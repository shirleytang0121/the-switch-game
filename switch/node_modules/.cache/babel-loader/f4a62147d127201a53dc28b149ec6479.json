{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Clamp = require('../math/Clamp');\n\nvar Class = require('../utils/Class');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar FindClosestInSorted = require('../utils/array/FindClosestInSorted');\n\nvar Frame = require('./AnimationFrame');\n\nvar GetValue = require('../utils/object/GetValue');\n/**\r\n * @classdesc\r\n * A Frame based Animation.\r\n *\r\n * This consists of a key, some default values (like the frame rate) and a bunch of Frame objects.\r\n *\r\n * The Animation Manager creates these. Game Objects don't own an instance of these directly.\r\n * Game Objects have the Animation Component, which are like playheads to global Animations (these objects)\r\n * So multiple Game Objects can have playheads all pointing to this one Animation instance.\r\n *\r\n * @class Animation\r\n * @memberof Phaser.Animations\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Animations.AnimationManager} manager - A reference to the global Animation Manager\r\n * @param {string} key - The unique identifying string for this animation.\r\n * @param {Phaser.Animations.Types.Animation} config - The Animation configuration.\r\n */\n\n\nvar Animation = new Class({\n  Extends: EventEmitter,\n  initialize: function Animation(manager, key, config) {\n    EventEmitter.call(this);\n    /**\r\n     * A reference to the global Animation Manager.\r\n     *\r\n     * @name Phaser.Animations.Animation#manager\r\n     * @type {Phaser.Animations.AnimationManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.manager = manager;\n    /**\r\n     * The unique identifying string for this animation.\r\n     *\r\n     * @name Phaser.Animations.Animation#key\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n\n    this.key = key;\n    /**\r\n     * A frame based animation (as opposed to a bone based animation)\r\n     *\r\n     * @name Phaser.Animations.Animation#type\r\n     * @type {string}\r\n     * @default frame\r\n     * @since 3.0.0\r\n     */\n\n    this.type = 'frame';\n    /**\r\n     * Extract all the frame data into the frames array.\r\n     *\r\n     * @name Phaser.Animations.Animation#frames\r\n     * @type {Phaser.Animations.AnimationFrame[]}\r\n     * @since 3.0.0\r\n     */\n\n    this.frames = this.getFrames(manager.textureManager, GetValue(config, 'frames', []), GetValue(config, 'defaultTextureKey', null));\n    /**\r\n     * The frame rate of playback in frames per second (default 24 if duration is null)\r\n     *\r\n     * @name Phaser.Animations.Animation#frameRate\r\n     * @type {integer}\r\n     * @default 24\r\n     * @since 3.0.0\r\n     */\n\n    this.frameRate = GetValue(config, 'frameRate', null);\n    /**\r\n     * How long the animation should play for, in milliseconds.\r\n     * If the `frameRate` property has been set then it overrides this value,\r\n     * otherwise the `frameRate` is derived from `duration`.\r\n     *\r\n     * @name Phaser.Animations.Animation#duration\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.duration = GetValue(config, 'duration', null);\n\n    if (this.duration === null && this.frameRate === null) {\n      //  No duration or frameRate given, use default frameRate of 24fps\n      this.frameRate = 24;\n      this.duration = this.frameRate / this.frames.length * 1000;\n    } else if (this.duration && this.frameRate === null) {\n      //  Duration given but no frameRate, so set the frameRate based on duration\n      //  I.e. 12 frames in the animation, duration = 4000 ms\n      //  So frameRate is 12 / (4000 / 1000) = 3 fps\n      this.frameRate = this.frames.length / (this.duration / 1000);\n    } else {\n      //  frameRate given, derive duration from it (even if duration also specified)\n      //  I.e. 15 frames in the animation, frameRate = 30 fps\n      //  So duration is 15 / 30 = 0.5 * 1000 (half a second, or 500ms)\n      this.duration = this.frames.length / this.frameRate * 1000;\n    }\n    /**\r\n     * How many ms per frame, not including frame specific modifiers.\r\n     *\r\n     * @name Phaser.Animations.Animation#msPerFrame\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.msPerFrame = 1000 / this.frameRate;\n    /**\r\n     * Skip frames if the time lags, or always advanced anyway?\r\n     *\r\n     * @name Phaser.Animations.Animation#skipMissedFrames\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.skipMissedFrames = GetValue(config, 'skipMissedFrames', true);\n    /**\r\n     * The delay in ms before the playback will begin.\r\n     *\r\n     * @name Phaser.Animations.Animation#delay\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.delay = GetValue(config, 'delay', 0);\n    /**\r\n     * Number of times to repeat the animation. Set to -1 to repeat forever.\r\n     *\r\n     * @name Phaser.Animations.Animation#repeat\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.repeat = GetValue(config, 'repeat', 0);\n    /**\r\n     * The delay in ms before the a repeat play starts.\r\n     *\r\n     * @name Phaser.Animations.Animation#repeatDelay\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.repeatDelay = GetValue(config, 'repeatDelay', 0);\n    /**\r\n     * Should the animation yoyo (reverse back down to the start) before repeating?\r\n     *\r\n     * @name Phaser.Animations.Animation#yoyo\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.yoyo = GetValue(config, 'yoyo', false);\n    /**\r\n     * Should the GameObject's `visible` property be set to `true` when the animation starts to play?\r\n     *\r\n     * @name Phaser.Animations.Animation#showOnStart\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.showOnStart = GetValue(config, 'showOnStart', false);\n    /**\r\n     * Should the GameObject's `visible` property be set to `false` when the animation finishes?\r\n     *\r\n     * @name Phaser.Animations.Animation#hideOnComplete\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.hideOnComplete = GetValue(config, 'hideOnComplete', false);\n    /**\r\n     * Global pause. All Game Objects using this Animation instance are impacted by this property.\r\n     *\r\n     * @name Phaser.Animations.Animation#paused\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.paused = false;\n    this.manager.on(Events.PAUSE_ALL, this.pause, this);\n    this.manager.on(Events.RESUME_ALL, this.resume, this);\n  },\n\n  /**\r\n   * Add frames to the end of the animation.\r\n   *\r\n   * @method Phaser.Animations.Animation#addFrame\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|Phaser.Animations.Types.AnimationFrame[])} config - [description]\r\n   *\r\n   * @return {Phaser.Animations.Animation} This Animation object.\r\n   */\n  addFrame: function addFrame(config) {\n    return this.addFrameAt(this.frames.length, config);\n  },\n\n  /**\r\n   * Add frame/s into the animation.\r\n   *\r\n   * @method Phaser.Animations.Animation#addFrameAt\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} index - The index to insert the frame at within the animation.\r\n   * @param {(string|Phaser.Animations.Types.AnimationFrame[])} config - [description]\r\n   *\r\n   * @return {Phaser.Animations.Animation} This Animation object.\r\n   */\n  addFrameAt: function addFrameAt(index, config) {\n    var newFrames = this.getFrames(this.manager.textureManager, config);\n\n    if (newFrames.length > 0) {\n      if (index === 0) {\n        this.frames = newFrames.concat(this.frames);\n      } else if (index === this.frames.length) {\n        this.frames = this.frames.concat(newFrames);\n      } else {\n        var pre = this.frames.slice(0, index);\n        var post = this.frames.slice(index);\n        this.frames = pre.concat(newFrames, post);\n      }\n\n      this.updateFrameSequence();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Check if the given frame index is valid.\r\n   *\r\n   * @method Phaser.Animations.Animation#checkFrame\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} index - The index to be checked.\r\n   *\r\n   * @return {boolean} `true` if the index is valid, otherwise `false`.\r\n   */\n  checkFrame: function checkFrame(index) {\n    return index >= 0 && index < this.frames.length;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Animations.Animation#completeAnimation\r\n   * @protected\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n   */\n  completeAnimation: function completeAnimation(component) {\n    if (this.hideOnComplete) {\n      component.parent.visible = false;\n    }\n\n    component.stop();\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Animations.Animation#getFirstTick\r\n   * @protected\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n   * @param {boolean} [includeDelay=true] - [description]\r\n   */\n  getFirstTick: function getFirstTick(component, includeDelay) {\n    if (includeDelay === undefined) {\n      includeDelay = true;\n    } //  When is the first update due?\n\n\n    component.accumulator = 0;\n    component.nextTick = component.msPerFrame + component.currentFrame.duration;\n\n    if (includeDelay) {\n      component.nextTick += component._delay;\n    }\n  },\n\n  /**\r\n   * Returns the AnimationFrame at the provided index\r\n   *\r\n   * @method Phaser.Animations.Animation#getFrameAt\r\n   * @protected\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} index - The index in the AnimationFrame array\r\n   *\r\n   * @return {Phaser.Animations.AnimationFrame} The frame at the index provided from the animation sequence\r\n   */\n  getFrameAt: function getFrameAt(index) {\n    return this.frames[index];\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Animations.Animation#getFrames\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Textures.TextureManager} textureManager - [description]\r\n   * @param {(string|Phaser.Animations.Types.AnimationFrame[])} frames - [description]\r\n   * @param {string} [defaultTextureKey] - [description]\r\n   *\r\n   * @return {Phaser.Animations.AnimationFrame[]} [description]\r\n   */\n  getFrames: function getFrames(textureManager, frames, defaultTextureKey) {\n    var out = [];\n    var prev;\n    var animationFrame;\n    var index = 1;\n    var i;\n    var textureKey; //  if frames is a string, we'll get all the frames from the texture manager as if it's a sprite sheet\n\n    if (typeof frames === 'string') {\n      textureKey = frames;\n      var texture = textureManager.get(textureKey);\n      var frameKeys = texture.getFrameNames();\n      frames = [];\n      frameKeys.forEach(function (idx, value) {\n        frames.push({\n          key: textureKey,\n          frame: value\n        });\n      });\n    }\n\n    if (!Array.isArray(frames) || frames.length === 0) {\n      return out;\n    }\n\n    for (i = 0; i < frames.length; i++) {\n      var item = frames[i];\n      var key = GetValue(item, 'key', defaultTextureKey);\n\n      if (!key) {\n        continue;\n      } //  Could be an integer or a string\n\n\n      var frame = GetValue(item, 'frame', 0); //  The actual texture frame\n\n      var textureFrame = textureManager.getFrame(key, frame);\n      animationFrame = new Frame(key, frame, index, textureFrame);\n      animationFrame.duration = GetValue(item, 'duration', 0);\n      animationFrame.isFirst = !prev; //  The previously created animationFrame\n\n      if (prev) {\n        prev.nextFrame = animationFrame;\n        animationFrame.prevFrame = prev;\n      }\n\n      out.push(animationFrame);\n      prev = animationFrame;\n      index++;\n    }\n\n    if (out.length > 0) {\n      animationFrame.isLast = true; //  Link them end-to-end, so they loop\n\n      animationFrame.nextFrame = out[0];\n      out[0].prevFrame = animationFrame; //  Generate the progress data\n\n      var slice = 1 / (out.length - 1);\n\n      for (i = 0; i < out.length; i++) {\n        out[i].progress = i * slice;\n      }\n    }\n\n    return out;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Animations.Animation#getNextTick\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n   */\n  getNextTick: function getNextTick(component) {\n    // accumulator += delta * _timeScale\n    // after a large delta surge (perf issue for example) we need to adjust for it here\n    //  When is the next update due?\n    component.accumulator -= component.nextTick;\n    component.nextTick = component.msPerFrame + component.currentFrame.duration;\n  },\n\n  /**\r\n   * Loads the Animation values into the Animation Component.\r\n   *\r\n   * @method Phaser.Animations.Animation#load\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Components.Animation} component - The Animation Component to load values into.\r\n   * @param {integer} startFrame - The start frame of the animation to load.\r\n   */\n  load: function load(component, startFrame) {\n    if (startFrame >= this.frames.length) {\n      startFrame = 0;\n    }\n\n    if (component.currentAnim !== this) {\n      component.currentAnim = this;\n      component.frameRate = this.frameRate;\n      component.duration = this.duration;\n      component.msPerFrame = this.msPerFrame;\n      component.skipMissedFrames = this.skipMissedFrames;\n      component._delay = this.delay;\n      component._repeat = this.repeat;\n      component._repeatDelay = this.repeatDelay;\n      component._yoyo = this.yoyo;\n    }\n\n    var frame = this.frames[startFrame];\n\n    if (startFrame === 0 && !component.forward) {\n      frame = this.getLastFrame();\n    }\n\n    component.updateFrame(frame);\n  },\n\n  /**\r\n   * Returns the frame closest to the given progress value between 0 and 1.\r\n   *\r\n   * @method Phaser.Animations.Animation#getFrameByProgress\r\n   * @since 3.4.0\r\n   *\r\n   * @param {number} value - A value between 0 and 1.\r\n   *\r\n   * @return {Phaser.Animations.AnimationFrame} The frame closest to the given progress value.\r\n   */\n  getFrameByProgress: function getFrameByProgress(value) {\n    value = Clamp(value, 0, 1);\n    return FindClosestInSorted(value, this.frames, 'progress');\n  },\n\n  /**\r\n   * Advance the animation frame.\r\n   *\r\n   * @method Phaser.Animations.Animation#nextFrame\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Components.Animation} component - The Animation Component to advance.\r\n   */\n  nextFrame: function nextFrame(component) {\n    var frame = component.currentFrame; //  TODO: Add frame skip support\n\n    if (frame.isLast) {\n      //  We're at the end of the animation\n      //  Yoyo? (happens before repeat)\n      if (component._yoyo) {\n        this.handleYoyoFrame(component, false);\n      } else if (component.repeatCounter > 0) {\n        //  Repeat (happens before complete)\n        if (component._reverse && component.forward) {\n          component.forward = false;\n        } else {\n          this.repeatAnimation(component);\n        }\n      } else {\n        this.completeAnimation(component);\n      }\n    } else {\n      this.updateAndGetNextTick(component, frame.nextFrame);\n    }\n  },\n\n  /**\r\n   * Handle the yoyo functionality in nextFrame and previousFrame methods.\r\n   *\r\n   * @method Phaser.Animations.Animation#handleYoyoFrame\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {Phaser.GameObjects.Components.Animation} component - The Animation Component to advance.\r\n   * @param {boolean} isReverse - Is animation in reverse mode? (Default: false)\r\n   */\n  handleYoyoFrame: function handleYoyoFrame(component, isReverse) {\n    if (!isReverse) {\n      isReverse = false;\n    }\n\n    if (component._reverse === !isReverse && component.repeatCounter > 0) {\n      component.forward = isReverse;\n      this.repeatAnimation(component);\n      return;\n    }\n\n    if (component._reverse !== isReverse && component.repeatCounter === 0) {\n      this.completeAnimation(component);\n      return;\n    }\n\n    component.forward = isReverse;\n    var frame = isReverse ? component.currentFrame.nextFrame : component.currentFrame.prevFrame;\n    this.updateAndGetNextTick(component, frame);\n  },\n\n  /**\r\n   * Returns the animation last frame.\r\n   *\r\n   * @method Phaser.Animations.Animation#getLastFrame\r\n   * @since 3.12.0\r\n   *\r\n   * @return {Phaser.Animations.AnimationFrame} component - The Animation Last Frame.\r\n   */\n  getLastFrame: function getLastFrame() {\n    return this.frames[this.frames.length - 1];\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Animations.Animation#previousFrame\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n   */\n  previousFrame: function previousFrame(component) {\n    var frame = component.currentFrame; //  TODO: Add frame skip support\n\n    if (frame.isFirst) {\n      //  We're at the start of the animation\n      if (component._yoyo) {\n        this.handleYoyoFrame(component, true);\n      } else if (component.repeatCounter > 0) {\n        if (component._reverse && !component.forward) {\n          component.currentFrame = this.getLastFrame();\n          this.repeatAnimation(component);\n        } else {\n          //  Repeat (happens before complete)\n          component.forward = true;\n          this.repeatAnimation(component);\n        }\n      } else {\n        this.completeAnimation(component);\n      }\n    } else {\n      this.updateAndGetNextTick(component, frame.prevFrame);\n    }\n  },\n\n  /**\r\n   * Update Frame and Wait next tick.\r\n   *\r\n   * @method Phaser.Animations.Animation#updateAndGetNextTick\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {Phaser.Animations.AnimationFrame} frame - An Animation frame.\r\n   */\n  updateAndGetNextTick: function updateAndGetNextTick(component, frame) {\n    component.updateFrame(frame);\n    this.getNextTick(component);\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Animations.Animation#removeFrame\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Animations.AnimationFrame} frame - [description]\r\n   *\r\n   * @return {Phaser.Animations.Animation} This Animation object.\r\n   */\n  removeFrame: function removeFrame(frame) {\n    var index = this.frames.indexOf(frame);\n\n    if (index !== -1) {\n      this.removeFrameAt(index);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes a frame from the AnimationFrame array at the provided index\r\n   * and updates the animation accordingly.\r\n   *\r\n   * @method Phaser.Animations.Animation#removeFrameAt\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} index - The index in the AnimationFrame array\r\n   *\r\n   * @return {Phaser.Animations.Animation} This Animation object.\r\n   */\n  removeFrameAt: function removeFrameAt(index) {\n    this.frames.splice(index, 1);\n    this.updateFrameSequence();\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Animations.Animation#repeatAnimation\r\n   * @fires Phaser.Animations.Events#ANIMATION_REPEAT\r\n   * @fires Phaser.Animations.Events#SPRITE_ANIMATION_REPEAT\r\n   * @fires Phaser.Animations.Events#SPRITE_ANIMATION_KEY_REPEAT\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n   */\n  repeatAnimation: function repeatAnimation(component) {\n    if (component._pendingStop === 2) {\n      return this.completeAnimation(component);\n    }\n\n    if (component._repeatDelay > 0 && component.pendingRepeat === false) {\n      component.pendingRepeat = true;\n      component.accumulator -= component.nextTick;\n      component.nextTick += component._repeatDelay;\n    } else {\n      component.repeatCounter--;\n      component.updateFrame(component.currentFrame[component.forward ? 'nextFrame' : 'prevFrame']);\n\n      if (component.isPlaying) {\n        this.getNextTick(component);\n        component.pendingRepeat = false;\n        var frame = component.currentFrame;\n        var parent = component.parent;\n        this.emit(Events.ANIMATION_REPEAT, this, frame);\n        parent.emit(Events.SPRITE_ANIMATION_KEY_REPEAT + this.key, this, frame, component.repeatCounter, parent);\n        parent.emit(Events.SPRITE_ANIMATION_REPEAT, this, frame, component.repeatCounter, parent);\n      }\n    }\n  },\n\n  /**\r\n   * Sets the texture frame the animation uses for rendering.\r\n   *\r\n   * @method Phaser.Animations.Animation#setFrame\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n   */\n  setFrame: function setFrame(component) {\n    //  Work out which frame should be set next on the child, and set it\n    if (component.forward) {\n      this.nextFrame(component);\n    } else {\n      this.previousFrame(component);\n    }\n  },\n\n  /**\r\n   * Converts the animation data to JSON.\r\n   *\r\n   * @method Phaser.Animations.Animation#toJSON\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Animations.Types.JSONAnimation} [description]\r\n   */\n  toJSON: function toJSON() {\n    var output = {\n      key: this.key,\n      type: this.type,\n      frames: [],\n      frameRate: this.frameRate,\n      duration: this.duration,\n      skipMissedFrames: this.skipMissedFrames,\n      delay: this.delay,\n      repeat: this.repeat,\n      repeatDelay: this.repeatDelay,\n      yoyo: this.yoyo,\n      showOnStart: this.showOnStart,\n      hideOnComplete: this.hideOnComplete\n    };\n    this.frames.forEach(function (frame) {\n      output.frames.push(frame.toJSON());\n    });\n    return output;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Animations.Animation#updateFrameSequence\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Animations.Animation} This Animation object.\r\n   */\n  updateFrameSequence: function updateFrameSequence() {\n    var len = this.frames.length;\n    var slice = 1 / (len - 1);\n\n    for (var i = 0; i < len; i++) {\n      var frame = this.frames[i];\n      frame.index = i + 1;\n      frame.isFirst = false;\n      frame.isLast = false;\n      frame.progress = i * slice;\n\n      if (i === 0) {\n        frame.isFirst = true;\n        frame.isLast = len === 1;\n        frame.prevFrame = this.frames[len - 1];\n        frame.nextFrame = this.frames[i + 1];\n      } else if (i === len - 1) {\n        frame.isLast = true;\n        frame.prevFrame = this.frames[len - 2];\n        frame.nextFrame = this.frames[0];\n      } else if (len > 1) {\n        frame.prevFrame = this.frames[i - 1];\n        frame.nextFrame = this.frames[i + 1];\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Animations.Animation#pause\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Animations.Animation} This Animation object.\r\n   */\n  pause: function pause() {\n    this.paused = true;\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Animations.Animation#resume\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Animations.Animation} This Animation object.\r\n   */\n  resume: function resume() {\n    this.paused = false;\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Animations.Animation#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    this.removeAllListeners();\n    this.manager.off(Events.PAUSE_ALL, this.pause, this);\n    this.manager.off(Events.RESUME_ALL, this.resume, this);\n    this.manager.remove(this.key);\n\n    for (var i = 0; i < this.frames.length; i++) {\n      this.frames[i].destroy();\n    }\n\n    this.frames = [];\n    this.manager = null;\n  }\n});\nmodule.exports = Animation;","map":null,"metadata":{},"sourceType":"script"}