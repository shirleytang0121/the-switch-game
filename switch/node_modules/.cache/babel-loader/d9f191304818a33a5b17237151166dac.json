{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Commands = require('./Commands');\n\nvar Utils = require('../../renderer/webgl/Utils'); //  TODO: Remove the use of this\n\n\nvar Point = function Point(x, y, width) {\n  this.x = x;\n  this.y = y;\n  this.width = width;\n}; //  TODO: Remove the use of this\n\n\nvar Path = function Path(x, y, width) {\n  this.points = [];\n  this.pointsLength = 1;\n  this.points[0] = new Point(x, y, width);\n};\n\nvar matrixStack = [];\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Graphics#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Graphics} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\n\nvar GraphicsWebGLRenderer = function GraphicsWebGLRenderer(renderer, src, interpolationPercentage, camera, parentMatrix) {\n  if (src.commandBuffer.length === 0) {\n    return;\n  }\n\n  var pipeline = renderer.currentPipeline;\n  var camMatrix = pipeline._tempMatrix1;\n  var graphicsMatrix = pipeline._tempMatrix2;\n  var currentMatrix = pipeline._tempMatrix4;\n  renderer.setPipeline(pipeline);\n  currentMatrix.loadIdentity();\n  graphicsMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\n  camMatrix.copyFrom(camera.matrix);\n\n  if (parentMatrix) {\n    //  Multiply the camera by the parent matrix\n    camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY); //  Undo the camera scroll\n\n    graphicsMatrix.e = src.x;\n    graphicsMatrix.f = src.y; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n    camMatrix.multiply(graphicsMatrix);\n  } else {\n    graphicsMatrix.e -= camera.scrollX * src.scrollFactorX;\n    graphicsMatrix.f -= camera.scrollY * src.scrollFactorY; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n    camMatrix.multiply(graphicsMatrix);\n  }\n\n  var commands = src.commandBuffer;\n  var alpha = camera.alpha * src.alpha;\n  var lineWidth = 1;\n  var fillTint = pipeline.fillTint;\n  var strokeTint = pipeline.strokeTint;\n  var tx = 0;\n  var ty = 0;\n  var ta = 0;\n  var iterStep = 0.01;\n  var PI2 = Math.PI * 2;\n  var cmd;\n  var path = [];\n  var pathIndex = 0;\n  var pathOpen = false;\n  var lastPath = null;\n  var getTint = Utils.getTintAppendFloatAlphaAndSwap;\n  var currentTexture = renderer.blankTexture.glTexture;\n\n  for (var cmdIndex = 0; cmdIndex < commands.length; cmdIndex++) {\n    cmd = commands[cmdIndex];\n\n    switch (cmd) {\n      case Commands.BEGIN_PATH:\n        path.length = 0;\n        lastPath = null;\n        pathOpen = true;\n        break;\n\n      case Commands.CLOSE_PATH:\n        pathOpen = false;\n\n        if (lastPath && lastPath.points.length) {\n          lastPath.points.push(lastPath.points[0]);\n        }\n\n        break;\n\n      case Commands.FILL_PATH:\n        for (pathIndex = 0; pathIndex < path.length; pathIndex++) {\n          pipeline.setTexture2D(currentTexture);\n          pipeline.batchFillPath(path[pathIndex].points, currentMatrix, camMatrix);\n        }\n\n        break;\n\n      case Commands.STROKE_PATH:\n        for (pathIndex = 0; pathIndex < path.length; pathIndex++) {\n          pipeline.setTexture2D(currentTexture);\n          pipeline.batchStrokePath(path[pathIndex].points, lineWidth, pathOpen, currentMatrix, camMatrix);\n        }\n\n        break;\n\n      case Commands.LINE_STYLE:\n        lineWidth = commands[++cmdIndex];\n        var strokeColor = commands[++cmdIndex];\n        var strokeAlpha = commands[++cmdIndex] * alpha;\n        var strokeTintColor = getTint(strokeColor, strokeAlpha);\n        strokeTint.TL = strokeTintColor;\n        strokeTint.TR = strokeTintColor;\n        strokeTint.BL = strokeTintColor;\n        strokeTint.BR = strokeTintColor;\n        break;\n\n      case Commands.FILL_STYLE:\n        var fillColor = commands[++cmdIndex];\n        var fillAlpha = commands[++cmdIndex] * alpha;\n        var fillTintColor = getTint(fillColor, fillAlpha);\n        fillTint.TL = fillTintColor;\n        fillTint.TR = fillTintColor;\n        fillTint.BL = fillTintColor;\n        fillTint.BR = fillTintColor;\n        break;\n\n      case Commands.GRADIENT_FILL_STYLE:\n        var gradientFillAlpha = commands[++cmdIndex] * alpha;\n        fillTint.TL = getTint(commands[++cmdIndex], gradientFillAlpha);\n        fillTint.TR = getTint(commands[++cmdIndex], gradientFillAlpha);\n        fillTint.BL = getTint(commands[++cmdIndex], gradientFillAlpha);\n        fillTint.BR = getTint(commands[++cmdIndex], gradientFillAlpha);\n        break;\n\n      case Commands.GRADIENT_LINE_STYLE:\n        lineWidth = commands[++cmdIndex];\n        var gradientLineAlpha = commands[++cmdIndex] * alpha;\n        strokeTint.TL = getTint(commands[++cmdIndex], gradientLineAlpha);\n        strokeTint.TR = getTint(commands[++cmdIndex], gradientLineAlpha);\n        strokeTint.BL = getTint(commands[++cmdIndex], gradientLineAlpha);\n        strokeTint.BR = getTint(commands[++cmdIndex], gradientLineAlpha);\n        break;\n\n      case Commands.ARC:\n        var iteration = 0;\n        var x = commands[++cmdIndex];\n        var y = commands[++cmdIndex];\n        var radius = commands[++cmdIndex];\n        var startAngle = commands[++cmdIndex];\n        var endAngle = commands[++cmdIndex];\n        var anticlockwise = commands[++cmdIndex];\n        var overshoot = commands[++cmdIndex];\n        endAngle -= startAngle;\n\n        if (anticlockwise) {\n          if (endAngle < -PI2) {\n            endAngle = -PI2;\n          } else if (endAngle > 0) {\n            endAngle = -PI2 + endAngle % PI2;\n          }\n        } else if (endAngle > PI2) {\n          endAngle = PI2;\n        } else if (endAngle < 0) {\n          endAngle = PI2 + endAngle % PI2;\n        }\n\n        if (lastPath === null) {\n          lastPath = new Path(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius, lineWidth);\n          path.push(lastPath);\n          iteration += iterStep;\n        }\n\n        while (iteration < 1 + overshoot) {\n          ta = endAngle * iteration + startAngle;\n          tx = x + Math.cos(ta) * radius;\n          ty = y + Math.sin(ta) * radius;\n          lastPath.points.push(new Point(tx, ty, lineWidth));\n          iteration += iterStep;\n        }\n\n        ta = endAngle + startAngle;\n        tx = x + Math.cos(ta) * radius;\n        ty = y + Math.sin(ta) * radius;\n        lastPath.points.push(new Point(tx, ty, lineWidth));\n        break;\n\n      case Commands.FILL_RECT:\n        pipeline.setTexture2D(currentTexture);\n        pipeline.batchFillRect(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, camMatrix);\n        break;\n\n      case Commands.FILL_TRIANGLE:\n        pipeline.setTexture2D(currentTexture);\n        pipeline.batchFillTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, camMatrix);\n        break;\n\n      case Commands.STROKE_TRIANGLE:\n        pipeline.setTexture2D(currentTexture);\n        pipeline.batchStrokeTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], lineWidth, currentMatrix, camMatrix);\n        break;\n\n      case Commands.LINE_TO:\n        if (lastPath !== null) {\n          lastPath.points.push(new Point(commands[++cmdIndex], commands[++cmdIndex], lineWidth));\n        } else {\n          lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);\n          path.push(lastPath);\n        }\n\n        break;\n\n      case Commands.MOVE_TO:\n        lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);\n        path.push(lastPath);\n        break;\n\n      case Commands.SAVE:\n        matrixStack.push(currentMatrix.copyToArray());\n        break;\n\n      case Commands.RESTORE:\n        currentMatrix.copyFromArray(matrixStack.pop());\n        break;\n\n      case Commands.TRANSLATE:\n        x = commands[++cmdIndex];\n        y = commands[++cmdIndex];\n        currentMatrix.translate(x, y);\n        break;\n\n      case Commands.SCALE:\n        x = commands[++cmdIndex];\n        y = commands[++cmdIndex];\n        currentMatrix.scale(x, y);\n        break;\n\n      case Commands.ROTATE:\n        currentMatrix.rotate(commands[++cmdIndex]);\n        break;\n\n      case Commands.SET_TEXTURE:\n        var frame = commands[++cmdIndex];\n        var mode = commands[++cmdIndex];\n        pipeline.currentFrame = frame;\n        pipeline.setTexture2D(frame.glTexture, 0);\n        pipeline.tintEffect = mode;\n        currentTexture = frame.glTexture;\n        break;\n\n      case Commands.CLEAR_TEXTURE:\n        pipeline.currentFrame = renderer.blankTexture;\n        pipeline.tintEffect = 2;\n        currentTexture = renderer.blankTexture.glTexture;\n        break;\n    }\n  }\n};\n\nmodule.exports = GraphicsWebGLRenderer;","map":null,"metadata":{},"sourceType":"script"}