{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar CONST = require('./const');\n\nvar Events = require('./events');\n\nvar GameEvents = require('../core/events');\n\nvar GetValue = require('../utils/object/GetValue');\n\nvar LoaderEvents = require('../loader/events');\n\nvar NOOP = require('../utils/NOOP');\n\nvar Scene = require('./Scene');\n\nvar Systems = require('./Systems');\n/**\r\n * @classdesc\r\n * The Scene Manager.\r\n *\r\n * The Scene Manager is a Game level system, responsible for creating, processing and updating all of the\r\n * Scenes in a Game instance.\r\n *\r\n *\r\n * @class SceneManager\r\n * @memberof Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser.Game instance this Scene Manager belongs to.\r\n * @param {object} sceneConfig - Scene specific configuration settings.\r\n */\n\n\nvar SceneManager = new Class({\n  initialize: function SceneManager(game, sceneConfig) {\n    /**\r\n     * The Game that this SceneManager belongs to.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#game\r\n     * @type {Phaser.Game}\r\n     * @since 3.0.0\r\n     */\n    this.game = game;\n    /**\r\n     * An object that maps the keys to the scene so we can quickly get a scene from a key without iteration.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#keys\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.keys = {};\n    /**\r\n     * The array in which all of the scenes are kept.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#scenes\r\n     * @type {array}\r\n     * @since 3.0.0\r\n     */\n\n    this.scenes = [];\n    /**\r\n     * Scenes pending to be added are stored in here until the manager has time to add it.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#_pending\r\n     * @type {array}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._pending = [];\n    /**\r\n     * An array of scenes waiting to be started once the game has booted.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#_start\r\n     * @type {array}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._start = [];\n    /**\r\n     * An operations queue, because we don't manipulate the scenes array during processing.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#_queue\r\n     * @type {array}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._queue = [];\n    /**\r\n     * Boot time data to merge.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#_data\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.4.0\r\n     */\n\n    this._data = {};\n    /**\r\n     * Is the Scene Manager actively processing the Scenes list?\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#isProcessing\r\n     * @type {boolean}\r\n     * @default false\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\n\n    this.isProcessing = false;\n    /**\r\n     * Has the Scene Manager properly started?\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#isBooted\r\n     * @type {boolean}\r\n     * @default false\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\n\n    this.isBooted = false;\n    /**\r\n     * Do any of the Cameras in any of the Scenes require a custom viewport?\r\n     * If not we can skip scissor tests.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#customViewports\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.12.0\r\n     */\n\n    this.customViewports = 0;\n\n    if (sceneConfig) {\n      if (!Array.isArray(sceneConfig)) {\n        sceneConfig = [sceneConfig];\n      }\n\n      for (var i = 0; i < sceneConfig.length; i++) {\n        //  The i === 0 part just autostarts the first Scene given (unless it says otherwise in its config)\n        this._pending.push({\n          key: 'default',\n          scene: sceneConfig[i],\n          autoStart: i === 0,\n          data: {}\n        });\n      }\n    }\n\n    game.events.once(GameEvents.READY, this.bootQueue, this);\n  },\n\n  /**\r\n   * Internal first-time Scene boot handler.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#bootQueue\r\n   * @private\r\n   * @since 3.2.0\r\n   */\n  bootQueue: function bootQueue() {\n    if (this.isBooted) {\n      return;\n    }\n\n    var i;\n    var entry;\n    var key;\n    var sceneConfig;\n\n    for (i = 0; i < this._pending.length; i++) {\n      entry = this._pending[i];\n      key = entry.key;\n      sceneConfig = entry.scene;\n      var newScene;\n\n      if (sceneConfig instanceof Scene) {\n        newScene = this.createSceneFromInstance(key, sceneConfig);\n      } else if (typeof sceneConfig === 'object') {\n        newScene = this.createSceneFromObject(key, sceneConfig);\n      } else if (typeof sceneConfig === 'function') {\n        newScene = this.createSceneFromFunction(key, sceneConfig);\n      } //  Replace key in case the scene changed it\n\n\n      key = newScene.sys.settings.key;\n      this.keys[key] = newScene;\n      this.scenes.push(newScene); //  Any data to inject?\n\n      if (this._data[key]) {\n        newScene.sys.settings.data = this._data[key].data;\n\n        if (this._data[key].autoStart) {\n          entry.autoStart = true;\n        }\n      }\n\n      if (entry.autoStart || newScene.sys.settings.active) {\n        this._start.push(key);\n      }\n    } //  Clear the pending lists\n\n\n    this._pending.length = 0;\n    this._data = {};\n    this.isBooted = true; //  _start might have been populated by the above\n\n    for (i = 0; i < this._start.length; i++) {\n      entry = this._start[i];\n      this.start(entry);\n    }\n\n    this._start.length = 0;\n  },\n\n  /**\r\n   * Process the Scene operations queue.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#processQueue\r\n   * @since 3.0.0\r\n   */\n  processQueue: function processQueue() {\n    var pendingLength = this._pending.length;\n    var queueLength = this._queue.length;\n\n    if (pendingLength === 0 && queueLength === 0) {\n      return;\n    }\n\n    var i;\n    var entry;\n\n    if (pendingLength) {\n      for (i = 0; i < pendingLength; i++) {\n        entry = this._pending[i];\n        this.add(entry.key, entry.scene, entry.autoStart, entry.data);\n      } //  _start might have been populated by this.add\n\n\n      for (i = 0; i < this._start.length; i++) {\n        entry = this._start[i];\n        this.start(entry);\n      } //  Clear the pending lists\n\n\n      this._start.length = 0;\n      this._pending.length = 0;\n      return;\n    }\n\n    for (i = 0; i < this._queue.length; i++) {\n      entry = this._queue[i];\n      this[entry.op](entry.keyA, entry.keyB);\n    }\n\n    this._queue.length = 0;\n  },\n\n  /**\r\n   * Adds a new Scene into the SceneManager.\r\n   * You must give each Scene a unique key by which you'll identify it.\r\n   *\r\n   * The `sceneConfig` can be:\r\n   *\r\n   * * A `Phaser.Scene` object, or an object that extends it.\r\n   * * A plain JavaScript object\r\n   * * A JavaScript ES6 Class that extends `Phaser.Scene`\r\n   * * A JavaScript ES5 prototype based Class\r\n   * * A JavaScript function\r\n   *\r\n   * If a function is given then a new Scene will be created by calling it.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#add\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - A unique key used to reference the Scene, i.e. `MainMenu` or `Level1`.\r\n   * @param {(Phaser.Scene|Phaser.Scenes.Settings.Config|function)} sceneConfig - The config for the Scene\r\n   * @param {boolean} [autoStart=false] - If `true` the Scene will be started immediately after being added.\r\n   * @param {object} [data] - Optional data object. This will be set as Scene.settings.data and passed to `Scene.init`.\r\n   *\r\n   * @return {?Phaser.Scene} The added Scene, if it was added immediately, otherwise `null`.\r\n   */\n  add: function add(key, sceneConfig, autoStart, data) {\n    if (autoStart === undefined) {\n      autoStart = false;\n    }\n\n    if (data === undefined) {\n      data = {};\n    } //  If processing or not booted then put scene into a holding pattern\n\n\n    if (this.isProcessing || !this.isBooted) {\n      this._pending.push({\n        key: key,\n        scene: sceneConfig,\n        autoStart: autoStart,\n        data: data\n      });\n\n      if (!this.isBooted) {\n        this._data[key] = {\n          data: data\n        };\n      }\n\n      return null;\n    }\n\n    key = this.getKey(key, sceneConfig);\n    var newScene;\n\n    if (sceneConfig instanceof Scene) {\n      newScene = this.createSceneFromInstance(key, sceneConfig);\n    } else if (typeof sceneConfig === 'object') {\n      sceneConfig.key = key;\n      newScene = this.createSceneFromObject(key, sceneConfig);\n    } else if (typeof sceneConfig === 'function') {\n      newScene = this.createSceneFromFunction(key, sceneConfig);\n    } //  Any data to inject?\n\n\n    newScene.sys.settings.data = data; //  Replace key in case the scene changed it\n\n    key = newScene.sys.settings.key;\n    this.keys[key] = newScene;\n    this.scenes.push(newScene);\n\n    if (autoStart || newScene.sys.settings.active) {\n      if (this._pending.length) {\n        this._start.push(key);\n      } else {\n        this.start(key);\n      }\n    }\n\n    return newScene;\n  },\n\n  /**\r\n   * Removes a Scene from the SceneManager.\r\n   *\r\n   * The Scene is removed from the local scenes array, it's key is cleared from the keys\r\n   * cache and Scene.Systems.destroy is then called on it.\r\n   *\r\n   * If the SceneManager is processing the Scenes when this method is called it will\r\n   * queue the operation for the next update sequence.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#remove\r\n   * @since 3.2.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} scene - The Scene to be removed.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  remove: function remove(key) {\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'remove',\n        keyA: key,\n        keyB: null\n      });\n    } else {\n      var sceneToRemove = this.getScene(key);\n\n      if (!sceneToRemove || sceneToRemove.sys.isTransitioning()) {\n        return this;\n      }\n\n      var index = this.scenes.indexOf(sceneToRemove);\n      var sceneKey = sceneToRemove.sys.settings.key;\n\n      if (index > -1) {\n        delete this.keys[sceneKey];\n        this.scenes.splice(index, 1);\n\n        if (this._start.indexOf(sceneKey) > -1) {\n          index = this._start.indexOf(sceneKey);\n\n          this._start.splice(index, 1);\n        }\n\n        sceneToRemove.sys.destroy();\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Boot the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#bootScene\r\n   * @private\r\n   * @fires Phaser.Scenes.Events#TRANSITION_INIT\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Scene} scene - The Scene to boot.\r\n   */\n  bootScene: function bootScene(scene) {\n    var sys = scene.sys;\n    var settings = sys.settings;\n\n    if (scene.init) {\n      scene.init.call(scene, settings.data);\n      settings.status = CONST.INIT;\n\n      if (settings.isTransition) {\n        sys.events.emit(Events.TRANSITION_INIT, settings.transitionFrom, settings.transitionDuration);\n      }\n    }\n\n    var loader;\n\n    if (sys.load) {\n      loader = sys.load;\n      loader.reset();\n    }\n\n    if (loader && scene.preload) {\n      scene.preload.call(scene); //  Is the loader empty?\n\n      if (loader.list.size === 0) {\n        this.create(scene);\n      } else {\n        settings.status = CONST.LOADING; //  Start the loader going as we have something in the queue\n\n        loader.once(LoaderEvents.COMPLETE, this.loadComplete, this);\n        loader.start();\n      }\n    } else {\n      //  No preload? Then there was nothing to load either\n      this.create(scene);\n    }\n  },\n\n  /**\r\n   * Handles load completion for a Scene's Loader.\r\n   *\r\n   * Starts the Scene that the Loader belongs to.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#loadComplete\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading.\r\n   */\n  loadComplete: function loadComplete(loader) {\n    var scene = loader.scene; // Try to unlock HTML5 sounds every time any loader completes\n\n    if (this.game.sound.onBlurPausedSounds) {\n      this.game.sound.unlock();\n    }\n\n    this.create(scene);\n  },\n\n  /**\r\n   * Handle payload completion for a Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#payloadComplete\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading its Scene's payload.\r\n   */\n  payloadComplete: function payloadComplete(loader) {\n    this.bootScene(loader.scene);\n  },\n\n  /**\r\n   * Updates the Scenes.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#update\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} time - Time elapsed.\r\n   * @param {number} delta - Delta time from the last update.\r\n   */\n  update: function update(time, delta) {\n    this.processQueue();\n    this.isProcessing = true; //  Loop through the active scenes in reverse order\n\n    for (var i = this.scenes.length - 1; i >= 0; i--) {\n      var sys = this.scenes[i].sys;\n\n      if (sys.settings.status > CONST.START && sys.settings.status <= CONST.RUNNING) {\n        sys.step(time, delta);\n      }\n    }\n  },\n\n  /**\r\n   * Renders the Scenes.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#render\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer to use.\r\n   */\n  render: function render(renderer) {\n    //  Loop through the scenes in forward order\n    for (var i = 0; i < this.scenes.length; i++) {\n      var sys = this.scenes[i].sys;\n\n      if (sys.settings.visible && sys.settings.status >= CONST.LOADING && sys.settings.status < CONST.SLEEPING) {\n        sys.render(renderer);\n      }\n    }\n\n    this.isProcessing = false;\n  },\n\n  /**\r\n   * Calls the given Scene's {@link Phaser.Scene#create} method and updates its status.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#create\r\n   * @private\r\n   * @fires Phaser.Scenes.Events#TRANSITION_INIT\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Scene} scene - The Scene to create.\r\n   */\n  create: function create(scene) {\n    var sys = scene.sys;\n    var settings = sys.settings;\n\n    if (scene.create) {\n      settings.status = CONST.CREATING;\n      scene.create.call(scene, settings.data);\n    }\n\n    if (settings.isTransition) {\n      sys.events.emit(Events.TRANSITION_START, settings.transitionFrom, settings.transitionDuration);\n    } //  If the Scene has an update function we'll set it now, otherwise it'll remain as NOOP\n\n\n    if (scene.update) {\n      sys.sceneUpdate = scene.update;\n    }\n\n    settings.status = CONST.RUNNING;\n  },\n\n  /**\r\n   * Creates and initializes a Scene from a function.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#createSceneFromFunction\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The key of the Scene.\r\n   * @param {function} scene - The function to create the Scene from.\r\n   *\r\n   * @return {Phaser.Scene} The created Scene.\r\n   */\n  createSceneFromFunction: function createSceneFromFunction(key, scene) {\n    var newScene = new scene();\n\n    if (newScene instanceof Scene) {\n      var configKey = newScene.sys.settings.key;\n\n      if (configKey !== '') {\n        key = configKey;\n      }\n\n      if (this.keys.hasOwnProperty(key)) {\n        throw new Error('Cannot add a Scene with duplicate key: ' + key);\n      }\n\n      return this.createSceneFromInstance(key, newScene);\n    } else {\n      newScene.sys = new Systems(newScene);\n      newScene.sys.settings.key = key;\n      newScene.sys.init(this.game);\n      return newScene;\n    }\n  },\n\n  /**\r\n   * Creates and initializes a Scene instance.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#createSceneFromInstance\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The key of the Scene.\r\n   * @param {Phaser.Scene} newScene - The Scene instance.\r\n   *\r\n   * @return {Phaser.Scene} The created Scene.\r\n   */\n  createSceneFromInstance: function createSceneFromInstance(key, newScene) {\n    var configKey = newScene.sys.settings.key;\n\n    if (configKey !== '') {\n      key = configKey;\n    } else {\n      newScene.sys.settings.key = key;\n    }\n\n    newScene.sys.init(this.game);\n    return newScene;\n  },\n\n  /**\r\n   * Creates and initializes a Scene from an Object definition.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#createSceneFromObject\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The key of the Scene.\r\n   * @param {(string|Phaser.Scenes.Settings.Config)} sceneConfig - The Scene config.\r\n   *\r\n   * @return {Phaser.Scene} The created Scene.\r\n   */\n  createSceneFromObject: function createSceneFromObject(key, sceneConfig) {\n    var newScene = new Scene(sceneConfig);\n    var configKey = newScene.sys.settings.key;\n\n    if (configKey !== '') {\n      key = configKey;\n    } else {\n      newScene.sys.settings.key = key;\n    }\n\n    newScene.sys.init(this.game); //  Extract callbacks\n\n    var defaults = ['init', 'preload', 'create', 'update', 'render'];\n\n    for (var i = 0; i < defaults.length; i++) {\n      var sceneCallback = GetValue(sceneConfig, defaults[i], null);\n\n      if (sceneCallback) {\n        newScene[defaults[i]] = sceneCallback;\n      }\n    } //  Now let's move across any other functions or properties that may exist in the extend object:\n\n    /*\r\n    scene: {\r\n        preload: preload,\r\n        create: create,\r\n        extend: {\r\n            hello: 1,\r\n            test: 'atari',\r\n            addImage: addImage\r\n        }\r\n    }\r\n    */\n\n\n    if (sceneConfig.hasOwnProperty('extend')) {\n      for (var propertyKey in sceneConfig.extend) {\n        var value = sceneConfig.extend[propertyKey];\n\n        if (propertyKey === 'data' && newScene.hasOwnProperty('data') && typeof value === 'object') {\n          //  Populate the DataManager\n          newScene.data.merge(value);\n        } else if (propertyKey !== 'sys') {\n          newScene[propertyKey] = value;\n        }\n      }\n    }\n\n    return newScene;\n  },\n\n  /**\r\n   * Retrieves the key of a Scene from a Scene config.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#getKey\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The key to check in the Scene config.\r\n   * @param {(Phaser.Scene|Phaser.Scenes.Settings.Config|function)} sceneConfig - The Scene config.\r\n   *\r\n   * @return {string} The Scene key.\r\n   */\n  getKey: function getKey(key, sceneConfig) {\n    if (!key) {\n      key = 'default';\n    }\n\n    if (typeof sceneConfig === 'function') {\n      return key;\n    } else if (sceneConfig instanceof Scene) {\n      key = sceneConfig.sys.settings.key;\n    } else if (typeof sceneConfig === 'object' && sceneConfig.hasOwnProperty('key')) {\n      key = sceneConfig.key;\n    } //  By this point it's either 'default' or extracted from the Scene\n\n\n    if (this.keys.hasOwnProperty(key)) {\n      throw new Error('Cannot add a Scene with duplicate key: ' + key);\n    } else {\n      return key;\n    }\n  },\n\n  /**\r\n   * Returns an array of all the current Scenes being managed by this Scene Manager.\r\n   * \r\n   * You can filter the output by the active state of the Scene and choose to have\r\n   * the array returned in normal or reversed order.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#getScenes\r\n   * @since 3.16.0\r\n   *\r\n   * @param {boolean} [isActive=true] - Only include Scene's that are currently active?\r\n   * @param {boolean} [inReverse=false] - Return the array of Scenes in reverse?\r\n   *\r\n   * @return {Phaser.Scene[]} An array containing all of the Scenes in the Scene Manager.\r\n   */\n  getScenes: function getScenes(isActive, inReverse) {\n    if (isActive === undefined) {\n      isActive = true;\n    }\n\n    if (inReverse === undefined) {\n      inReverse = false;\n    }\n\n    var out = [];\n    var scenes = this.scenes;\n\n    for (var i = 0; i < scenes.length; i++) {\n      var scene = scenes[i];\n\n      if (scene && (!isActive || isActive && scene.sys.isActive())) {\n        out.push(scene);\n      }\n    }\n\n    return inReverse ? out.reverse() : out;\n  },\n\n  /**\r\n   * Retrieves a Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#getScene\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string|Phaser.Scene} key - The Scene to retrieve.\r\n   *\r\n   * @return {?Phaser.Scene} The Scene.\r\n   */\n  getScene: function getScene(key) {\n    if (typeof key === 'string') {\n      if (this.keys[key]) {\n        return this.keys[key];\n      }\n    } else {\n      for (var i = 0; i < this.scenes.length; i++) {\n        if (key === this.scenes[i]) {\n          return key;\n        }\n      }\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Determines whether a Scene is active.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#isActive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to check.\r\n   *\r\n   * @return {boolean} Whether the Scene is active.\r\n   */\n  isActive: function isActive(key) {\n    var scene = this.getScene(key);\n\n    if (scene) {\n      return scene.sys.isActive();\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Determines whether a Scene is visible.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#isVisible\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to check.\r\n   *\r\n   * @return {boolean} Whether the Scene is visible.\r\n   */\n  isVisible: function isVisible(key) {\n    var scene = this.getScene(key);\n\n    if (scene) {\n      return scene.sys.isVisible();\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Determines whether a Scene is sleeping.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#isSleeping\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to check.\r\n   *\r\n   * @return {boolean} Whether the Scene is sleeping.\r\n   */\n  isSleeping: function isSleeping(key) {\n    var scene = this.getScene(key);\n\n    if (scene) {\n      return scene.sys.isSleeping();\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Pauses the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#pause\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to pause.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its pause event.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  pause: function pause(key, data) {\n    var scene = this.getScene(key);\n\n    if (scene) {\n      scene.sys.pause(data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Resumes the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#resume\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to resume.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its resume event.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  resume: function resume(key, data) {\n    var scene = this.getScene(key);\n\n    if (scene) {\n      scene.sys.resume(data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Puts the given Scene to sleep.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#sleep\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to put to sleep.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its sleep event.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  sleep: function sleep(key, data) {\n    var scene = this.getScene(key);\n\n    if (scene && !scene.sys.isTransitioning()) {\n      scene.sys.sleep(data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Awakens the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#wake\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to wake up.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its wake event.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  wake: function wake(key, data) {\n    var scene = this.getScene(key);\n\n    if (scene) {\n      scene.sys.wake(data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Runs the given Scene, but does not change the state of this Scene.\r\n   *\r\n   * If the given Scene is paused, it will resume it. If sleeping, it will wake it.\r\n   * If not running at all, it will be started.\r\n   *\r\n   * Use this if you wish to open a modal Scene by calling `pause` on the current\r\n   * Scene, then `run` on the modal Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#run\r\n   * @since 3.10.0\r\n   *\r\n   * @param {string} key - The Scene to run.\r\n   * @param {object} [data] - A data object that will be passed to the Scene on start, wake, or resume.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This Scene Manager.\r\n   */\n  run: function run(key, data) {\n    var scene = this.getScene(key);\n\n    if (!scene) {\n      for (var i = 0; i < this._pending.length; i++) {\n        if (this._pending[i].key === key) {\n          this.queueOp('start', key, data);\n          break;\n        }\n      }\n\n      return this;\n    }\n\n    if (scene.sys.isSleeping()) {\n      //  Sleeping?\n      scene.sys.wake(data);\n    } else if (scene.sys.isBooted && !scene.sys.isActive()) {\n      //  Paused?\n      scene.sys.resume(data);\n    } else {\n      //  Not actually running?\n      this.start(key, data);\n    }\n  },\n\n  /**\r\n   * Starts the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#start\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to start.\r\n   * @param {object} [data] - Optional data object to pass to Scene.Settings and Scene.init.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  start: function start(key, data) {\n    //  If the Scene Manager is not running, then put the Scene into a holding pattern\n    if (!this.isBooted) {\n      this._data[key] = {\n        autoStart: true,\n        data: data\n      };\n      return this;\n    }\n\n    var scene = this.getScene(key);\n\n    if (scene) {\n      //  If the Scene is already running (perhaps they called start from a launched sub-Scene?)\n      //  then we close it down before starting it again.\n      if (scene.sys.isActive() || scene.sys.isPaused()) {\n        scene.sys.shutdown();\n        scene.sys.start(data);\n      } else {\n        scene.sys.start(data);\n        var loader;\n\n        if (scene.sys.load) {\n          loader = scene.sys.load;\n        } //  Files payload?\n\n\n        if (loader && scene.sys.settings.hasOwnProperty('pack')) {\n          loader.reset();\n\n          if (loader.addPack({\n            payload: scene.sys.settings.pack\n          })) {\n            scene.sys.settings.status = CONST.LOADING;\n            loader.once(LoaderEvents.COMPLETE, this.payloadComplete, this);\n            loader.start();\n            return this;\n          }\n        }\n      }\n\n      this.bootScene(scene);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Stops the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#stop\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to stop.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  stop: function stop(key) {\n    var scene = this.getScene(key);\n\n    if (scene && !scene.sys.isTransitioning()) {\n      scene.sys.shutdown();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sleeps one one Scene and starts the other.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#switch\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} from - The Scene to sleep.\r\n   * @param {string} to - The Scene to start.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  switch: function _switch(from, to) {\n    var sceneA = this.getScene(from);\n    var sceneB = this.getScene(to);\n\n    if (sceneA && sceneB && sceneA !== sceneB) {\n      this.sleep(from);\n\n      if (this.isSleeping(to)) {\n        this.wake(to);\n      } else {\n        this.start(to);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Retrieves a Scene by numeric index.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#getAt\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} index - The index of the Scene to retrieve.\r\n   *\r\n   * @return {(Phaser.Scene|undefined)} The Scene.\r\n   */\n  getAt: function getAt(index) {\n    return this.scenes[index];\n  },\n\n  /**\r\n   * Retrieves the numeric index of a Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#getIndex\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} key - The key of the Scene.\r\n   *\r\n   * @return {integer} The index of the Scene.\r\n   */\n  getIndex: function getIndex(key) {\n    var scene = this.getScene(key);\n    return this.scenes.indexOf(scene);\n  },\n\n  /**\r\n   * Brings a Scene to the top of the Scenes list.\r\n   *\r\n   * This means it will render above all other Scenes.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#bringToTop\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  bringToTop: function bringToTop(key) {\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'bringToTop',\n        keyA: key,\n        keyB: null\n      });\n    } else {\n      var index = this.getIndex(key);\n\n      if (index !== -1 && index < this.scenes.length) {\n        var scene = this.getScene(key);\n        this.scenes.splice(index, 1);\n        this.scenes.push(scene);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sends a Scene to the back of the Scenes list.\r\n   *\r\n   * This means it will render below all other Scenes.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#sendToBack\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  sendToBack: function sendToBack(key) {\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'sendToBack',\n        keyA: key,\n        keyB: null\n      });\n    } else {\n      var index = this.getIndex(key);\n\n      if (index !== -1 && index > 0) {\n        var scene = this.getScene(key);\n        this.scenes.splice(index, 1);\n        this.scenes.unshift(scene);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Moves a Scene down one position in the Scenes list.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#moveDown\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  moveDown: function moveDown(key) {\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'moveDown',\n        keyA: key,\n        keyB: null\n      });\n    } else {\n      var indexA = this.getIndex(key);\n\n      if (indexA > 0) {\n        var indexB = indexA - 1;\n        var sceneA = this.getScene(key);\n        var sceneB = this.getAt(indexB);\n        this.scenes[indexA] = sceneB;\n        this.scenes[indexB] = sceneA;\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Moves a Scene up one position in the Scenes list.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#moveUp\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  moveUp: function moveUp(key) {\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'moveUp',\n        keyA: key,\n        keyB: null\n      });\n    } else {\n      var indexA = this.getIndex(key);\n\n      if (indexA < this.scenes.length - 1) {\n        var indexB = indexA + 1;\n        var sceneA = this.getScene(key);\n        var sceneB = this.getAt(indexB);\n        this.scenes[indexA] = sceneB;\n        this.scenes[indexB] = sceneA;\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Moves a Scene so it is immediately above another Scene in the Scenes list.\r\n   *\r\n   * This means it will render over the top of the other Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#moveAbove\r\n   * @since 3.2.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.\r\n   * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  moveAbove: function moveAbove(keyA, keyB) {\n    if (keyA === keyB) {\n      return this;\n    }\n\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'moveAbove',\n        keyA: keyA,\n        keyB: keyB\n      });\n    } else {\n      var indexA = this.getIndex(keyA);\n      var indexB = this.getIndex(keyB);\n\n      if (indexA !== -1 && indexB !== -1) {\n        var tempScene = this.getAt(indexB); //  Remove\n\n        this.scenes.splice(indexB, 1); //  Add in new location\n\n        this.scenes.splice(indexA + 1, 0, tempScene);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Moves a Scene so it is immediately below another Scene in the Scenes list.\r\n   *\r\n   * This means it will render behind the other Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#moveBelow\r\n   * @since 3.2.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.\r\n   * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  moveBelow: function moveBelow(keyA, keyB) {\n    if (keyA === keyB) {\n      return this;\n    }\n\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'moveBelow',\n        keyA: keyA,\n        keyB: keyB\n      });\n    } else {\n      var indexA = this.getIndex(keyA);\n      var indexB = this.getIndex(keyB);\n\n      if (indexA !== -1 && indexB !== -1) {\n        var tempScene = this.getAt(indexB); //  Remove\n\n        this.scenes.splice(indexB, 1);\n\n        if (indexA === 0) {\n          this.scenes.unshift(tempScene);\n        } else {\n          //  Add in new location\n          this.scenes.splice(indexA, 0, tempScene);\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Queue a Scene operation for the next update.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#queueOp\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} op - The operation to perform.\r\n   * @param {(string|Phaser.Scene)} keyA - Scene A.\r\n   * @param {(string|Phaser.Scene)} [keyB] - Scene B.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  queueOp: function queueOp(op, keyA, keyB) {\n    this._queue.push({\n      op: op,\n      keyA: keyA,\n      keyB: keyB\n    });\n\n    return this;\n  },\n\n  /**\r\n   * Swaps the positions of two Scenes in the Scenes list.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#swapPosition\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} keyA - The first Scene to swap.\r\n   * @param {(string|Phaser.Scene)} keyB - The second Scene to swap.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  swapPosition: function swapPosition(keyA, keyB) {\n    if (keyA === keyB) {\n      return this;\n    }\n\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'swapPosition',\n        keyA: keyA,\n        keyB: keyB\n      });\n    } else {\n      var indexA = this.getIndex(keyA);\n      var indexB = this.getIndex(keyB);\n\n      if (indexA !== indexB && indexA !== -1 && indexB !== -1) {\n        var tempScene = this.getAt(indexA);\n        this.scenes[indexA] = this.scenes[indexB];\n        this.scenes[indexB] = tempScene;\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Dumps debug information about each Scene to the developer console.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#dump\r\n   * @since 3.2.0\r\n   */\n  dump: function dump() {\n    var out = [];\n    var map = ['pending', 'init', 'start', 'loading', 'creating', 'running', 'paused', 'sleeping', 'shutdown', 'destroyed'];\n\n    for (var i = 0; i < this.scenes.length; i++) {\n      var sys = this.scenes[i].sys;\n      var key = sys.settings.visible && (sys.settings.status === CONST.RUNNING || sys.settings.status === CONST.PAUSED) ? '[*] ' : '[-] ';\n      key += sys.settings.key + ' (' + map[sys.settings.status] + ')';\n      out.push(key);\n    }\n\n    console.log(out.join('\\n'));\n  },\n\n  /**\r\n   * Destroy the SceneManager and all of its Scene's systems.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    for (var i = 0; i < this.scenes.length; i++) {\n      var sys = this.scenes[i].sys;\n      sys.destroy();\n    }\n\n    this.update = NOOP;\n    this.scenes = [];\n    this._pending = [];\n    this._start = [];\n    this._queue = [];\n    this.game = null;\n  }\n});\nmodule.exports = SceneManager;","map":null,"metadata":{},"sourceType":"script"}