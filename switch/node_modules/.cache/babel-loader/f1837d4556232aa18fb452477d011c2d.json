{"ast":null,"code":"/**\r\n* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.\r\n*\r\n* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Svg\r\n*/\nvar Svg = {};\nmodule.exports = Svg;\n\nvar Bounds = require('../geometry/Bounds');\n\nvar Common = require('../core/Common');\n\n(function () {\n  /**\r\n   * Converts an SVG path into an array of vector points.\r\n   * If the input path forms a concave shape, you must decompose the result into convex parts before use.\r\n   * See `Bodies.fromVertices` which provides support for this.\r\n   * Note that this function is not guaranteed to support complex paths (such as those with holes).\r\n   * You must load the `pathseg.js` polyfill on newer browsers.\r\n   * @method pathToVertices\r\n   * @param {SVGPathElement} path\r\n   * @param {Number} [sampleLength=15]\r\n   * @return {Vector[]} points\r\n   */\n  Svg.pathToVertices = function (path, sampleLength) {\n    if (typeof window !== 'undefined' && !('SVGPathSeg' in window)) {\n      Common.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.');\n    } // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js\n\n\n    var i,\n        il,\n        total,\n        point,\n        segment,\n        segments,\n        segmentsQueue,\n        lastSegment,\n        lastPoint,\n        segmentIndex,\n        points = [],\n        lx,\n        ly,\n        length = 0,\n        x = 0,\n        y = 0;\n    sampleLength = sampleLength || 15;\n\n    var addPoint = function addPoint(px, py, pathSegType) {\n      // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)\n      var isRelative = pathSegType % 2 === 1 && pathSegType > 1; // when the last point doesn't equal the current point add the current point\n\n      if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {\n        if (lastPoint && isRelative) {\n          lx = lastPoint.x;\n          ly = lastPoint.y;\n        } else {\n          lx = 0;\n          ly = 0;\n        }\n\n        var point = {\n          x: lx + px,\n          y: ly + py\n        }; // set last point\n\n        if (isRelative || !lastPoint) {\n          lastPoint = point;\n        }\n\n        points.push(point);\n        x = lx + px;\n        y = ly + py;\n      }\n    };\n\n    var addSegmentPoint = function addSegmentPoint(segment) {\n      var segType = segment.pathSegTypeAsLetter.toUpperCase(); // skip path ends\n\n      if (segType === 'Z') return; // map segment to x and y\n\n      switch (segType) {\n        case 'M':\n        case 'L':\n        case 'T':\n        case 'C':\n        case 'S':\n        case 'Q':\n          x = segment.x;\n          y = segment.y;\n          break;\n\n        case 'H':\n          x = segment.x;\n          break;\n\n        case 'V':\n          y = segment.y;\n          break;\n      }\n\n      addPoint(x, y, segment.pathSegType);\n    }; // ensure path is absolute\n\n\n    Svg._svgPathToAbsolute(path); // get total length\n\n\n    total = path.getTotalLength(); // queue segments\n\n    segments = [];\n\n    for (i = 0; i < path.pathSegList.numberOfItems; i += 1) {\n      segments.push(path.pathSegList.getItem(i));\n    }\n\n    segmentsQueue = segments.concat(); // sample through path\n\n    while (length < total) {\n      // get segment at position\n      segmentIndex = path.getPathSegAtLength(length);\n      segment = segments[segmentIndex]; // new segment\n\n      if (segment != lastSegment) {\n        while (segmentsQueue.length && segmentsQueue[0] != segment) {\n          addSegmentPoint(segmentsQueue.shift());\n        }\n\n        lastSegment = segment;\n      } // add points in between when curving\n      // TODO: adaptive sampling\n\n\n      switch (segment.pathSegTypeAsLetter.toUpperCase()) {\n        case 'C':\n        case 'T':\n        case 'S':\n        case 'Q':\n        case 'A':\n          point = path.getPointAtLength(length);\n          addPoint(point.x, point.y, 0);\n          break;\n      } // increment by sample value\n\n\n      length += sampleLength;\n    } // add remaining segments not passed by sampling\n\n\n    for (i = 0, il = segmentsQueue.length; i < il; ++i) {\n      addSegmentPoint(segmentsQueue[i]);\n    }\n\n    return points;\n  };\n\n  Svg._svgPathToAbsolute = function (path) {\n    // http://phrogz.net/convert-svg-path-to-all-absolute-commands\n    // Copyright (c) Gavin Kistner\n    // http://phrogz.net/js/_ReuseLicense.txt\n    // Modifications: tidy formatting and naming\n    var x0,\n        y0,\n        x1,\n        y1,\n        x2,\n        y2,\n        segs = path.pathSegList,\n        x = 0,\n        y = 0,\n        len = segs.numberOfItems;\n\n    for (var i = 0; i < len; ++i) {\n      var seg = segs.getItem(i),\n          segType = seg.pathSegTypeAsLetter;\n\n      if (/[MLHVCSQTA]/.test(segType)) {\n        if ('x' in seg) x = seg.x;\n        if ('y' in seg) y = seg.y;\n      } else {\n        if ('x1' in seg) x1 = x + seg.x1;\n        if ('x2' in seg) x2 = x + seg.x2;\n        if ('y1' in seg) y1 = y + seg.y1;\n        if ('y2' in seg) y2 = y + seg.y2;\n        if ('x' in seg) x += seg.x;\n        if ('y' in seg) y += seg.y;\n\n        switch (segType) {\n          case 'm':\n            segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);\n            break;\n\n          case 'l':\n            segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);\n            break;\n\n          case 'h':\n            segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);\n            break;\n\n          case 'v':\n            segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);\n            break;\n\n          case 'c':\n            segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);\n            break;\n\n          case 's':\n            segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);\n            break;\n\n          case 'q':\n            segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);\n            break;\n\n          case 't':\n            segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);\n            break;\n\n          case 'a':\n            segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);\n            break;\n\n          case 'z':\n          case 'Z':\n            x = x0;\n            y = y0;\n            break;\n        }\n      }\n\n      if (segType == 'M' || segType == 'm') {\n        x0 = x;\n        y0 = y;\n      }\n    }\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}