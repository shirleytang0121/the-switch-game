{"ast":null,"code":"/**\r\n * @author       Joachim Grill <joachim@codeandweb.com>\r\n * @copyright    2018 CodeAndWeb GmbH\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Bodies = require('./lib/factory/Bodies');\n\nvar Body = require('./lib/body/Body');\n\nvar Bounds = require('./lib/geometry/Bounds');\n\nvar Common = require('./lib/core/Common');\n\nvar GetFastValue = require('../../utils/object/GetFastValue');\n\nvar Vector = require('./lib/geometry/Vector');\n\nvar Vertices = require('./lib/geometry/Vertices');\n/**\r\n * Use PhysicsEditorParser.parseBody() to build a Matter body object, based on a physics data file\r\n * created and exported with PhysicsEditor (https://www.codeandweb.com/physicseditor).\r\n *\r\n * @namespace Phaser.Physics.Matter.PhysicsEditorParser\r\n * @since 3.10.0\r\n */\n\n\nvar PhysicsEditorParser = {\n  /**\r\n   * Parses a body element exported by PhysicsEditor.\r\n   *\r\n   * @function Phaser.Physics.Matter.PhysicsEditorParser.parseBody\r\n   * @since 3.10.0\r\n   *\r\n   * @param {number} x - x position.\r\n   * @param {number} y - y position.\r\n   * @param {number} w - width.\r\n   * @param {number} h - height.\r\n   * @param {object} config - body configuration and fixture (child body) definitions.\r\n   * \r\n   * @return {object} A matter body, consisting of several parts (child bodies)\r\n   */\n  parseBody: function parseBody(x, y, w, h, config) {\n    var fixtureConfigs = GetFastValue(config, 'fixtures', []);\n    var fixtures = [];\n\n    for (var fc = 0; fc < fixtureConfigs.length; fc++) {\n      var fixtureParts = this.parseFixture(fixtureConfigs[fc]);\n\n      for (var i = 0; i < fixtureParts.length; i++) {\n        fixtures.push(fixtureParts[i]);\n      }\n    }\n\n    var matterConfig = Common.extend({}, false, config);\n    delete matterConfig.fixtures;\n    delete matterConfig.type;\n    var body = Body.create(matterConfig);\n    Body.setParts(body, fixtures);\n    body.render.sprite.xOffset = body.position.x / w;\n    body.render.sprite.yOffset = body.position.y / h;\n    Body.setPosition(body, {\n      x: x,\n      y: y\n    });\n    return body;\n  },\n\n  /**\r\n   * Parses an element of the \"fixtures\" list exported by PhysicsEditor\r\n   *\r\n   * @function Phaser.Physics.Matter.PhysicsEditorParser.parseFixture\r\n   * @since 3.10.0\r\n   *\r\n   * @param {object} fixtureConfig - the fixture object to parse\r\n   * \r\n   * @return {object[]} - A list of matter bodies\r\n   */\n  parseFixture: function parseFixture(fixtureConfig) {\n    var matterConfig = Common.extend({}, false, fixtureConfig);\n    delete matterConfig.circle;\n    delete matterConfig.vertices;\n    var fixtures;\n\n    if (fixtureConfig.circle) {\n      var x = GetFastValue(fixtureConfig.circle, 'x');\n      var y = GetFastValue(fixtureConfig.circle, 'y');\n      var r = GetFastValue(fixtureConfig.circle, 'radius');\n      fixtures = [Bodies.circle(x, y, r, matterConfig)];\n    } else if (fixtureConfig.vertices) {\n      fixtures = this.parseVertices(fixtureConfig.vertices, matterConfig);\n    }\n\n    return fixtures;\n  },\n\n  /**\r\n   * Parses the \"vertices\" lists exported by PhysicsEditor.\r\n   *\r\n   * @function Phaser.Physics.Matter.PhysicsEditorParser.parseVertices\r\n   * @since 3.10.0\r\n   *\r\n   * @param {object} vertexSets - The vertex lists to parse.\r\n   * @param {object} options - Matter body options.\r\n   * \r\n   * @return {object[]} - A list of matter bodies.\r\n   */\n  parseVertices: function parseVertices(vertexSets, options) {\n    var i, j, k, v, z;\n    var parts = [];\n    options = options || {};\n\n    for (v = 0; v < vertexSets.length; v += 1) {\n      parts.push(Body.create(Common.extend({\n        position: Vertices.centre(vertexSets[v]),\n        vertices: vertexSets[v]\n      }, options)));\n    } // flag coincident part edges\n\n\n    var coincidentMaxDist = 5;\n\n    for (i = 0; i < parts.length; i++) {\n      var partA = parts[i];\n\n      for (j = i + 1; j < parts.length; j++) {\n        var partB = parts[j];\n\n        if (Bounds.overlaps(partA.bounds, partB.bounds)) {\n          var pav = partA.vertices,\n              pbv = partB.vertices; // iterate vertices of both parts\n\n          for (k = 0; k < partA.vertices.length; k++) {\n            for (z = 0; z < partB.vertices.length; z++) {\n              // find distances between the vertices\n              var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])),\n                  db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length])); // if both vertices are very close, consider the edge concident (internal)\n\n              if (da < coincidentMaxDist && db < coincidentMaxDist) {\n                pav[k].isInternal = true;\n                pbv[z].isInternal = true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return parts;\n  }\n};\nmodule.exports = PhysicsEditorParser;","map":null,"metadata":{},"sourceType":"script"}