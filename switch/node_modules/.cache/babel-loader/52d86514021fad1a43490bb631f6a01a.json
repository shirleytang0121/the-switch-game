{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar AddToDOM = require('../../../dom/AddToDOM');\n\nvar CanvasPool = require('../../../display/canvas/CanvasPool');\n\nvar Class = require('../../../utils/Class');\n\nvar Components = require('../../components');\n\nvar CONST = require('../../../const');\n\nvar GameObject = require('../../GameObject');\n\nvar GetTextSize = require('../GetTextSize');\n\nvar GetValue = require('../../../utils/object/GetValue');\n\nvar RemoveFromDOM = require('../../../dom/RemoveFromDOM');\n\nvar TextRender = require('./TextRender');\n\nvar TextStyle = require('../TextStyle');\n/**\r\n * @classdesc\r\n * A Text Game Object.\r\n * \r\n * Text objects work by creating their own internal hidden Canvas and then renders text to it using\r\n * the standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered\r\n * to your game during the render pass.\r\n * \r\n * Because it uses the Canvas API you can take advantage of all the features this offers, such as\r\n * applying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts\r\n * loaded externally, such as Google or TypeKit Web fonts.\r\n * \r\n * **Important:** If the font you wish to use has a space or digit in its name, such as\r\n * 'Press Start 2P' or 'Roboto Condensed', then you _must_ put the font name in quotes, either\r\n * when creating the Text object, or when setting the font via `setFont` or `setFontFamily`. I.e.:\r\n * \r\n * ```javascript\r\n * this.add.text(0, 0, 'Hello World', { fontFamily: '\"Roboto Condensed\"' });\r\n * ```\r\n * \r\n * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all\r\n * quoted properly, too:\r\n * \r\n * ```javascript\r\n * this.add.text(0, 0, 'Hello World', { fontFamily: 'Verdana, \"Times New Roman\", Tahoma, serif' });\r\n * ```\r\n *\r\n * You can only display fonts that are currently loaded and available to the browser: therefore fonts must\r\n * be pre-loaded. Phaser does not do ths for you, so you will require the use of a 3rd party font loader,\r\n * or have the fonts ready available in the CSS on the page in which your Phaser game resides.\r\n *\r\n * See {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts\r\n * across mobile browsers.\r\n * \r\n * A note on performance: Every time the contents of a Text object changes, i.e. changing the text being\r\n * displayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the\r\n * new texture to the GPU. This can be an expensive operation if used often, or with large quantities of\r\n * Text objects in your game. If you run into performance issues you would be better off using Bitmap Text\r\n * instead, as it benefits from batching and avoids expensive Canvas API calls.\r\n *\r\n * @class Text\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Crop\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|string[])} text - The text this Text object will display.\r\n * @param {object} style - The text style configuration object.\r\n */\n\n\nvar Text = new Class({\n  Extends: GameObject,\n  Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Crop, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScaleMode, Components.ScrollFactor, Components.Tint, Components.Transform, Components.Visible, TextRender],\n  initialize: function Text(scene, x, y, text, style) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    GameObject.call(this, scene, 'Text');\n    /**\r\n     * The renderer in use by this Text object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#renderer\r\n     * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n     * @since 3.12.0\r\n     */\n\n    this.renderer = scene.sys.game.renderer;\n    this.setPosition(x, y);\n    this.setOrigin(0, 0);\n    this.initPipeline();\n    /**\r\n     * The canvas element that the text is rendered to.\r\n     *\r\n     * @name Phaser.GameObjects.Text#canvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.0.0\r\n     */\n\n    this.canvas = CanvasPool.create(this);\n    /**\r\n     * The context of the canvas element that the text is rendered to.\r\n     *\r\n     * @name Phaser.GameObjects.Text#context\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.0.0\r\n     */\n\n    this.context = this.canvas.getContext('2d');\n    /**\r\n     * The Text Style object.\r\n     *\r\n     * Manages the style of this Text object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#style\r\n     * @type {Phaser.GameObjects.TextStyle}\r\n     * @since 3.0.0\r\n     */\n\n    this.style = new TextStyle(this, style);\n    /**\r\n     * Whether to automatically round line positions.\r\n     *\r\n     * @name Phaser.GameObjects.Text#autoRound\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.autoRound = true;\n    /**\r\n     * The Regular Expression that is used to split the text up into lines, in\r\n     * multi-line text. By default this is `/(?:\\r\\n|\\r|\\n)/`.\r\n     * You can change this RegExp to be anything else that you may need.\r\n     *\r\n     * @name Phaser.GameObjects.Text#splitRegExp\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.splitRegExp = /(?:\\r\\n|\\r|\\n)/;\n    /**\r\n     * The text to display.\r\n     *\r\n     * @name Phaser.GameObjects.Text#_text\r\n     * @type {string}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._text = '';\n    /**\r\n     * Specify a padding value which is added to the line width and height when calculating the Text size.\r\n     * Allows you to add extra spacing if the browser is unable to accurately determine the true font dimensions.\r\n     *\r\n     * @name Phaser.GameObjects.Text#padding\r\n     * @type {{left:number,right:number,top:number,bottom:number}}\r\n     * @since 3.0.0\r\n     */\n\n    this.padding = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    /**\r\n     * The width of this Text object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#width\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\n\n    this.width = 1;\n    /**\r\n     * The height of this Text object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#height\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\n\n    this.height = 1;\n    /**\r\n     * The line spacing value.\r\n     * This value is added to the font height to calculate the overall line height.\r\n     * Only has an effect if this Text object contains multiple lines of text.\r\n     * \r\n     * If you update this property directly, instead of using the `setLineSpacing` method, then\r\n     * be sure to call `updateText` after, or you won't see the change reflected in the Text object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#lineSpacing\r\n     * @type {number}\r\n     * @since 3.13.0\r\n     */\n\n    this.lineSpacing = 0;\n    /**\r\n     * Whether the text or its settings have changed and need updating.\r\n     *\r\n     * @name Phaser.GameObjects.Text#dirty\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.dirty = false; //  If resolution wasn't set, then we get it from the game config\n\n    if (this.style.resolution === 0) {\n      this.style.resolution = scene.sys.game.config.resolution;\n    }\n    /**\r\n     * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n     *\r\n     * @name Phaser.GameObjects.Text#_crop\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n\n    this._crop = this.resetCropObject(); //  Create a Texture for this Text object\n\n    this.texture = scene.sys.textures.addCanvas(null, this.canvas, true); //  Get the frame\n\n    this.frame = this.texture.get(); //  Set the resolution\n\n    this.frame.source.resolution = this.style.resolution;\n\n    if (this.renderer && this.renderer.gl) {\n      //  Clear the default 1x1 glTexture, as we override it later\n      this.renderer.deleteTexture(this.frame.source.glTexture);\n      this.frame.source.glTexture = null;\n    }\n\n    this.initRTL();\n\n    if (style && style.padding) {\n      this.setPadding(style.padding);\n    }\n\n    if (style && style.lineSpacing) {\n      this.lineSpacing = style.lineSpacing;\n    }\n\n    this.setText(text);\n\n    if (scene.sys.game.config.renderType === CONST.WEBGL) {\n      scene.sys.game.renderer.onContextRestored(function () {\n        this.dirty = true;\n      }, this);\n    }\n  },\n\n  /**\r\n   * Initialize right to left text.\r\n   *\r\n   * @method Phaser.GameObjects.Text#initRTL\r\n   * @since 3.0.0\r\n   */\n  initRTL: function initRTL() {\n    if (!this.style.rtl) {\n      return;\n    } //  Here is where the crazy starts.\n    //\n    //  Due to browser implementation issues, you cannot fillText BiDi text to a canvas\n    //  that is not part of the DOM. It just completely ignores the direction property.\n\n\n    this.canvas.dir = 'rtl'; //  Experimental atm, but one day ...\n\n    this.context.direction = 'rtl'; //  Add it to the DOM, but hidden within the parent canvas.\n\n    this.canvas.style.display = 'none';\n    AddToDOM(this.canvas, this.scene.sys.canvas); //  And finally we set the x origin\n\n    this.originX = 1;\n  },\n\n  /**\r\n   * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n   * bounds.\r\n   *\r\n   * @method Phaser.GameObjects.Text#runWordWrap\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} text - The text to perform word wrap detection against.\r\n   *\r\n   * @return {string} The text after wrapping has been applied.\r\n   */\n  runWordWrap: function runWordWrap(text) {\n    var style = this.style;\n\n    if (style.wordWrapCallback) {\n      var wrappedLines = style.wordWrapCallback.call(style.wordWrapCallbackScope, text, this);\n\n      if (Array.isArray(wrappedLines)) {\n        wrappedLines = wrappedLines.join('\\n');\n      }\n\n      return wrappedLines;\n    } else if (style.wordWrapWidth) {\n      if (style.wordWrapUseAdvanced) {\n        return this.advancedWordWrap(text, this.context, this.style.wordWrapWidth);\n      } else {\n        return this.basicWordWrap(text, this.context, this.style.wordWrapWidth);\n      }\n    } else {\n      return text;\n    }\n  },\n\n  /**\r\n   * Advanced wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n   * bounds. Consecutive spaces will be collapsed and replaced with a single space. Lines will be\r\n   * trimmed of white space before processing. Throws an error if wordWrapWidth is less than a\r\n   * single character.\r\n   *\r\n   * @method Phaser.GameObjects.Text#advancedWordWrap\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} text - The text to perform word wrap detection against.\r\n   * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\r\n   * @param {number} wordWrapWidth - The word wrap width.\r\n   *\r\n   * @return {string} The wrapped text.\r\n   */\n  advancedWordWrap: function advancedWordWrap(text, context, wordWrapWidth) {\n    var output = ''; // Condense consecutive spaces and split into lines\n\n    var lines = text.replace(/ +/gi, ' ').split(this.splitRegExp);\n    var linesCount = lines.length;\n\n    for (var i = 0; i < linesCount; i++) {\n      var line = lines[i];\n      var out = ''; // Trim whitespace\n\n      line = line.replace(/^ *|\\s*$/gi, ''); // If entire line is less than wordWrapWidth append the entire line and exit early\n\n      var lineWidth = context.measureText(line).width;\n\n      if (lineWidth < wordWrapWidth) {\n        output += line + '\\n';\n        continue;\n      } // Otherwise, calculate new lines\n\n\n      var currentLineWidth = wordWrapWidth; // Split into words\n\n      var words = line.split(' ');\n\n      for (var j = 0; j < words.length; j++) {\n        var word = words[j];\n        var wordWithSpace = word + ' ';\n        var wordWidth = context.measureText(wordWithSpace).width;\n\n        if (wordWidth > currentLineWidth) {\n          // Break word\n          if (j === 0) {\n            // Shave off letters from word until it's small enough\n            var newWord = wordWithSpace;\n\n            while (newWord.length) {\n              newWord = newWord.slice(0, -1);\n              wordWidth = context.measureText(newWord).width;\n\n              if (wordWidth <= currentLineWidth) {\n                break;\n              }\n            } // If wordWrapWidth is too small for even a single letter, shame user\n            // failure with a fatal error\n\n\n            if (!newWord.length) {\n              throw new Error('This text\\'s wordWrapWidth setting is less than a single character!');\n            } // Replace current word in array with remainder\n\n\n            var secondPart = word.substr(newWord.length);\n            words[j] = secondPart; // Append first piece to output\n\n            out += newWord;\n          } // If existing word length is 0, don't include it\n\n\n          var offset = words[j].length ? j : j + 1; // Collapse rest of sentence and remove any trailing white space\n\n          var remainder = words.slice(offset).join(' ').replace(/[ \\n]*$/gi, ''); // Prepend remainder to next line\n\n          lines[i + 1] = remainder + ' ' + (lines[i + 1] || '');\n          linesCount = lines.length;\n          break; // Processing on this line\n          // Append word with space to output\n        } else {\n          out += wordWithSpace;\n          currentLineWidth -= wordWidth;\n        }\n      } // Append processed line to output\n\n\n      output += out.replace(/[ \\n]*$/gi, '') + '\\n';\n    } // Trim the end of the string\n\n\n    output = output.replace(/[\\s|\\n]*$/gi, '');\n    return output;\n  },\n\n  /**\r\n   * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n   * bounds. Spaces are not collapsed and whitespace is not trimmed.\r\n   *\r\n   * @method Phaser.GameObjects.Text#basicWordWrap\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} text - The text to perform word wrap detection against.\r\n   * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\r\n   * @param {number} wordWrapWidth - The word wrap width.\r\n   *\r\n   * @return {string} The wrapped text.\r\n   */\n  basicWordWrap: function basicWordWrap(text, context, wordWrapWidth) {\n    var result = '';\n    var lines = text.split(this.splitRegExp);\n\n    for (var i = 0; i < lines.length; i++) {\n      var spaceLeft = wordWrapWidth;\n      var words = lines[i].split(' ');\n\n      for (var j = 0; j < words.length; j++) {\n        var wordWidth = context.measureText(words[j]).width;\n        var wordWidthWithSpace = wordWidth + context.measureText(' ').width;\n\n        if (wordWidthWithSpace > spaceLeft) {\n          // Skip printing the newline if it's the first word of the line that is greater\n          // than the word wrap width.\n          if (j > 0) {\n            result += '\\n';\n          }\n\n          result += words[j] + ' ';\n          spaceLeft = wordWrapWidth - wordWidth;\n        } else {\n          spaceLeft -= wordWidthWithSpace;\n          result += words[j];\n\n          if (j < words.length - 1) {\n            result += ' ';\n          }\n        }\n      }\n\n      if (i < lines.length - 1) {\n        result += '\\n';\n      }\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Runs the given text through this Text objects word wrapping and returns the results as an\r\n   * array, where each element of the array corresponds to a wrapped line of text.\r\n   *\r\n   * @method Phaser.GameObjects.Text#getWrappedText\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} text - The text for which the wrapping will be calculated. If unspecified, the Text objects current text will be used.\r\n   *\r\n   * @return {string[]} An array of strings with the pieces of wrapped text.\r\n   */\n  getWrappedText: function getWrappedText(text) {\n    if (text === undefined) {\n      text = this._text;\n    }\n\n    this.style.syncFont(this.canvas, this.context);\n    var wrappedLines = this.runWordWrap(text);\n    return wrappedLines.split(this.splitRegExp);\n  },\n\n  /**\r\n   * Set the text to display.\r\n   *\r\n   * An array of strings will be joined with `\\n` line breaks.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setText\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|string[])} value - The string, or array of strings, to be set as the content of this Text object.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setText: function setText(value) {\n    if (!value && value !== 0) {\n      value = '';\n    }\n\n    if (Array.isArray(value)) {\n      value = value.join('\\n');\n    }\n\n    if (value !== this._text) {\n      this._text = value.toString();\n      this.updateText();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Set the text style.\r\n   *\r\n   * @example\r\n   * text.setStyle({\r\n   *     fontSize: '64px',\r\n   *     fontFamily: 'Arial',\r\n   *     color: '#ffffff',\r\n   *     align: 'center',\r\n   *     backgroundColor: '#ff00ff'\r\n   * });\r\n   *\r\n   * @method Phaser.GameObjects.Text#setStyle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} style - The style settings to set.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setStyle: function setStyle(style) {\n    return this.style.setStyle(style);\n  },\n\n  /**\r\n   * Set the font.\r\n   *\r\n   * If a string is given, the font family is set.\r\n   *\r\n   * If an object is given, the `fontFamily`, `fontSize` and `fontStyle`\r\n   * properties of that object are set.\r\n   * \r\n   * **Important:** If the font you wish to use has a space or digit in its name, such as\r\n   * 'Press Start 2P' or 'Roboto Condensed', then you _must_ put the font name in quotes:\r\n   * \r\n   * ```javascript\r\n   * Text.setFont('\"Roboto Condensed\"');\r\n   * ```\r\n   * \r\n   * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all\r\n   * quoted properly, too:\r\n   * \r\n   * ```javascript\r\n   * Text.setFont('Verdana, \"Times New Roman\", Tahoma, serif');\r\n   * ```\r\n   *\r\n   * @method Phaser.GameObjects.Text#setFont\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} font - The font family or font settings to set.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setFont: function setFont(font) {\n    return this.style.setFont(font);\n  },\n\n  /**\r\n   * Set the font family.\r\n   * \r\n   * **Important:** If the font you wish to use has a space or digit in its name, such as\r\n   * 'Press Start 2P' or 'Roboto Condensed', then you _must_ put the font name in quotes:\r\n   * \r\n   * ```javascript\r\n   * Text.setFont('\"Roboto Condensed\"');\r\n   * ```\r\n   * \r\n   * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all\r\n   * quoted properly, too:\r\n   * \r\n   * ```javascript\r\n   * Text.setFont('Verdana, \"Times New Roman\", Tahoma, serif');\r\n   * ```\r\n   *\r\n   * @method Phaser.GameObjects.Text#setFontFamily\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} family - The font family.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setFontFamily: function setFontFamily(family) {\n    return this.style.setFontFamily(family);\n  },\n\n  /**\r\n   * Set the font size.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setFontSize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} size - The font size.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setFontSize: function setFontSize(size) {\n    return this.style.setFontSize(size);\n  },\n\n  /**\r\n   * Set the font style.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setFontStyle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} style - The font style.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setFontStyle: function setFontStyle(style) {\n    return this.style.setFontStyle(style);\n  },\n\n  /**\r\n   * Set a fixed width and height for the text.\r\n   *\r\n   * Pass in `0` for either of these parameters to disable fixed width or height respectively.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setFixedSize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} width - The fixed width to set. `0` disables fixed width.\r\n   * @param {number} height - The fixed height to set. `0` disables fixed height.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setFixedSize: function setFixedSize(width, height) {\n    return this.style.setFixedSize(width, height);\n  },\n\n  /**\r\n   * Set the background color.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setBackgroundColor\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} color - The background color.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setBackgroundColor: function setBackgroundColor(color) {\n    return this.style.setBackgroundColor(color);\n  },\n\n  /**\r\n   * Set the fill style to be used by the Text object.\r\n   *\r\n   * This can be any valid CanvasRenderingContext2D fillStyle value, such as\r\n   * a color (in hex, rgb, rgba, hsl or named values), a gradient or a pattern.\r\n   *\r\n   * See the [MDN fillStyle docs](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle) for more details.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setFill\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|any)} color - The text fill style. Can be any valid CanvasRenderingContext `fillStyle` value.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setFill: function setFill(fillStyle) {\n    return this.style.setFill(fillStyle);\n  },\n\n  /**\r\n   * Set the text fill color.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setColor\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} color - The text fill color.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setColor: function setColor(color) {\n    return this.style.setColor(color);\n  },\n\n  /**\r\n   * Set the stroke settings.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setStroke\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} color - The stroke color.\r\n   * @param {number} thickness - The stroke thickness.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setStroke: function setStroke(color, thickness) {\n    return this.style.setStroke(color, thickness);\n  },\n\n  /**\r\n   * Set the shadow settings.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setShadow\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [x=0] - The horizontal shadow offset.\r\n   * @param {number} [y=0] - The vertical shadow offset.\r\n   * @param {string} [color='#000'] - The shadow color.\r\n   * @param {number} [blur=0] - The shadow blur radius.\r\n   * @param {boolean} [shadowStroke=false] - Whether to stroke the shadow.\r\n   * @param {boolean} [shadowFill=true] - Whether to fill the shadow.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setShadow: function setShadow(x, y, color, blur, shadowStroke, shadowFill) {\n    return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);\n  },\n\n  /**\r\n   * Set the shadow offset.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setShadowOffset\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal shadow offset.\r\n   * @param {number} y - The vertical shadow offset.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setShadowOffset: function setShadowOffset(x, y) {\n    return this.style.setShadowOffset(x, y);\n  },\n\n  /**\r\n   * Set the shadow color.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setShadowColor\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} color - The shadow color.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setShadowColor: function setShadowColor(color) {\n    return this.style.setShadowColor(color);\n  },\n\n  /**\r\n   * Set the shadow blur radius.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setShadowBlur\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} blur - The shadow blur radius.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setShadowBlur: function setShadowBlur(blur) {\n    return this.style.setShadowBlur(blur);\n  },\n\n  /**\r\n   * Enable or disable shadow stroke.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setShadowStroke\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} enabled - Whether shadow stroke is enabled or not.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setShadowStroke: function setShadowStroke(enabled) {\n    return this.style.setShadowStroke(enabled);\n  },\n\n  /**\r\n   * Enable or disable shadow fill.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setShadowFill\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} enabled - Whether shadow fill is enabled or not.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setShadowFill: function setShadowFill(enabled) {\n    return this.style.setShadowFill(enabled);\n  },\n\n  /**\r\n   * Set the width (in pixels) to use for wrapping lines. Pass in null to remove wrapping by width.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setWordWrapWidth\r\n   * @since 3.0.0\r\n   *\r\n   * @param {?number} width - The maximum width of a line in pixels. Set to null to remove wrapping.\r\n   * @param {boolean} [useAdvancedWrap=false] - Whether or not to use the advanced wrapping\r\n   * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,\r\n   * spaces and whitespace are left as is.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setWordWrapWidth: function setWordWrapWidth(width, useAdvancedWrap) {\n    return this.style.setWordWrapWidth(width, useAdvancedWrap);\n  },\n\n  /**\r\n   * Set a custom callback for wrapping lines. Pass in null to remove wrapping by callback.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setWordWrapCallback\r\n   * @since 3.0.0\r\n   *\r\n   * @param {TextStyleWordWrapCallback} callback - A custom function that will be responsible for wrapping the\r\n   * text. It will receive two arguments: text (the string to wrap), textObject (this Text\r\n   * instance). It should return the wrapped lines either as an array of lines or as a string with\r\n   * newline characters in place to indicate where breaks should happen.\r\n   * @param {object} [scope=null] - The scope that will be applied when the callback is invoked.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setWordWrapCallback: function setWordWrapCallback(callback, scope) {\n    return this.style.setWordWrapCallback(callback, scope);\n  },\n\n  /**\r\n   * Set the text alignment.\r\n   *\r\n   * Expects values like `'left'`, `'right'`, `'center'` or `'justified'`.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setAlign\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} align - The text alignment.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setAlign: function setAlign(align) {\n    return this.style.setAlign(align);\n  },\n\n  /**\r\n   * Set the resolution used by this Text object.\r\n   *\r\n   * By default it will be set to match the resolution set in the Game Config,\r\n   * but you can override it via this method, or by specifying it in the Text style configuration object.\r\n   * \r\n   * It allows for much clearer text on High DPI devices, at the cost of memory because it uses larger\r\n   * internal Canvas textures for the Text.\r\n   * \r\n   * Therefore, please use with caution, as the more high res Text you have, the more memory it uses.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setResolution\r\n   * @since 3.12.0\r\n   *\r\n   * @param {number} value - The resolution for this Text object to use.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setResolution: function setResolution(value) {\n    return this.style.setResolution(value);\n  },\n\n  /**\r\n   * Sets the line spacing value.\r\n   *\r\n   * This value is _added_ to the height of the font when calculating the overall line height.\r\n   * This only has an effect if this Text object consists of multiple lines of text.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setLineSpacing\r\n   * @since 3.13.0\r\n   *\r\n   * @param {number} value - The amount to add to the font height to achieve the overall line height.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setLineSpacing: function setLineSpacing(value) {\n    this.lineSpacing = value;\n    return this.updateText();\n  },\n\n  /**\r\n   * Set the text padding.\r\n   *\r\n   * 'left' can be an object.\r\n   *\r\n   * If only 'left' and 'top' are given they are treated as 'x' and 'y'.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setPadding\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(number|object)} left - The left padding value, or a padding config object.\r\n   * @param {number} top - The top padding value.\r\n   * @param {number} right - The right padding value.\r\n   * @param {number} bottom - The bottom padding value.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setPadding: function setPadding(left, top, right, bottom) {\n    if (typeof left === 'object') {\n      var config = left; //  If they specify x and/or y this applies to all\n\n      var x = GetValue(config, 'x', null);\n\n      if (x !== null) {\n        left = x;\n        right = x;\n      } else {\n        left = GetValue(config, 'left', 0);\n        right = GetValue(config, 'right', left);\n      }\n\n      var y = GetValue(config, 'y', null);\n\n      if (y !== null) {\n        top = y;\n        bottom = y;\n      } else {\n        top = GetValue(config, 'top', 0);\n        bottom = GetValue(config, 'bottom', top);\n      }\n    } else {\n      if (left === undefined) {\n        left = 0;\n      }\n\n      if (top === undefined) {\n        top = left;\n      }\n\n      if (right === undefined) {\n        right = left;\n      }\n\n      if (bottom === undefined) {\n        bottom = top;\n      }\n    }\n\n    this.padding.left = left;\n    this.padding.top = top;\n    this.padding.right = right;\n    this.padding.bottom = bottom;\n    return this.updateText();\n  },\n\n  /**\r\n   * Set the maximum number of lines to draw.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setMaxLines\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} [max=0] - The maximum number of lines to draw.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setMaxLines: function setMaxLines(max) {\n    return this.style.setMaxLines(max);\n  },\n\n  /**\r\n   * Update the displayed text.\r\n   *\r\n   * @method Phaser.GameObjects.Text#updateText\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  updateText: function updateText() {\n    var canvas = this.canvas;\n    var context = this.context;\n    var style = this.style;\n    var resolution = style.resolution;\n    var size = style.metrics;\n    style.syncFont(canvas, context);\n    var outputText = this._text;\n\n    if (style.wordWrapWidth || style.wordWrapCallback) {\n      outputText = this.runWordWrap(this._text);\n    } //  Split text into lines\n\n\n    var lines = outputText.split(this.splitRegExp);\n    var textSize = GetTextSize(this, size, lines);\n    var padding = this.padding;\n    var w = textSize.width + padding.left + padding.right;\n    var h = textSize.height + padding.top + padding.bottom;\n\n    if (style.fixedWidth === 0) {\n      this.width = w;\n    }\n\n    if (style.fixedHeight === 0) {\n      this.height = h;\n    }\n\n    this.updateDisplayOrigin();\n    w *= resolution;\n    h *= resolution;\n    w = Math.max(w, 1);\n    h = Math.max(h, 1);\n\n    if (canvas.width !== w || canvas.height !== h) {\n      canvas.width = w;\n      canvas.height = h;\n      this.frame.setSize(w, h);\n      style.syncFont(canvas, context); // Resizing resets the context\n    } else {\n      context.clearRect(0, 0, w, h);\n    }\n\n    context.save();\n    context.scale(resolution, resolution);\n\n    if (style.backgroundColor) {\n      context.fillStyle = style.backgroundColor;\n      context.fillRect(0, 0, w, h);\n    }\n\n    style.syncStyle(canvas, context);\n    context.textBaseline = 'alphabetic'; //  Apply padding\n\n    context.translate(padding.left, padding.top);\n    var linePositionX;\n    var linePositionY; //  Draw text line by line\n\n    for (var i = 0; i < textSize.lines; i++) {\n      linePositionX = style.strokeThickness / 2;\n      linePositionY = style.strokeThickness / 2 + i * textSize.lineHeight + size.ascent;\n\n      if (i > 0) {\n        linePositionY += textSize.lineSpacing * i;\n      }\n\n      if (style.rtl) {\n        linePositionX = w - linePositionX;\n      } else if (style.align === 'right') {\n        linePositionX += textSize.width - textSize.lineWidths[i];\n      } else if (style.align === 'center') {\n        linePositionX += (textSize.width - textSize.lineWidths[i]) / 2;\n      }\n\n      if (this.autoRound) {\n        linePositionX = Math.round(linePositionX);\n        linePositionY = Math.round(linePositionY);\n      }\n\n      if (style.strokeThickness) {\n        this.style.syncShadow(context, style.shadowStroke);\n        context.strokeText(lines[i], linePositionX, linePositionY);\n      }\n\n      if (style.color) {\n        this.style.syncShadow(context, style.shadowFill);\n        context.fillText(lines[i], linePositionX, linePositionY);\n      }\n    }\n\n    context.restore();\n\n    if (this.renderer.gl) {\n      this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);\n      this.frame.glTexture = this.frame.source.glTexture;\n    }\n\n    this.dirty = true;\n    return this;\n  },\n\n  /**\r\n   * Get the current text metrics.\r\n   *\r\n   * @method Phaser.GameObjects.Text#getTextMetrics\r\n   * @since 3.0.0\r\n   *\r\n   * @return {object} The text metrics.\r\n   */\n  getTextMetrics: function getTextMetrics() {\n    return this.style.getTextMetrics();\n  },\n\n  /**\r\n   * The text string being rendered by this Text Game Object.\r\n   *\r\n   * @name Phaser.GameObjects.Text#text\r\n   * @type {string}\r\n   * @since 3.0.0\r\n   */\n  text: {\n    get: function get() {\n      return this._text;\n    },\n    set: function set(value) {\n      this.setText(value);\n    }\n  },\n\n  /**\r\n   * Build a JSON representation of the Text object.\r\n   *\r\n   * @method Phaser.GameObjects.Text#toJSON\r\n   * @since 3.0.0\r\n   *\r\n   * @return {JSONGameObject} A JSON representation of the Text object.\r\n   */\n  toJSON: function toJSON() {\n    var out = Components.ToJSON(this); //  Extra Text data is added here\n\n    var data = {\n      autoRound: this.autoRound,\n      text: this._text,\n      style: this.style.toJSON(),\n      padding: {\n        left: this.padding.left,\n        right: this.padding.right,\n        top: this.padding.top,\n        bottom: this.padding.bottom\n      }\n    };\n    out.data = data;\n    return out;\n  },\n\n  /**\r\n   * Internal destroy handler, called as part of the destroy process.\r\n   *\r\n   * @method Phaser.GameObjects.Text#preDestroy\r\n   * @protected\r\n   * @since 3.0.0\r\n   */\n  preDestroy: function preDestroy() {\n    if (this.style.rtl) {\n      RemoveFromDOM(this.canvas);\n    }\n\n    CanvasPool.remove(this.canvas);\n    this.texture.destroy();\n  }\n});\nmodule.exports = Text;","map":null,"metadata":{},"sourceType":"script"}