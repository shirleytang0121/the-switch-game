{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar GetFastValue = require('../../utils/object/GetFastValue');\n/**\r\n * @typedef {object} GetTilesWithinFilteringOptions\r\n *\r\n * @property {boolean} [isNotEmpty=false] - If true, only return tiles that don't have -1 for an index.\r\n * @property {boolean} [isColliding=false] - If true, only return tiles that collide on at least one side.\r\n * @property {boolean} [hasInterestingFace=false] - If true, only return tiles that have at least one interesting face.\r\n */\n\n/**\r\n * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithin\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {integer} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {integer} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {object} GetTilesWithinFilteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */\n\n\nvar GetTilesWithin = function GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer) {\n  if (tileX === undefined) {\n    tileX = 0;\n  }\n\n  if (tileY === undefined) {\n    tileY = 0;\n  }\n\n  if (width === undefined) {\n    width = layer.width;\n  }\n\n  if (height === undefined) {\n    height = layer.height;\n  }\n\n  var isNotEmpty = GetFastValue(filteringOptions, 'isNotEmpty', false);\n  var isColliding = GetFastValue(filteringOptions, 'isColliding', false);\n  var hasInterestingFace = GetFastValue(filteringOptions, 'hasInterestingFace', false); // Clip x, y to top left of map, while shrinking width/height to match.\n\n  if (tileX < 0) {\n    width += tileX;\n    tileX = 0;\n  }\n\n  if (tileY < 0) {\n    height += tileY;\n    tileY = 0;\n  } // Clip width and height to bottom right of map.\n\n\n  if (tileX + width > layer.width) {\n    width = Math.max(layer.width - tileX, 0);\n  }\n\n  if (tileY + height > layer.height) {\n    height = Math.max(layer.height - tileY, 0);\n  }\n\n  var results = [];\n\n  for (var ty = tileY; ty < tileY + height; ty++) {\n    for (var tx = tileX; tx < tileX + width; tx++) {\n      var tile = layer.data[ty][tx];\n\n      if (tile !== null) {\n        if (isNotEmpty && tile.index === -1) {\n          continue;\n        }\n\n        if (isColliding && !tile.collides) {\n          continue;\n        }\n\n        if (hasInterestingFace && !tile.hasInterestingFace) {\n          continue;\n        }\n\n        results.push(tile);\n      }\n    }\n  }\n\n  return results;\n};\n\nmodule.exports = GetTilesWithin;","map":null,"metadata":{},"sourceType":"script"}