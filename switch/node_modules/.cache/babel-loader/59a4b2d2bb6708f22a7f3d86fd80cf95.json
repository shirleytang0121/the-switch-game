{"ast":null,"code":"/**\r\n* The `Matter.Resolver` module contains methods for resolving collision pairs.\r\n*\r\n* @class Resolver\r\n*/\nvar Resolver = {};\nmodule.exports = Resolver;\n\nvar Vertices = require('../geometry/Vertices');\n\nvar Vector = require('../geometry/Vector');\n\nvar Common = require('../core/Common');\n\nvar Bounds = require('../geometry/Bounds');\n\n(function () {\n  Resolver._restingThresh = 4;\n  Resolver._restingThreshTangent = 6;\n  Resolver._positionDampen = 0.9;\n  Resolver._positionWarming = 0.8;\n  Resolver._frictionNormalMultiplier = 5;\n  /**\r\n   * Prepare pairs for position solving.\r\n   * @method preSolvePosition\r\n   * @param {pair[]} pairs\r\n   */\n\n  Resolver.preSolvePosition = function (pairs) {\n    var i, pair, activeCount; // find total contacts on each body\n\n    for (i = 0; i < pairs.length; i++) {\n      pair = pairs[i];\n      if (!pair.isActive) continue;\n      activeCount = pair.activeContacts.length;\n      pair.collision.parentA.totalContacts += activeCount;\n      pair.collision.parentB.totalContacts += activeCount;\n    }\n  };\n  /**\r\n   * Find a solution for pair positions.\r\n   * @method solvePosition\r\n   * @param {pair[]} pairs\r\n   * @param {body[]} bodies\r\n   * @param {number} timeScale\r\n   */\n\n\n  Resolver.solvePosition = function (pairs, bodies, timeScale) {\n    var i,\n        normalX,\n        normalY,\n        pair,\n        collision,\n        bodyA,\n        bodyB,\n        normal,\n        separation,\n        penetration,\n        positionImpulseA,\n        positionImpulseB,\n        contactShare,\n        bodyBtoAX,\n        bodyBtoAY,\n        positionImpulse,\n        impulseCoefficient = timeScale * Resolver._positionDampen;\n\n    for (i = 0; i < bodies.length; i++) {\n      var body = bodies[i];\n      body.previousPositionImpulse.x = body.positionImpulse.x;\n      body.previousPositionImpulse.y = body.positionImpulse.y;\n    } // find impulses required to resolve penetration\n\n\n    for (i = 0; i < pairs.length; i++) {\n      pair = pairs[i];\n      if (!pair.isActive || pair.isSensor) continue;\n      collision = pair.collision;\n      bodyA = collision.parentA;\n      bodyB = collision.parentB;\n      normal = collision.normal;\n      positionImpulseA = bodyA.previousPositionImpulse;\n      positionImpulseB = bodyB.previousPositionImpulse;\n      penetration = collision.penetration;\n      bodyBtoAX = positionImpulseB.x - positionImpulseA.x + penetration.x;\n      bodyBtoAY = positionImpulseB.y - positionImpulseA.y + penetration.y;\n      normalX = normal.x;\n      normalY = normal.y;\n      separation = normalX * bodyBtoAX + normalY * bodyBtoAY;\n      pair.separation = separation;\n      positionImpulse = (separation - pair.slop) * impulseCoefficient;\n      if (bodyA.isStatic || bodyB.isStatic) positionImpulse *= 2;\n\n      if (!(bodyA.isStatic || bodyA.isSleeping)) {\n        contactShare = positionImpulse / bodyA.totalContacts;\n        bodyA.positionImpulse.x += normalX * contactShare;\n        bodyA.positionImpulse.y += normalY * contactShare;\n      }\n\n      if (!(bodyB.isStatic || bodyB.isSleeping)) {\n        contactShare = positionImpulse / bodyB.totalContacts;\n        bodyB.positionImpulse.x -= normalX * contactShare;\n        bodyB.positionImpulse.y -= normalY * contactShare;\n      }\n    }\n  };\n  /**\r\n   * Apply position resolution.\r\n   * @method postSolvePosition\r\n   * @param {body[]} bodies\r\n   */\n\n\n  Resolver.postSolvePosition = function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i]; // reset contact count\n\n      body.totalContacts = 0;\n\n      if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {\n        // update body geometry\n        for (var j = 0; j < body.parts.length; j++) {\n          var part = body.parts[j];\n          Vertices.translate(part.vertices, body.positionImpulse);\n          Bounds.update(part.bounds, part.vertices, body.velocity);\n          part.position.x += body.positionImpulse.x;\n          part.position.y += body.positionImpulse.y;\n        } // move the body without changing velocity\n\n\n        body.positionPrev.x += body.positionImpulse.x;\n        body.positionPrev.y += body.positionImpulse.y;\n\n        if (Vector.dot(body.positionImpulse, body.velocity) < 0) {\n          // reset cached impulse if the body has velocity along it\n          body.positionImpulse.x = 0;\n          body.positionImpulse.y = 0;\n        } else {\n          // warm the next iteration\n          body.positionImpulse.x *= Resolver._positionWarming;\n          body.positionImpulse.y *= Resolver._positionWarming;\n        }\n      }\n    }\n  };\n  /**\r\n   * Prepare pairs for velocity solving.\r\n   * @method preSolveVelocity\r\n   * @param {pair[]} pairs\r\n   */\n\n\n  Resolver.preSolveVelocity = function (pairs) {\n    var i,\n        j,\n        pair,\n        contacts,\n        collision,\n        bodyA,\n        bodyB,\n        normal,\n        tangent,\n        contact,\n        contactVertex,\n        normalImpulse,\n        tangentImpulse,\n        offset,\n        impulse = Vector._temp[0],\n        tempA = Vector._temp[1];\n\n    for (i = 0; i < pairs.length; i++) {\n      pair = pairs[i];\n      if (!pair.isActive || pair.isSensor) continue;\n      contacts = pair.activeContacts;\n      collision = pair.collision;\n      bodyA = collision.parentA;\n      bodyB = collision.parentB;\n      normal = collision.normal;\n      tangent = collision.tangent; // resolve each contact\n\n      for (j = 0; j < contacts.length; j++) {\n        contact = contacts[j];\n        contactVertex = contact.vertex;\n        normalImpulse = contact.normalImpulse;\n        tangentImpulse = contact.tangentImpulse;\n\n        if (normalImpulse !== 0 || tangentImpulse !== 0) {\n          // total impulse from contact\n          impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;\n          impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse; // apply impulse from contact\n\n          if (!(bodyA.isStatic || bodyA.isSleeping)) {\n            offset = Vector.sub(contactVertex, bodyA.position, tempA);\n            bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\n            bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\n            bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;\n          }\n\n          if (!(bodyB.isStatic || bodyB.isSleeping)) {\n            offset = Vector.sub(contactVertex, bodyB.position, tempA);\n            bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\n            bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\n            bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Find a solution for pair velocities.\r\n   * @method solveVelocity\r\n   * @param {pair[]} pairs\r\n   * @param {number} timeScale\r\n   */\n\n\n  Resolver.solveVelocity = function (pairs, timeScale) {\n    var timeScaleSquared = timeScale * timeScale,\n        impulse = Vector._temp[0],\n        tempA = Vector._temp[1],\n        tempB = Vector._temp[2],\n        tempC = Vector._temp[3],\n        tempD = Vector._temp[4],\n        tempE = Vector._temp[5];\n\n    for (var i = 0; i < pairs.length; i++) {\n      var pair = pairs[i];\n      if (!pair.isActive || pair.isSensor) continue;\n      var collision = pair.collision,\n          bodyA = collision.parentA,\n          bodyB = collision.parentB,\n          normal = collision.normal,\n          tangent = collision.tangent,\n          contacts = pair.activeContacts,\n          contactShare = 1 / contacts.length; // update body velocities\n\n      bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;\n      bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;\n      bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;\n      bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;\n      bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;\n      bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev; // resolve each contact\n\n      for (var j = 0; j < contacts.length; j++) {\n        var contact = contacts[j],\n            contactVertex = contact.vertex,\n            offsetA = Vector.sub(contactVertex, bodyA.position, tempA),\n            offsetB = Vector.sub(contactVertex, bodyB.position, tempB),\n            velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC),\n            velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD),\n            relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE),\n            normalVelocity = Vector.dot(normal, relativeVelocity);\n        var tangentVelocity = Vector.dot(tangent, relativeVelocity),\n            tangentSpeed = Math.abs(tangentVelocity),\n            tangentVelocityDirection = Common.sign(tangentVelocity); // raw impulses\n\n        var normalImpulse = (1 + pair.restitution) * normalVelocity,\n            normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier; // coulomb friction\n\n\n        var tangentImpulse = tangentVelocity,\n            maxFriction = Infinity;\n\n        if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {\n          maxFriction = tangentSpeed;\n          tangentImpulse = Common.clamp(pair.friction * tangentVelocityDirection * timeScaleSquared, -maxFriction, maxFriction);\n        } // modify impulses accounting for mass, inertia and offset\n\n\n        var oAcN = Vector.cross(offsetA, normal),\n            oBcN = Vector.cross(offsetB, normal),\n            share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * oBcN * oBcN);\n        normalImpulse *= share;\n        tangentImpulse *= share; // handle high velocity and resting collisions separately\n\n        if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {\n          // high normal velocity so clear cached contact normal impulse\n          contact.normalImpulse = 0;\n        } else {\n          // solve resting collision constraints using Erin Catto's method (GDC08)\n          // impulse constraint tends to 0\n          var contactNormalImpulse = contact.normalImpulse;\n          contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);\n          normalImpulse = contact.normalImpulse - contactNormalImpulse;\n        } // handle high velocity and resting collisions separately\n\n\n        if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {\n          // high tangent velocity so clear cached contact tangent impulse\n          contact.tangentImpulse = 0;\n        } else {\n          // solve resting collision constraints using Erin Catto's method (GDC08)\n          // tangent impulse tends to -tangentSpeed or +tangentSpeed\n          var contactTangentImpulse = contact.tangentImpulse;\n          contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);\n          tangentImpulse = contact.tangentImpulse - contactTangentImpulse;\n        } // total impulse from contact\n\n\n        impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;\n        impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse; // apply impulse from contact\n\n        if (!(bodyA.isStatic || bodyA.isSleeping)) {\n          bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\n          bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\n          bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;\n        }\n\n        if (!(bodyB.isStatic || bodyB.isSleeping)) {\n          bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\n          bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\n          bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;\n        }\n      }\n    }\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}