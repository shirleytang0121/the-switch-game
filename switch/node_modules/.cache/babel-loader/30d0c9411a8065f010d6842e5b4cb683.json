{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar Components = require('../components');\n\nvar DOMElementRender = require('./DOMElementRender');\n\nvar GameObject = require('../GameObject');\n\nvar RemoveFromDOM = require('../../dom/RemoveFromDOM');\n\nvar Vector4 = require('../../math/Vector4');\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class DOMElement\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.12.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|HTMLElement)} [element] - The DOM Element to use.\r\n */\n\n\nvar DOMElement = new Class({\n  Extends: GameObject,\n  Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Depth, Components.Origin, Components.ScrollFactor, Components.Transform, Components.Visible, DOMElementRender],\n  initialize: function DOMElement(scene, x, y, element) {\n    GameObject.call(this, scene, 'DOMElement');\n    this.parent = scene.sys.game.domContainer;\n    this.cache = scene.sys.cache.html;\n    this.node;\n    this.skewX = 0;\n    this.skewY = 0; //  https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d\n\n    this.rotate3d = new Vector4();\n    this.rotate3dAngle = 'deg';\n    this.handler = this.dispatchNativeEvent.bind(this);\n    this.setPosition(x, y);\n\n    if (element) {\n      this.setElement(element);\n    }\n  },\n  setSkew: function setSkew(x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.skewX = x;\n    this.skewY = y;\n    return this;\n  },\n  perspective: {\n    get: function get() {\n      return parseFloat(this.parent.style.perspective);\n    },\n    set: function set(value) {\n      this.parent.style.perspective = value + 'px';\n    }\n  },\n  setPerspective: function setPerspective(value) {\n    //  Sets it on the DOM Container!\n    this.parent.style.perspective = value + 'px';\n    return this;\n  },\n  addListener: function addListener(events) {\n    if (this.node) {\n      events = events.split(' ');\n\n      for (var i = 0; i < events.length; i++) {\n        this.node.addEventListener(events[i], this.handler, false);\n      }\n    }\n\n    return this;\n  },\n  removeListener: function removeListener(events) {\n    if (this.node) {\n      events = events.split(' ');\n\n      for (var i = 0; i < events.length; i++) {\n        this.node.removeEventListener(events[i], this.handler);\n      }\n    }\n\n    return this;\n  },\n  dispatchNativeEvent: function dispatchNativeEvent(event) {\n    this.emit(event.type, event);\n  },\n  setElement: function setElement(element) {\n    var target;\n\n    if (typeof element === 'string') {\n      target = document.getElementById(element);\n    } else if (typeof element === 'object' && element.nodeType === 1) {\n      target = element;\n    }\n\n    if (!target) {\n      return;\n    }\n\n    this.node = target;\n    target.style.zIndex = '0';\n    target.style.display = 'inline';\n    target.style.position = 'absolute'; //  Node handler\n\n    target.phaser = this;\n\n    if (this.parent) {\n      this.parent.appendChild(target);\n    }\n\n    var nodeBounds = target.getBoundingClientRect();\n    this.setSize(nodeBounds.width || 0, nodeBounds.height || 0);\n    return this;\n  },\n  createFromCache: function createFromCache(key, elementType) {\n    return this.createFromHTML(this.cache.get(key), elementType);\n  },\n  createFromHTML: function createFromHTML(html, elementType) {\n    if (elementType === undefined) {\n      elementType = 'div';\n    }\n\n    var element = document.createElement(elementType);\n    this.node = element;\n    element.style.zIndex = '0';\n    element.style.display = 'inline';\n    element.style.position = 'absolute'; //  Node handler\n\n    element.phaser = this;\n\n    if (this.parent) {\n      this.parent.appendChild(element);\n    }\n\n    element.innerHTML = html;\n    var nodeBounds = element.getBoundingClientRect();\n    this.setSize(nodeBounds.width || 0, nodeBounds.height || 0);\n    return this;\n  },\n  getChildByProperty: function getChildByProperty(property, value) {\n    if (this.node) {\n      var children = this.node.querySelectorAll('*');\n\n      for (var i = 0; i < children.length; i++) {\n        if (children[i][property] === value) {\n          return children[i];\n        }\n      }\n    }\n\n    return null;\n  },\n  getChildByID: function getChildByID(id) {\n    return this.getChildByProperty('id', id);\n  },\n  getChildByName: function getChildByName(name) {\n    return this.getChildByProperty('name', name);\n  },\n  setText: function setText(text) {\n    if (this.node) {\n      this.node.innerText = text;\n      var nodeBounds = this.node.getBoundingClientRect();\n      this.setSize(nodeBounds.width, nodeBounds.height);\n    }\n\n    return this;\n  },\n  setHTML: function setHTML(html) {\n    if (this.node) {\n      this.node.innerHTML = html;\n      var nodeBounds = this.node.getBoundingClientRect();\n      this.setSize(nodeBounds.width, nodeBounds.height);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n   * \r\n   * DOMElements always return `true` as they need to still set values during the render pass, even if not visible.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#willRender\r\n   * @since 3.12.0\r\n   *\r\n   * @return {boolean} True if the Game Object should be rendered, otherwise false.\r\n   */\n  willRender: function willRender() {\n    return true;\n  },\n  destroy: function destroy() {\n    RemoveFromDOM(this.node);\n  }\n});\nmodule.exports = DOMElement;","map":null,"metadata":{},"sourceType":"script"}