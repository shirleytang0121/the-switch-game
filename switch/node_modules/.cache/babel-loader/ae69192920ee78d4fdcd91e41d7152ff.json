{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Tileset = require('../../Tileset');\n\nvar ImageCollection = require('../../ImageCollection');\n\nvar ParseObject = require('./ParseObject');\n/**\r\n * Tilesets & Image Collections\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseTilesets\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - [description]\r\n *\r\n * @return {object} [description]\r\n */\n\n\nvar ParseTilesets = function ParseTilesets(json) {\n  var tilesets = [];\n  var imageCollections = [];\n  var lastSet = null;\n  var stringID;\n\n  for (var i = 0; i < json.tilesets.length; i++) {\n    //  name, firstgid, width, height, margin, spacing, properties\n    var set = json.tilesets[i];\n\n    if (set.source) {\n      console.warn('Phaser can\\'t load external tilesets. Use the Embed Tileset button and then export the map again.');\n    } else if (set.image) {\n      var newSet = new Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing);\n\n      if (json.version > 1) {\n        // Tiled 1.2+\n        if (Array.isArray(set.tiles)) {\n          var tiles = {};\n          var props = {};\n\n          for (var t = 0; t < set.tiles.length; t++) {\n            var tile = set.tiles[t]; //  Convert tileproperties\n\n            if (tile.properties) {\n              var newPropData = {};\n              tile.properties.forEach(function (propData) {\n                newPropData[propData['name']] = propData['value'];\n              });\n              props[tile.id] = newPropData;\n            } //  Convert objectgroup\n\n\n            if (tile.objectgroup) {\n              tiles[tile.id] = {\n                objectgroup: tile.objectgroup\n              };\n\n              if (tile.objectgroup.objects) {\n                var parsedObjects2 = tile.objectgroup.objects.map(function (obj) {\n                  return ParseObject(obj);\n                });\n                tiles[tile.id].objectgroup.objects = parsedObjects2;\n              }\n            } // Copy animation data\n\n\n            if (tile.animation) {\n              if (tiles.hasOwnProperty(tile.id)) {\n                tiles[tile.id].animation = tile.animation;\n              } else {\n                tiles[tile.id] = {\n                  animation: tile.animation\n                };\n              }\n            }\n          }\n\n          newSet.tileData = tiles;\n          newSet.tileProperties = props;\n        }\n      } else {\n        // Tiled 1\n        // Properties stored per-tile in object with string indexes starting at \"0\"\n        if (set.tileproperties) {\n          newSet.tileProperties = set.tileproperties;\n        } // Object & terrain shapes stored per-tile in object with string indexes starting at \"0\"\n\n\n        if (set.tiles) {\n          newSet.tileData = set.tiles; // Parse the objects into Phaser format to match handling of other Tiled objects\n\n          for (stringID in newSet.tileData) {\n            var objectGroup = newSet.tileData[stringID].objectgroup;\n\n            if (objectGroup && objectGroup.objects) {\n              var parsedObjects1 = objectGroup.objects.map(function (obj) {\n                return ParseObject(obj);\n              });\n              newSet.tileData[stringID].objectgroup.objects = parsedObjects1;\n            }\n          }\n        }\n      } // For a normal sliced tileset the row/count/size information is computed when updated.\n      // This is done (again) after the image is set.\n\n\n      newSet.updateTileData(set.imagewidth, set.imageheight);\n      tilesets.push(newSet);\n    } else {\n      var newCollection = new ImageCollection(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);\n\n      for (stringID in set.tiles) {\n        var image = set.tiles[stringID].image;\n        var gid = set.firstgid + parseInt(stringID, 10);\n        newCollection.addImage(gid, image);\n      }\n\n      imageCollections.push(newCollection);\n    } //  We've got a new Tileset, so set the lastgid into the previous one\n\n\n    if (lastSet) {\n      lastSet.lastgid = set.firstgid - 1;\n    }\n\n    lastSet = set;\n  }\n\n  return {\n    tilesets: tilesets,\n    imageCollections: imageCollections\n  };\n};\n\nmodule.exports = ParseTilesets;","map":null,"metadata":{},"sourceType":"script"}