{"ast":null,"code":"/**\r\n* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.\r\n*\r\n* @class Grid\r\n*/\nvar Grid = {};\nmodule.exports = Grid;\n\nvar Pair = require('./Pair');\n\nvar Detector = require('./Detector');\n\nvar Common = require('../core/Common');\n\n(function () {\n  /**\r\n   * Creates a new grid.\r\n   * @method create\r\n   * @param {} options\r\n   * @return {grid} A new grid\r\n   */\n  Grid.create = function (options) {\n    var defaults = {\n      controller: Grid,\n      detector: Detector.collisions,\n      buckets: {},\n      pairs: {},\n      pairsList: [],\n      bucketWidth: 48,\n      bucketHeight: 48\n    };\n    return Common.extend(defaults, options);\n  };\n  /**\r\n   * The width of a single grid bucket.\r\n   *\r\n   * @property bucketWidth\r\n   * @type number\r\n   * @default 48\r\n   */\n\n  /**\r\n   * The height of a single grid bucket.\r\n   *\r\n   * @property bucketHeight\r\n   * @type number\r\n   * @default 48\r\n   */\n\n  /**\r\n   * Updates the grid.\r\n   * @method update\r\n   * @param {grid} grid\r\n   * @param {body[]} bodies\r\n   * @param {engine} engine\r\n   * @param {boolean} forceUpdate\r\n   */\n\n\n  Grid.update = function (grid, bodies, engine, forceUpdate) {\n    var i,\n        col,\n        row,\n        world = engine.world,\n        buckets = grid.buckets,\n        bucket,\n        bucketId,\n        gridChanged = false; // @if DEBUG\n\n    var metrics = engine.metrics;\n    metrics.broadphaseTests = 0; // @endif\n\n    for (i = 0; i < bodies.length; i++) {\n      var body = bodies[i];\n      if (body.isSleeping && !forceUpdate) continue; // don't update out of world bodies\n\n      if (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y) continue;\n\n      var newRegion = Grid._getRegion(grid, body); // if the body has changed grid region\n\n\n      if (!body.region || newRegion.id !== body.region.id || forceUpdate) {\n        // @if DEBUG\n        metrics.broadphaseTests += 1; // @endif\n\n        if (!body.region || forceUpdate) body.region = newRegion;\n\n        var union = Grid._regionUnion(newRegion, body.region); // update grid buckets affected by region change\n        // iterate over the union of both regions\n\n\n        for (col = union.startCol; col <= union.endCol; col++) {\n          for (row = union.startRow; row <= union.endRow; row++) {\n            bucketId = Grid._getBucketId(col, row);\n            bucket = buckets[bucketId];\n            var isInsideNewRegion = col >= newRegion.startCol && col <= newRegion.endCol && row >= newRegion.startRow && row <= newRegion.endRow;\n            var isInsideOldRegion = col >= body.region.startCol && col <= body.region.endCol && row >= body.region.startRow && row <= body.region.endRow; // remove from old region buckets\n\n            if (!isInsideNewRegion && isInsideOldRegion) {\n              if (isInsideOldRegion) {\n                if (bucket) Grid._bucketRemoveBody(grid, bucket, body);\n              }\n            } // add to new region buckets\n\n\n            if (body.region === newRegion || isInsideNewRegion && !isInsideOldRegion || forceUpdate) {\n              if (!bucket) bucket = Grid._createBucket(buckets, bucketId);\n\n              Grid._bucketAddBody(grid, bucket, body);\n            }\n          }\n        } // set the new region\n\n\n        body.region = newRegion; // flag changes so we can update pairs\n\n        gridChanged = true;\n      }\n    } // update pairs list only if pairs changed (i.e. a body changed region)\n\n\n    if (gridChanged) grid.pairsList = Grid._createActivePairsList(grid);\n  };\n  /**\r\n   * Clears the grid.\r\n   * @method clear\r\n   * @param {grid} grid\r\n   */\n\n\n  Grid.clear = function (grid) {\n    grid.buckets = {};\n    grid.pairs = {};\n    grid.pairsList = [];\n  };\n  /**\r\n   * Finds the union of two regions.\r\n   * @method _regionUnion\r\n   * @private\r\n   * @param {} regionA\r\n   * @param {} regionB\r\n   * @return {} region\r\n   */\n\n\n  Grid._regionUnion = function (regionA, regionB) {\n    var startCol = Math.min(regionA.startCol, regionB.startCol),\n        endCol = Math.max(regionA.endCol, regionB.endCol),\n        startRow = Math.min(regionA.startRow, regionB.startRow),\n        endRow = Math.max(regionA.endRow, regionB.endRow);\n    return Grid._createRegion(startCol, endCol, startRow, endRow);\n  };\n  /**\r\n   * Gets the region a given body falls in for a given grid.\r\n   * @method _getRegion\r\n   * @private\r\n   * @param {} grid\r\n   * @param {} body\r\n   * @return {} region\r\n   */\n\n\n  Grid._getRegion = function (grid, body) {\n    var bounds = body.bounds,\n        startCol = Math.floor(bounds.min.x / grid.bucketWidth),\n        endCol = Math.floor(bounds.max.x / grid.bucketWidth),\n        startRow = Math.floor(bounds.min.y / grid.bucketHeight),\n        endRow = Math.floor(bounds.max.y / grid.bucketHeight);\n    return Grid._createRegion(startCol, endCol, startRow, endRow);\n  };\n  /**\r\n   * Creates a region.\r\n   * @method _createRegion\r\n   * @private\r\n   * @param {} startCol\r\n   * @param {} endCol\r\n   * @param {} startRow\r\n   * @param {} endRow\r\n   * @return {} region\r\n   */\n\n\n  Grid._createRegion = function (startCol, endCol, startRow, endRow) {\n    return {\n      id: startCol + ',' + endCol + ',' + startRow + ',' + endRow,\n      startCol: startCol,\n      endCol: endCol,\n      startRow: startRow,\n      endRow: endRow\n    };\n  };\n  /**\r\n   * Gets the bucket id at the given position.\r\n   * @method _getBucketId\r\n   * @private\r\n   * @param {} column\r\n   * @param {} row\r\n   * @return {string} bucket id\r\n   */\n\n\n  Grid._getBucketId = function (column, row) {\n    return 'C' + column + 'R' + row;\n  };\n  /**\r\n   * Creates a bucket.\r\n   * @method _createBucket\r\n   * @private\r\n   * @param {} buckets\r\n   * @param {} bucketId\r\n   * @return {} bucket\r\n   */\n\n\n  Grid._createBucket = function (buckets, bucketId) {\n    var bucket = buckets[bucketId] = [];\n    return bucket;\n  };\n  /**\r\n   * Adds a body to a bucket.\r\n   * @method _bucketAddBody\r\n   * @private\r\n   * @param {} grid\r\n   * @param {} bucket\r\n   * @param {} body\r\n   */\n\n\n  Grid._bucketAddBody = function (grid, bucket, body) {\n    // add new pairs\n    for (var i = 0; i < bucket.length; i++) {\n      var bodyB = bucket[i];\n      if (body.id === bodyB.id || body.isStatic && bodyB.isStatic) continue; // keep track of the number of buckets the pair exists in\n      // important for Grid.update to work\n\n      var pairId = Pair.id(body, bodyB),\n          pair = grid.pairs[pairId];\n\n      if (pair) {\n        pair[2] += 1;\n      } else {\n        grid.pairs[pairId] = [body, bodyB, 1];\n      }\n    } // add to bodies (after pairs, otherwise pairs with self)\n\n\n    bucket.push(body);\n  };\n  /**\r\n   * Removes a body from a bucket.\r\n   * @method _bucketRemoveBody\r\n   * @private\r\n   * @param {} grid\r\n   * @param {} bucket\r\n   * @param {} body\r\n   */\n\n\n  Grid._bucketRemoveBody = function (grid, bucket, body) {\n    // remove from bucket\n    bucket.splice(Common.indexOf(bucket, body), 1); // update pair counts\n\n    for (var i = 0; i < bucket.length; i++) {\n      // keep track of the number of buckets the pair exists in\n      // important for _createActivePairsList to work\n      var bodyB = bucket[i],\n          pairId = Pair.id(body, bodyB),\n          pair = grid.pairs[pairId];\n      if (pair) pair[2] -= 1;\n    }\n  };\n  /**\r\n   * Generates a list of the active pairs in the grid.\r\n   * @method _createActivePairsList\r\n   * @private\r\n   * @param {} grid\r\n   * @return [] pairs\r\n   */\n\n\n  Grid._createActivePairsList = function (grid) {\n    var pairKeys,\n        pair,\n        pairs = []; // grid.pairs is used as a hashmap\n\n    pairKeys = Common.keys(grid.pairs); // iterate over grid.pairs\n\n    for (var k = 0; k < pairKeys.length; k++) {\n      pair = grid.pairs[pairKeys[k]]; // if pair exists in at least one bucket\n      // it is a pair that needs further collision testing so push it\n\n      if (pair[2] > 0) {\n        pairs.push(pair);\n      } else {\n        delete grid.pairs[pairKeys[k]];\n      }\n    }\n\n    return pairs;\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}