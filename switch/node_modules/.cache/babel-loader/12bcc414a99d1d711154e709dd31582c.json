{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar TileCheckX = require('./TileCheckX');\n\nvar TileCheckY = require('./TileCheckY');\n\nvar TileIntersectsBody = require('./TileIntersectsBody');\n/**\r\n * The core separation function to separate a physics body and a tile.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.SeparateTile\r\n * @since 3.0.0\r\n *\r\n * @param {number} i - The index of the tile within the map data.\r\n * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\r\n * @param {Phaser.Tilemaps.Tile} tile - The tile to collide against.\r\n * @param {Phaser.Geom.Rectangle} tileWorldRect - A rectangle-like object defining the dimensions of the tile.\r\n * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The tilemapLayer to collide against.\r\n * @param {number} tileBias - The tile bias value. Populated by the `World.TILE_BIAS` constant.\r\n *\r\n * @return {boolean} `true` if the body was separated, otherwise `false`.\r\n */\n\n\nvar SeparateTile = function SeparateTile(i, body, tile, tileWorldRect, tilemapLayer, tileBias) {\n  var tileLeft = tileWorldRect.left;\n  var tileTop = tileWorldRect.top;\n  var tileRight = tileWorldRect.right;\n  var tileBottom = tileWorldRect.bottom;\n  var faceHorizontal = tile.faceLeft || tile.faceRight;\n  var faceVertical = tile.faceTop || tile.faceBottom; //  We don't need to go any further if this tile doesn't actually have any colliding faces. This\n  //  could happen if the tile was meant to be collided with re: a callback, but otherwise isn't\n  //  needed for separation.\n\n  if (!faceHorizontal && !faceVertical) {\n    return false;\n  }\n\n  var ox = 0;\n  var oy = 0;\n  var minX = 0;\n  var minY = 1;\n\n  if (body.deltaAbsX() > body.deltaAbsY()) {\n    //  Moving faster horizontally, check X axis first\n    minX = -1;\n  } else if (body.deltaAbsX() < body.deltaAbsY()) {\n    //  Moving faster vertically, check Y axis first\n    minY = -1;\n  }\n\n  if (body.deltaX() !== 0 && body.deltaY() !== 0 && faceHorizontal && faceVertical) {\n    //  We only need do this if both axes have colliding faces AND we're moving in both\n    //  directions\n    minX = Math.min(Math.abs(body.position.x - tileRight), Math.abs(body.right - tileLeft));\n    minY = Math.min(Math.abs(body.position.y - tileBottom), Math.abs(body.bottom - tileTop));\n  }\n\n  if (minX < minY) {\n    if (faceHorizontal) {\n      ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias); //  That's horizontal done, check if we still intersects? If not then we can return now\n\n      if (ox !== 0 && !TileIntersectsBody(tileWorldRect, body)) {\n        return true;\n      }\n    }\n\n    if (faceVertical) {\n      oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias);\n    }\n  } else {\n    if (faceVertical) {\n      oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias); //  That's vertical done, check if we still intersects? If not then we can return now\n\n      if (oy !== 0 && !TileIntersectsBody(tileWorldRect, body)) {\n        return true;\n      }\n    }\n\n    if (faceHorizontal) {\n      ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias);\n    }\n  }\n\n  return ox !== 0 || oy !== 0;\n};\n\nmodule.exports = SeparateTile;","map":null,"metadata":{},"sourceType":"script"}