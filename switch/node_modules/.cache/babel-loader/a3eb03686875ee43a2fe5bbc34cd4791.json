{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar CONST = require('./const');\n\nvar Class = require('../utils/Class');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar GameEvents = require('../core/events');\n\nvar GetInnerHeight = require('../dom/GetInnerHeight');\n\nvar GetTarget = require('../dom/GetTarget');\n\nvar GetScreenOrientation = require('../dom/GetScreenOrientation');\n\nvar NOOP = require('../utils/NOOP');\n\nvar Rectangle = require('../geom/rectangle/Rectangle');\n\nvar Size = require('../structs/Size');\n\nvar SnapFloor = require('../math/snap/SnapFloor');\n\nvar Vector2 = require('../math/Vector2');\n/**\r\n * @classdesc\r\n * The Scale Manager handles the scaling, resizing and alignment of the game canvas.\r\n * \r\n * The way scaling is handled is by setting the game canvas to a fixed size, which is defined in the\r\n * game configuration. You also define the parent container in the game config. If no parent is given,\r\n * it will default to using the document body. The Scale Manager will then look at the available space\r\n * within the _parent_ and scale the canvas accordingly. Scaling is handled by setting the canvas CSS\r\n * width and height properties, leaving the width and height of the canvas element itself untouched.\r\n * Scaling is therefore achieved by keeping the core canvas the same size and 'stretching'\r\n * it via its CSS properties. This gives the same result and speed as using the `transform-scale` CSS\r\n * property, without the need for browser prefix handling.\r\n * \r\n * The calculations for the scale are heavily influenced by the bounding parent size, which is the computed\r\n * dimensions of the canvas's parent. The CSS rules of the parent element play an important role in the\r\n * operation of the Scale Manager. For example, if the parent has no defined width or height, then actions\r\n * like auto-centering will fail to achieve the required result. The Scale Manager works in tandem with the\r\n * CSS you set-up on the page hosting your game, rather than taking control of it.\r\n * \r\n * #### Parent and Display canvas containment guidelines:\r\n *\r\n * - Style the Parent element (of the game canvas) to control the Parent size and thus the games size and layout.\r\n *\r\n * - The Parent element's CSS styles should _effectively_ apply maximum (and minimum) bounding behavior.\r\n *\r\n * - The Parent element should _not_ apply a padding as this is not accounted for.\r\n *   If a padding is required apply it to the Parent's parent or apply a margin to the Parent.\r\n *   If you need to add a border, margin or any other CSS around your game container, then use a parent element and\r\n *   apply the CSS to this instead, otherwise you'll be constantly resizing the shape of the game container.\r\n *\r\n * - The Display canvas layout CSS styles (i.e. margins, size) should not be altered / specified as\r\n *   they may be updated by the Scale Manager.\r\n *\r\n * #### Scale Modes\r\n * \r\n * The way the scaling is handled is determined by the `scaleMode` property. The default is `NO_SCALE`,\r\n * which prevents Phaser from scaling or touching the canvas, or its parent, at all. In this mode, you are\r\n * responsible for all scaling. The other scaling modes afford you automatic scaling.\r\n * \r\n * If you wish to scale your game so that it always fits into the available space within the parent, you\r\n * should use the scale mode `FIT`. Look at the documentation for other scale modes to see what options are\r\n * available. Here is a basic config showing how to set this scale mode:\r\n * \r\n * ```javascript\r\n * scale: {\r\n *     parent: 'yourgamediv',\r\n *     mode: Phaser.Scale.FIT,\r\n *     width: 800,\r\n *     height: 600\r\n * }\r\n * ```\r\n * \r\n * Place the `scale` config object within your game config.\r\n * \r\n * If you wish for the canvas to be resized directly, so that the canvas itself fills the available space\r\n * (i.e. it isn't scaled, it's resized) then use the `RESIZE` scale mode. This will give you a 1:1 mapping\r\n * of canvas pixels to game size. In this mode CSS isn't used to scale the canvas, it's literally adjusted\r\n * to fill all available space within the parent. You should be extremely careful about the size of the\r\n * canvas you're creating when doing this, as the larger the area, the more work the GPU has to do and it's\r\n * very easy to hit fill-rate limits quickly.\r\n * \r\n * For complex, custom-scaling requirements, you should probably consider using the `RESIZE` scale mode,\r\n * with your own limitations in place re: canvas dimensions and managing the scaling with the game scenes\r\n * yourself. For the vast majority of games, however, the `FIT` mode is likely to be the most used.\r\n * \r\n * Please appreciate that the Scale Manager cannot perform miracles. All it does is scale your game canvas\r\n * as best it can, based on what it can infer from its surrounding area. There are all kinds of environments\r\n * where it's up to you to guide and help the canvas position itself, especially when built into rendering\r\n * frameworks like React and Vue. If your page requires meta tags to prevent user scaling gestures, or such\r\n * like, then it's up to you to ensure they are present in the html.\r\n * \r\n * #### Centering\r\n * \r\n * You can also have the game canvas automatically centered. Again, this relies heavily on the parent being\r\n * properly configured and styled, as the centering offsets are based entirely on the available space\r\n * within the parent element. Centering is disabled by default, or can be applied horizontally, vertically,\r\n * or both. Here's an example:\r\n * \r\n * ```javascript\r\n * scale: {\r\n *     parent: 'yourgamediv',\r\n *     autoCenter: Phaser.Scale.CENTER_BOTH,\r\n *     width: 800,\r\n *     height: 600\r\n * }\r\n * ```\r\n * \r\n * #### Fullscreen API\r\n * \r\n * If the browser supports it, you can send your game into fullscreen mode. In this mode, the game will fill\r\n * the entire display, removing all browser UI and anything else present on the screen. It will remain in this\r\n * mode until your game either disables it, or until the user tabs out or presses ESCape if on desktop. It's a\r\n * great way to achieve a desktop-game like experience from the browser, but it does require a modern browser\r\n * to handle it. Some mobile browsers also support this.\r\n *\r\n * @class ScaleManager\r\n * @memberof Phaser.Scale\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.16.0\r\n *\r\n * @param {Phaser.Game} game - A reference to the Phaser.Game instance.\r\n */\n\n\nvar ScaleManager = new Class({\n  Extends: EventEmitter,\n  initialize: function ScaleManager(game) {\n    EventEmitter.call(this);\n    /**\r\n     * A reference to the Phaser.Game instance.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#game\r\n     * @type {Phaser.Game}\r\n     * @readonly\r\n     * @since 3.15.0\r\n     */\n\n    this.game = game;\n    /**\r\n     * A reference to the HTML Canvas Element that Phaser uses to render the game.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#canvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.16.0\r\n     */\n\n    this.canvas;\n    /**\r\n     * The DOM bounds of the canvas element.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#canvasBounds\r\n     * @type {Phaser.Geom.Rectangle}\r\n     * @since 3.16.0\r\n     */\n\n    this.canvasBounds = new Rectangle();\n    /**\r\n     * The parent object of the Canvas. Often a div, or the browser window, or nothing in non-browser environments.\r\n     * \r\n     * This is set in the Game Config as the `parent` property. If undefined (or just not present), it will default\r\n     * to use the document body. If specifically set to `null` Phaser will ignore all parent operations.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#parent\r\n     * @type {?any}\r\n     * @since 3.16.0\r\n     */\n\n    this.parent = null;\n    /**\r\n     * Is the parent element the browser window?\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#parentIsWindow\r\n     * @type {boolean}\r\n     * @since 3.16.0\r\n     */\n\n    this.parentIsWindow = false;\n    /**\r\n     * The Parent Size component.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#parentSize\r\n     * @type {Phaser.Structs.Size}\r\n     * @since 3.16.0\r\n     */\n\n    this.parentSize = new Size();\n    /**\r\n     * The Game Size component.\r\n     * \r\n     * The un-modified game size, as requested in the game config (the raw width / height),\r\n     * as used for world bounds, cameras, etc\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#gameSize\r\n     * @type {Phaser.Structs.Size}\r\n     * @since 3.16.0\r\n     */\n\n    this.gameSize = new Size();\n    /**\r\n     * The Base Size component.\r\n     * \r\n     * The modified game size, which is the gameSize * resolution, used to set the canvas width and height\r\n     * (but not the CSS style)\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#baseSize\r\n     * @type {Phaser.Structs.Size}\r\n     * @since 3.16.0\r\n     */\n\n    this.baseSize = new Size();\n    /**\r\n     * The Display Size component.\r\n     * \r\n     * The size used for the canvas style, factoring in the scale mode, parent and other values.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#displaySize\r\n     * @type {Phaser.Structs.Size}\r\n     * @since 3.16.0\r\n     */\n\n    this.displaySize = new Size();\n    /**\r\n     * The game scale mode.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#scaleMode\r\n     * @type {Phaser.Scale.ScaleModeType}\r\n     * @since 3.16.0\r\n     */\n\n    this.scaleMode = CONST.SCALE_MODE.NONE;\n    /**\r\n     * The canvas resolution.\r\n     * \r\n     * This is hard-coded to a value of 1 in the 3.16 release of Phaser and will be enabled at a later date.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#resolution\r\n     * @type {number}\r\n     * @since 3.16.0\r\n     */\n\n    this.resolution = 1;\n    /**\r\n     * The game zoom factor.\r\n     * \r\n     * This value allows you to multiply your games base size by the given zoom factor.\r\n     * This is then used when calculating the display size, even in `NO_SCALE` situations.\r\n     * If you don't want Phaser to touch the canvas style at all, this value should be 1.\r\n     * \r\n     * Can also be set to `MAX_ZOOM` in which case the zoom value will be derived based\r\n     * on the game size and available space within the parent.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#zoom\r\n     * @type {number}\r\n     * @since 3.16.0\r\n     */\n\n    this.zoom = 1;\n    /**\r\n     * The scale factor between the baseSize and the canvasBounds.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#displayScale\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.16.0\r\n     */\n\n    this.displayScale = new Vector2(1, 1);\n    /**\r\n     * If set, the canvas sizes will be automatically passed through Math.floor.\r\n     * This results in rounded pixel display values, which is important for performance on legacy\r\n     * and low powered devices, but at the cost of not achieving a 'perfect' fit in some browser windows.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#autoRound\r\n     * @type {boolean}\r\n     * @since 3.16.0\r\n     */\n\n    this.autoRound = false;\n    /**\r\n     * Automatically center the canvas within the parent? The different centering modes are:\r\n     * \r\n     * 1. No centering.\r\n     * 2. Center both horizontally and vertically.\r\n     * 3. Center horizontally.\r\n     * 4. Center vertically.\r\n     * \r\n     * Please be aware that in order to center the game canvas, you must have specified a parent\r\n     * that has a size set, or the canvas parent is the document.body.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#autoCenter\r\n     * @type {Phaser.Scale.CenterType}\r\n     * @since 3.16.0\r\n     */\n\n    this.autoCenter = CONST.CENTER.NO_CENTER;\n    /**\r\n     * The current device orientation.\r\n     * \r\n     * Orientation events are dispatched via the Device Orientation API, typically only on mobile browsers.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#orientation\r\n     * @type {Phaser.Scale.OrientationType}\r\n     * @since 3.16.0\r\n     */\n\n    this.orientation = CONST.ORIENTATION.LANDSCAPE;\n    /**\r\n     * A reference to the Device.Fullscreen object.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#fullscreen\r\n     * @type {Phaser.Device.Fullscreen}\r\n     * @since 3.16.0\r\n     */\n\n    this.fullscreen;\n    /**\r\n     * The DOM Element which is sent into fullscreen mode.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#fullscreenTarget\r\n     * @type {?any}\r\n     * @since 3.16.0\r\n     */\n\n    this.fullscreenTarget = null;\n    /**\r\n     * Did Phaser create the fullscreen target div, or was it provided in the game config?\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#_createdFullscreenTarget\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this._createdFullscreenTarget = false;\n    /**\r\n     * Internal var that keeps track of the user, or the browser, requesting fullscreen changes.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#_requestedFullscreenChange\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.16.2\r\n     */\n\n    this._requestedFullscreenChange = false;\n    /**\r\n     * The dirty state of the Scale Manager.\r\n     * Set if there is a change between the parent size and the current size.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#dirty\r\n     * @type {boolean}\r\n     * @since 3.16.0\r\n     */\n\n    this.dirty = false;\n    /**\r\n     * How many milliseconds should elapse before checking if the browser size has changed?\r\n     * \r\n     * Most modern browsers dispatch a 'resize' event, which the Scale Manager will listen for.\r\n     * However, older browsers fail to do this, or do it consistently, so we fall back to a\r\n     * more traditional 'size check' based on a time interval. You can control how often it is\r\n     * checked here.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#resizeInterval\r\n     * @type {integer}\r\n     * @since 3.16.0\r\n     */\n\n    this.resizeInterval = 500;\n    /**\r\n     * Internal size interval tracker.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#_lastCheck\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this._lastCheck = 0;\n    /**\r\n     * Internal flag to check orientation state.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#_checkOrientation\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this._checkOrientation = false;\n    /**\r\n     * Internal object containing our defined event listeners.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#listeners\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this.listeners = {\n      orientationChange: NOOP,\n      windowResize: NOOP,\n      fullScreenChange: NOOP,\n      fullScreenError: NOOP\n    };\n  },\n\n  /**\r\n   * Called _before_ the canvas object is created and added to the DOM.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#preBoot\r\n   * @protected\r\n   * @listens Phaser.Core.Events#BOOT\r\n   * @since 3.16.0\r\n   */\n  preBoot: function preBoot() {\n    //  Parse the config to get the scaling values we need\n    this.parseConfig(this.game.config);\n    this.game.events.once('boot', this.boot, this);\n  },\n\n  /**\r\n   * The Boot handler is called by Phaser.Game when it first starts up.\r\n   * The renderer is available by now and the canvas has been added to the DOM.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#boot\r\n   * @protected\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   */\n  boot: function boot() {\n    var game = this.game;\n    this.canvas = game.canvas;\n    this.fullscreen = game.device.fullscreen;\n\n    if (this.scaleMode !== CONST.SCALE_MODE.RESIZE) {\n      this.displaySize.setAspectMode(this.scaleMode);\n    }\n\n    if (this.scaleMode === CONST.SCALE_MODE.NONE) {\n      this.resize(this.width, this.height);\n    } else {\n      this.getParentBounds(); //  Only set the parent bounds if the parent has an actual size\n\n      if (this.parentSize.width > 0 && this.parentSize.height > 0) {\n        this.displaySize.setParent(this.parentSize);\n      }\n\n      this.refresh();\n    }\n\n    game.events.on(GameEvents.PRE_STEP, this.step, this);\n    this.startListeners();\n  },\n\n  /**\r\n   * Parses the game configuration to set-up the scale defaults.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#parseConfig\r\n   * @protected\r\n   * @since 3.16.0\r\n   * \r\n   * @param {GameConfig} config - The Game configuration object.\r\n   */\n  parseConfig: function parseConfig(config) {\n    //  Get the parent element, if any\n    this.getParent(config); //  Get the size of the parent element\n    //  This can often set a height of zero (especially for un-styled divs)\n\n    this.getParentBounds();\n    var width = config.width;\n    var height = config.height;\n    var scaleMode = config.scaleMode;\n    var resolution = config.resolution;\n    var zoom = config.zoom;\n    var autoRound = config.autoRound; //  If width = '100%', or similar value\n\n    if (typeof width === 'string') {\n      //  If we have a parent with a height, we'll work it out from that\n      var parentWidth = this.parentSize.width;\n\n      if (parentWidth === 0) {\n        parentWidth = window.innerWidth;\n      }\n\n      var parentScaleX = parseInt(width, 10) / 100;\n      width = Math.floor(parentWidth * parentScaleX);\n    } //  If height = '100%', or similar value\n\n\n    if (typeof height === 'string') {\n      //  If we have a parent with a height, we'll work it out from that\n      var parentHeight = this.parentSize.height;\n\n      if (parentHeight === 0) {\n        parentHeight = window.innerHeight;\n      }\n\n      var parentScaleY = parseInt(height, 10) / 100;\n      height = Math.floor(parentHeight * parentScaleY);\n    } //  This is fixed at 1 on purpose.\n    //  Changing it will break all user input.\n    //  Wait for another release to solve this issue.\n\n\n    this.resolution = 1;\n    this.scaleMode = scaleMode;\n    this.autoRound = autoRound;\n    this.autoCenter = config.autoCenter;\n    this.resizeInterval = config.resizeInterval;\n\n    if (autoRound) {\n      width = Math.floor(width);\n      height = Math.floor(height);\n    } //  The un-modified game size, as requested in the game config (the raw width / height) as used for world bounds, etc\n\n\n    this.gameSize.setSize(width, height);\n\n    if (zoom === CONST.ZOOM.MAX_ZOOM) {\n      zoom = this.getMaxZoom();\n    }\n\n    this.zoom = zoom; //  The modified game size, which is the w/h * resolution\n\n    this.baseSize.setSize(width * resolution, height * resolution);\n\n    if (autoRound) {\n      this.baseSize.width = Math.floor(this.baseSize.width);\n      this.baseSize.height = Math.floor(this.baseSize.height);\n    }\n\n    if (config.minWidth > 0) {\n      this.displaySize.setMin(config.minWidth * zoom, config.minHeight * zoom);\n    }\n\n    if (config.maxWidth > 0) {\n      this.displaySize.setMax(config.maxWidth * zoom, config.maxHeight * zoom);\n    } //  The size used for the canvas style, factoring in the scale mode and parent and zoom value\n    //  We just use the w/h here as this is what sets the aspect ratio (which doesn't then change)\n\n\n    this.displaySize.setSize(width, height);\n    this.orientation = GetScreenOrientation(width, height);\n  },\n\n  /**\r\n   * Determines the parent element of the game canvas, if any, based on the game configuration.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#getParent\r\n   * @since 3.16.0\r\n   * \r\n   * @param {GameConfig} config - The Game configuration object.\r\n   */\n  getParent: function getParent(config) {\n    var parent = config.parent;\n\n    if (parent === null) {\n      //  User is responsible for managing the parent\n      return;\n    }\n\n    this.parent = GetTarget(parent);\n    this.parentIsWindow = this.parent === document.body;\n\n    if (config.expandParent && config.scaleMode !== CONST.SCALE_MODE.NONE) {\n      var DOMRect = this.parent.getBoundingClientRect();\n\n      if (this.parentIsWindow || DOMRect.height === 0) {\n        document.documentElement.style.height = '100%';\n        document.body.style.height = '100%';\n        DOMRect = this.parent.getBoundingClientRect(); //  The parent STILL has no height, clearly no CSS\n        //  has been set on it even though we fixed the body :(\n\n        if (!this.parentIsWindow && DOMRect.height === 0) {\n          this.parent.style.overflow = 'hidden';\n          this.parent.style.width = '100%';\n          this.parent.style.height = '100%';\n        }\n      }\n    } //  And now get the fullscreenTarget\n\n\n    if (config.fullscreenTarget && !this.fullscreenTarget) {\n      this.fullscreenTarget = GetTarget(config.fullscreenTarget);\n    }\n  },\n\n  /**\r\n   * Calculates the size of the parent bounds and updates the `parentSize` component, if the canvas has a dom parent.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#getParentBounds\r\n   * @since 3.16.0\r\n   * \r\n   * @return {boolean} `true` if the parent bounds have changed size, otherwise `false`.\r\n   */\n  getParentBounds: function getParentBounds() {\n    if (!this.parent) {\n      return false;\n    }\n\n    var parentSize = this.parentSize; // Ref. http://msdn.microsoft.com/en-us/library/hh781509(v=vs.85).aspx for getBoundingClientRect\n\n    var DOMRect = this.parent.getBoundingClientRect();\n\n    if (this.parentIsWindow && this.game.device.os.iOS) {\n      DOMRect.height = GetInnerHeight(true);\n    }\n\n    var resolution = this.resolution;\n    var newWidth = DOMRect.width * resolution;\n    var newHeight = DOMRect.height * resolution;\n\n    if (parentSize.width !== newWidth || parentSize.height !== newHeight) {\n      parentSize.setSize(newWidth, newHeight);\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  /**\r\n   * Attempts to lock the orientation of the web browser using the Screen Orientation API.\r\n   * \r\n   * This API is only available on modern mobile browsers.\r\n   * See https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation for details.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#lockOrientation\r\n   * @since 3.16.0\r\n   * \r\n   * @param {string} orientation - The orientation you'd like to lock the browser in. Should be an API string such as 'landscape', 'landscape-primary', 'portrait', etc.\r\n   * \r\n   * @return {boolean} `true` if the orientation was successfully locked, otherwise `false`.\r\n   */\n  lockOrientation: function lockOrientation(orientation) {\n    var lock = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;\n\n    if (lock) {\n      return lock(orientation);\n    }\n\n    return false;\n  },\n\n  /**\r\n   * This method will set the size of the Parent Size component, which is used in scaling\r\n   * and centering calculations. You only need to call this method if you have explicitly\r\n   * disabled the use of a parent in your game config, but still wish to take advantage of\r\n   * other Scale Manager features.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#setParentSize\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @param {number} width - The new width of the parent.\r\n   * @param {number} height - The new height of the parent.\r\n   * \r\n   * @return {this} The Scale Manager instance.\r\n   */\n  setParentSize: function setParentSize(width, height) {\n    this.parentSize.setSize(width, height);\n    return this.refresh();\n  },\n\n  /**\r\n   * This method will set a new size for your game.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#setGameSize\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @param {number} width - The new width of the game.\r\n   * @param {number} height - The new height of the game.\r\n   * \r\n   * @return {this} The Scale Manager instance.\r\n   */\n  setGameSize: function setGameSize(width, height) {\n    var autoRound = this.autoRound;\n    var resolution = this.resolution;\n\n    if (autoRound) {\n      width = Math.floor(width);\n      height = Math.floor(height);\n    }\n\n    this.gameSize.resize(width, height);\n    this.baseSize.resize(width * resolution, height * resolution);\n    this.updateBounds();\n    this.displayScale.set(width / this.canvasBounds.width, height / this.canvasBounds.height);\n    this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, this.resolution);\n    this.updateOrientation();\n    return this.refresh();\n  },\n\n  /**\r\n   * Call this to modify the size of the Phaser canvas element directly.\r\n   * You should only use this if you are using the `NO_SCALE` scale mode,\r\n   * it will update all internal components completely.\r\n   * \r\n   * If all you want to do is change the size of the parent, see the `setParentSize` method.\r\n   * \r\n   * If all you want is to change the base size of the game, but still have the Scale Manager\r\n   * manage all the scaling, then see the `setGameSize` method.\r\n   * \r\n   * This method will set the `gameSize`, `baseSize` and `displaySize` components to the given\r\n   * dimensions. It will then resize the canvas width and height to the values given, by\r\n   * directly setting the properties. Finally, if you have set the Scale Manager zoom value\r\n   * to anything other than 1 (the default), it will set the canvas CSS width and height to\r\n   * be the given size multiplied by the zoom factor (the canvas pixel size remains untouched).\r\n   * \r\n   * If you have enabled `autoCenter`, it is then passed to the `updateCenter` method and\r\n   * the margins are set, allowing the canvas to be centered based on its parent element\r\n   * alone. Finally, the `displayScale` is adjusted and the RESIZE event dispatched.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#resize\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @param {number} width - The new width of the game.\r\n   * @param {number} height - The new height of the game.\r\n   * \r\n   * @return {this} The Scale Manager instance.\r\n   */\n  resize: function resize(width, height) {\n    var zoom = this.zoom;\n    var resolution = this.resolution;\n    var autoRound = this.autoRound;\n\n    if (autoRound) {\n      width = Math.floor(width);\n      height = Math.floor(height);\n    }\n\n    this.gameSize.resize(width, height);\n    this.baseSize.resize(width * resolution, height * resolution);\n    this.displaySize.setSize(width * zoom * resolution, height * zoom * resolution);\n    this.canvas.width = this.baseSize.width;\n    this.canvas.height = this.baseSize.height;\n    var style = this.canvas.style;\n    var styleWidth = width * zoom;\n    var styleHeight = height * zoom;\n\n    if (autoRound) {\n      styleWidth = Math.floor(styleWidth);\n      styleHeight = Math.floor(styleHeight);\n    }\n\n    if (styleWidth !== width || styleHeight !== height) {\n      style.width = styleWidth + 'px';\n      style.height = styleHeight + 'px';\n    }\n\n    this.getParentBounds();\n    this.updateCenter();\n    this.updateBounds();\n    this.displayScale.set(width / this.canvasBounds.width, height / this.canvasBounds.height);\n    this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, this.resolution);\n    this.updateOrientation();\n    return this;\n  },\n\n  /**\r\n   * Sets the zoom value of the Scale Manager.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#setZoom\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @param {integer} value - The new zoom value of the game.\r\n   * \r\n   * @return {this} The Scale Manager instance.\r\n   */\n  setZoom: function setZoom(value) {\n    this.zoom = value;\n    return this.refresh();\n  },\n\n  /**\r\n   * Sets the zoom to be the maximum possible based on the _current_ parent size.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#setMaxZoom\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @return {this} The Scale Manager instance.\r\n   */\n  setMaxZoom: function setMaxZoom() {\n    this.zoom = this.getMaxZoom();\n    return this.refresh();\n  },\n\n  /**\r\n   * Refreshes the internal scale values, bounds sizes and orientation checks.\r\n   * \r\n   * Once finished, dispatches the resize event.\r\n   * \r\n   * This is called automatically by the Scale Manager when the browser window size changes,\r\n   * as long as it is using a Scale Mode other than 'NONE'.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#refresh\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @return {this} The Scale Manager instance.\r\n   */\n  refresh: function refresh() {\n    this.updateScale();\n    this.updateBounds();\n    this.updateOrientation();\n    this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);\n    this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, this.resolution);\n    return this;\n  },\n\n  /**\r\n   * Internal method that checks the current screen orientation, only if the internal check flag is set.\r\n   * \r\n   * If the orientation has changed it updates the orientation property and then dispatches the orientation change event.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#updateOrientation\r\n   * @fires Phaser.Scale.Events#ORIENTATION_CHANGE\r\n   * @since 3.16.0\r\n   */\n  updateOrientation: function updateOrientation() {\n    if (this._checkOrientation) {\n      this._checkOrientation = false;\n      var newOrientation = GetScreenOrientation(this.width, this.height);\n\n      if (newOrientation !== this.orientation) {\n        this.orientation = newOrientation;\n        this.emit(Events.ORIENTATION_CHANGE, newOrientation);\n      }\n    }\n  },\n\n  /**\r\n   * Internal method that manages updating the size components based on the scale mode.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#updateScale\r\n   * @since 3.16.0\r\n   */\n  updateScale: function updateScale() {\n    var style = this.canvas.style;\n    var width = this.gameSize.width;\n    var height = this.gameSize.height;\n    var styleWidth;\n    var styleHeight;\n    var zoom = this.zoom;\n    var autoRound = this.autoRound;\n    var resolution = 1;\n\n    if (this.scaleMode === CONST.SCALE_MODE.NONE) {\n      //  No scale\n      this.displaySize.setSize(width * zoom * resolution, height * zoom * resolution);\n      styleWidth = this.displaySize.width / resolution;\n      styleHeight = this.displaySize.height / resolution;\n\n      if (autoRound) {\n        styleWidth = Math.floor(styleWidth);\n        styleHeight = Math.floor(styleHeight);\n      }\n\n      if (zoom > 1) {\n        style.width = styleWidth + 'px';\n        style.height = styleHeight + 'px';\n      }\n    } else if (this.scaleMode === CONST.SCALE_MODE.RESIZE) {\n      //  Resize to match parent\n      //  This will constrain using min/max\n      this.displaySize.setSize(this.parentSize.width, this.parentSize.height);\n      this.gameSize.setSize(this.displaySize.width, this.displaySize.height);\n      this.baseSize.setSize(this.displaySize.width * resolution, this.displaySize.height * resolution);\n      styleWidth = this.displaySize.width / resolution;\n      styleHeight = this.displaySize.height / resolution;\n\n      if (autoRound) {\n        styleWidth = Math.floor(styleWidth);\n        styleHeight = Math.floor(styleHeight);\n      }\n\n      this.canvas.width = styleWidth;\n      this.canvas.height = styleHeight;\n    } else {\n      //  All other scale modes\n      this.displaySize.setSize(this.parentSize.width, this.parentSize.height);\n      styleWidth = this.displaySize.width / resolution;\n      styleHeight = this.displaySize.height / resolution;\n\n      if (autoRound) {\n        styleWidth = Math.floor(styleWidth);\n        styleHeight = Math.floor(styleHeight);\n      }\n\n      style.width = styleWidth + 'px';\n      style.height = styleHeight + 'px';\n    } //  Update the parentSize incase the canvas / style change modified it\n\n\n    this.getParentBounds(); //  Finally, update the centering\n\n    this.updateCenter();\n  },\n\n  /**\r\n   * Calculates and returns the largest possible zoom factor, based on the current\r\n   * parent and game sizes. If the parent has no dimensions (i.e. an unstyled div),\r\n   * or is smaller than the un-zoomed game, then this will return a value of 1 (no zoom)\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#getMaxZoom\r\n   * @since 3.16.0\r\n   * \r\n   * @return {integer} The maximum possible zoom factor. At a minimum this value is always at least 1.\r\n   */\n  getMaxZoom: function getMaxZoom() {\n    var zoomH = SnapFloor(this.parentSize.width, this.gameSize.width, 0, true);\n    var zoomV = SnapFloor(this.parentSize.height, this.gameSize.height, 0, true);\n    return Math.max(Math.min(zoomH, zoomV), 1);\n  },\n\n  /**\r\n   * Calculates and updates the canvas CSS style in order to center it within the\r\n   * bounds of its parent. If you have explicitly set parent to be `null` in your\r\n   * game config then this method will likely give incorrect results unless you have called the\r\n   * `setParentSize` method first.\r\n   * \r\n   * It works by modifying the canvas CSS `marginLeft` and `marginTop` properties.\r\n   * \r\n   * If they have already been set by your own style sheet, or code, this will overwrite them.\r\n   * \r\n   * To prevent the Scale Manager from centering the canvas, either do not set the\r\n   * `autoCenter` property in your game config, or make sure it is set to `NO_CENTER`.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#updateCenter\r\n   * @since 3.16.0\r\n   */\n  updateCenter: function updateCenter() {\n    var autoCenter = this.autoCenter;\n\n    if (autoCenter === CONST.CENTER.NO_CENTER) {\n      return;\n    }\n\n    var canvas = this.canvas;\n    var style = canvas.style;\n    var bounds = canvas.getBoundingClientRect(); // var width = parseInt(canvas.style.width, 10) || canvas.width;\n    // var height = parseInt(canvas.style.height, 10) || canvas.height;\n\n    var width = bounds.width;\n    var height = bounds.height;\n    var offsetX = Math.floor((this.parentSize.width - width) / 2);\n    var offsetY = Math.floor((this.parentSize.height - height) / 2);\n\n    if (autoCenter === CONST.CENTER.CENTER_HORIZONTALLY) {\n      offsetY = 0;\n    } else if (autoCenter === CONST.CENTER.CENTER_VERTICALLY) {\n      offsetX = 0;\n    }\n\n    style.marginLeft = offsetX + 'px';\n    style.marginTop = offsetY + 'px';\n  },\n\n  /**\r\n   * Updates the `canvasBounds` rectangle to match the bounding client rectangle of the\r\n   * canvas element being used to track input events.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#updateBounds\r\n   * @since 3.16.0\r\n   */\n  updateBounds: function updateBounds() {\n    var bounds = this.canvasBounds;\n    var clientRect = this.canvas.getBoundingClientRect();\n    bounds.x = clientRect.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0);\n    bounds.y = clientRect.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0);\n    bounds.width = clientRect.width;\n    bounds.height = clientRect.height;\n  },\n\n  /**\r\n   * Transforms the pageX value into the scaled coordinate space of the Scale Manager.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#transformX\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} pageX - The DOM pageX value.\r\n   *\r\n   * @return {number} The translated value.\r\n   */\n  transformX: function transformX(pageX) {\n    return (pageX - this.canvasBounds.left) * this.displayScale.x;\n  },\n\n  /**\r\n   * Transforms the pageY value into the scaled coordinate space of the Scale Manager.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#transformY\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} pageY - The DOM pageY value.\r\n   *\r\n   * @return {number} The translated value.\r\n   */\n  transformY: function transformY(pageY) {\n    return (pageY - this.canvasBounds.top) * this.displayScale.y;\n  },\n\n  /**\r\n   * Sends a request to the browser to ask it to go in to full screen mode, using the {@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API Fullscreen API}.\r\n   * \r\n   * If the browser does not support this, a `FULLSCREEN_UNSUPPORTED` event will be emitted.\r\n   * \r\n   * This method _must_ be called from a user-input gesture, such as `pointerdown`. You cannot launch\r\n   * games fullscreen without this, as most browsers block it. Games within an iframe will also be blocked\r\n   * from fullscreen unless the iframe has the `allowfullscreen` attribute.\r\n   * \r\n   * Performing an action that navigates to another page, or opens another tab, will automatically cancel\r\n   * fullscreen mode, as will the user pressing the ESC key. To cancel fullscreen mode from your game, i.e.\r\n   * from clicking an icon, call the `stopFullscreen` method.\r\n   * \r\n   * A browser can only send one DOM element into fullscreen. You can control which element this is by\r\n   * setting the `fullscreenTarget` property in your game config, or changing the property in the Scale Manager.\r\n   * Note that the game canvas _must_ be a child of the target. If you do not give a target, Phaser will\r\n   * automatically create a blank `<div>` element and move the canvas into it, before going fullscreen.\r\n   * When it leaves fullscreen, the div will be removed.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#startFullscreen\r\n   * @fires Phaser.Scale.Events#ENTER_FULLSCREEN\r\n   * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @param {object} [fullscreenOptions] - The FullscreenOptions dictionary is used to provide configuration options when entering full screen.\r\n   */\n  startFullscreen: function startFullscreen(fullscreenOptions) {\n    if (fullscreenOptions === undefined) {\n      fullscreenOptions = {\n        navigationUI: 'hide'\n      };\n    }\n\n    var fullscreen = this.fullscreen;\n\n    if (!fullscreen.available) {\n      this.emit(Events.FULLSCREEN_UNSUPPORTED);\n      return;\n    }\n\n    if (!fullscreen.active) {\n      var fsTarget = this.getFullscreenTarget();\n      this._requestedFullscreenChange = true;\n\n      if (fullscreen.keyboard) {\n        fsTarget[fullscreen.request](Element.ALLOW_KEYBOARD_INPUT);\n      } else {\n        fsTarget[fullscreen.request](fullscreenOptions);\n      }\n\n      this.getParentBounds();\n      this.refresh();\n      this.emit(Events.ENTER_FULLSCREEN);\n    }\n  },\n\n  /**\r\n   * An internal method that gets the target element that is used when entering fullscreen mode.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#getFullscreenTarget\r\n   * @since 3.16.0\r\n   * \r\n   * @return {object} The fullscreen target element.\r\n   */\n  getFullscreenTarget: function getFullscreenTarget() {\n    if (!this.fullscreenTarget) {\n      var fsTarget = document.createElement('div');\n      fsTarget.style.margin = '0';\n      fsTarget.style.padding = '0';\n      fsTarget.style.width = '100%';\n      fsTarget.style.height = '100%';\n      this.fullscreenTarget = fsTarget;\n      this._createdFullscreenTarget = true;\n    }\n\n    if (this._createdFullscreenTarget) {\n      var canvasParent = this.canvas.parentNode;\n      canvasParent.insertBefore(this.fullscreenTarget, this.canvas);\n      this.fullscreenTarget.appendChild(this.canvas);\n    }\n\n    return this.fullscreenTarget;\n  },\n\n  /**\r\n   * Calling this method will cancel fullscreen mode, if the browser has entered it.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#stopFullscreen\r\n   * @fires Phaser.Scale.Events#LEAVE_FULLSCREEN\r\n   * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n   * @since 3.16.0\r\n   */\n  stopFullscreen: function stopFullscreen() {\n    var fullscreen = this.fullscreen;\n\n    if (!fullscreen.available) {\n      this.emit(Events.FULLSCREEN_UNSUPPORTED);\n      return false;\n    }\n\n    if (fullscreen.active) {\n      this._requestedFullscreenChange = true;\n      document[fullscreen.cancel]();\n    }\n\n    if (this._createdFullscreenTarget) {\n      var fsTarget = this.fullscreenTarget;\n\n      if (fsTarget && fsTarget.parentNode) {\n        var parent = fsTarget.parentNode;\n        parent.insertBefore(this.canvas, fsTarget);\n        parent.removeChild(fsTarget);\n      }\n    }\n\n    this.emit(Events.LEAVE_FULLSCREEN);\n    this.refresh();\n  },\n\n  /**\r\n   * Toggles the fullscreen mode. If already in fullscreen, calling this will cancel it.\r\n   * If not in fullscreen, this will request the browser to enter fullscreen mode.\r\n   * \r\n   * If the browser does not support this, a `FULLSCREEN_UNSUPPORTED` event will be emitted.\r\n   * \r\n   * This method _must_ be called from a user-input gesture, such as `pointerdown`. You cannot launch\r\n   * games fullscreen without this, as most browsers block it. Games within an iframe will also be blocked\r\n   * from fullscreen unless the iframe has the `allowfullscreen` attribute.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#toggleFullscreen\r\n   * @fires Phaser.Scale.Events#ENTER_FULLSCREEN\r\n   * @fires Phaser.Scale.Events#LEAVE_FULLSCREEN\r\n   * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @param {object} [fullscreenOptions] - The FullscreenOptions dictionary is used to provide configuration options when entering full screen.\r\n   */\n  toggleFullscreen: function toggleFullscreen(fullscreenOptions) {\n    if (this.fullscreen.active) {\n      this.stopFullscreen();\n    } else {\n      this.startFullscreen(fullscreenOptions);\n    }\n  },\n\n  /**\r\n   * An internal method that starts the different DOM event listeners running.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#startListeners\r\n   * @since 3.16.0\r\n   */\n  startListeners: function startListeners() {\n    var _this = this;\n\n    var listeners = this.listeners;\n\n    listeners.orientationChange = function () {\n      _this._checkOrientation = true;\n      _this.dirty = true;\n    };\n\n    listeners.windowResize = function () {\n      _this.dirty = true;\n    }; //  Only dispatched on mobile devices\n\n\n    window.addEventListener('orientationchange', listeners.orientationChange, false);\n    window.addEventListener('resize', listeners.windowResize, false);\n\n    if (this.fullscreen.available) {\n      listeners.fullScreenChange = function (event) {\n        return _this.onFullScreenChange(event);\n      };\n\n      listeners.fullScreenError = function (event) {\n        return _this.onFullScreenError(event);\n      };\n\n      var vendors = ['webkit', 'moz', ''];\n      vendors.forEach(function (prefix) {\n        document.addEventListener(prefix + 'fullscreenchange', listeners.fullScreenChange, false);\n        document.addEventListener(prefix + 'fullscreenerror', listeners.fullScreenError, false);\n      }); //  MS Specific\n\n      document.addEventListener('MSFullscreenChange', listeners.fullScreenChange, false);\n      document.addEventListener('MSFullscreenError', listeners.fullScreenError, false);\n    }\n  },\n\n  /**\r\n   * Triggered when a fullscreenchange event is dispatched by the DOM.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#onFullScreenChange\r\n   * @since 3.16.0\r\n   */\n  onFullScreenChange: function onFullScreenChange() {\n    //  They pressed ESC while in fullscreen mode\n    if (!this._requestedFullscreenChange) {\n      this.stopFullscreen();\n    }\n\n    this._requestedFullscreenChange = false;\n  },\n\n  /**\r\n   * Triggered when a fullscreenerror event is dispatched by the DOM.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#onFullScreenError\r\n   * @since 3.16.0\r\n   */\n  onFullScreenError: function onFullScreenError() {},\n\n  /**\r\n   * Internal method, called automatically by the game step.\r\n   * Monitors the elapsed time and resize interval to see if a parent bounds check needs to take place.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#step\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} time - The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().\r\n   * @param {number} delta - The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.\r\n   */\n  step: function step(time, delta) {\n    if (!this.parent) {\n      return;\n    }\n\n    this._lastCheck += delta;\n\n    if (this.dirty || this._lastCheck > this.resizeInterval) {\n      //  Returns true if the parent bounds have changed size\n      if (this.getParentBounds()) {\n        this.refresh();\n      }\n\n      this.dirty = false;\n      this._lastCheck = 0;\n    }\n  },\n\n  /**\r\n   * Stops all DOM event listeners.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#stopListeners\r\n   * @since 3.16.0\r\n   */\n  stopListeners: function stopListeners() {\n    var listeners = this.listeners;\n    window.removeEventListener('orientationchange', listeners.orientationChange, false);\n    window.removeEventListener('resize', listeners.windowResize, false);\n    var vendors = ['webkit', 'moz', ''];\n    vendors.forEach(function (prefix) {\n      document.removeEventListener(prefix + 'fullscreenchange', listeners.fullScreenChange, false);\n      document.removeEventListener(prefix + 'fullscreenerror', listeners.fullScreenError, false);\n    }); //  MS Specific\n\n    document.removeEventListener('MSFullscreenChange', listeners.fullScreenChange, false);\n    document.removeEventListener('MSFullscreenError', listeners.fullScreenError, false);\n  },\n\n  /**\r\n   * Destroys this Scale Manager, releasing all references to external resources.\r\n   * Once destroyed, the Scale Manager cannot be used again.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#destroy\r\n   * @since 3.16.0\r\n   */\n  destroy: function destroy() {\n    this.removeAllListeners();\n    this.stopListeners();\n    this.game = null;\n    this.canvas = null;\n    this.canvasBounds = null;\n    this.parent = null;\n    this.parentSize.destroy();\n    this.gameSize.destroy();\n    this.baseSize.destroy();\n    this.displaySize.destroy();\n    this.fullscreenTarget = null;\n  },\n\n  /**\r\n   * Is the browser currently in fullscreen mode or not?\r\n   *\r\n   * @name Phaser.Scale.ScaleManager#isFullscreen\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  isFullscreen: {\n    get: function get() {\n      return this.fullscreen.active;\n    }\n  },\n\n  /**\r\n   * The game width.\r\n   * \r\n   * This is typically the size given in the game configuration.\r\n   *\r\n   * @name Phaser.Scale.ScaleManager#width\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  width: {\n    get: function get() {\n      return this.gameSize.width;\n    }\n  },\n\n  /**\r\n   * The game height.\r\n   * \r\n   * This is typically the size given in the game configuration.\r\n   *\r\n   * @name Phaser.Scale.ScaleManager#height\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  height: {\n    get: function get() {\n      return this.gameSize.height;\n    }\n  },\n\n  /**\r\n   * Is the device in a portrait orientation as reported by the Orientation API?\r\n   * This value is usually only available on mobile devices.\r\n   *\r\n   * @name Phaser.Scale.ScaleManager#isPortrait\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  isPortrait: {\n    get: function get() {\n      return this.orientation === CONST.ORIENTATION.PORTRAIT;\n    }\n  },\n\n  /**\r\n   * Is the device in a landscape orientation as reported by the Orientation API?\r\n   * This value is usually only available on mobile devices.\r\n   *\r\n   * @name Phaser.Scale.ScaleManager#isLandscape\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  isLandscape: {\n    get: function get() {\n      return this.orientation === CONST.ORIENTATION.LANDSCAPE;\n    }\n  },\n\n  /**\r\n   * Are the game dimensions portrait? (i.e. taller than they are wide)\r\n   * \r\n   * This is different to the device itself being in a portrait orientation.\r\n   *\r\n   * @name Phaser.Scale.ScaleManager#isGamePortrait\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  isGamePortrait: {\n    get: function get() {\n      return this.height > this.width;\n    }\n  },\n\n  /**\r\n   * Are the game dimensions landscape? (i.e. wider than they are tall)\r\n   * \r\n   * This is different to the device itself being in a landscape orientation.\r\n   *\r\n   * @name Phaser.Scale.ScaleManager#isGameLandscape\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  isGameLandscape: {\n    get: function get() {\n      return this.width > this.height;\n    }\n  }\n});\nmodule.exports = ScaleManager;","map":null,"metadata":{},"sourceType":"script"}