{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar ArrayUtils = require('../../utils/array');\n\nvar BlendModes = require('../../renderer/BlendModes');\n\nvar Class = require('../../utils/Class');\n\nvar Components = require('../components');\n\nvar Events = require('../events');\n\nvar GameObject = require('../GameObject');\n\nvar Rectangle = require('../../geom/rectangle/Rectangle');\n\nvar Render = require('./ContainerRender');\n\nvar Union = require('../../geom/rectangle/Union');\n\nvar Vector2 = require('../../math/Vector2');\n/**\r\n * @classdesc\r\n * A Container Game Object.\r\n *\r\n * A Container, as the name implies, can 'contain' other types of Game Object.\r\n * When a Game Object is added to a Container, the Container becomes responsible for the rendering of it.\r\n * By default it will be removed from the Display List and instead added to the Containers own internal list.\r\n *\r\n * The position of the Game Object automatically becomes relative to the position of the Container.\r\n *\r\n * When the Container is rendered, all of its children are rendered as well, in the order in which they exist\r\n * within the Container. Container children can be repositioned using methods such as `MoveUp`, `MoveDown` and `SendToBack`.\r\n *\r\n * If you modify a transform property of the Container, such as `Container.x` or `Container.rotation` then it will\r\n * automatically influence all children as well.\r\n *\r\n * Containers can include other Containers for deeply nested transforms.\r\n *\r\n * Containers can have masks set on them and can be used as a mask too. However, Container children cannot be masked.\r\n * The masks do not 'stack up'. Only a Container on the root of the display list will use its mask.\r\n *\r\n * Containers can be enabled for input. Because they do not have a texture you need to provide a shape for them\r\n * to use as their hit area. Container children can also be enabled for input, independent of the Container.\r\n *\r\n * Containers can be given a physics body for either Arcade Physics, Impact Physics or Matter Physics. However,\r\n * if Container _children_ are enabled for physics you may get unexpected results, such as offset bodies,\r\n * if the Container itself, or any of its ancestors, is positioned anywhere other than at 0 x 0. Container children\r\n * with physics do not factor in the Container due to the excessive extra calculations needed. Please structure\r\n * your game to work around this.\r\n *\r\n * It's important to understand the impact of using Containers. They add additional processing overhead into\r\n * every one of their children. The deeper you nest them, the more the cost escalates. This is especially true\r\n * for input events. You also loose the ability to set the display depth of Container children in the same\r\n * flexible manner as those not within them. In short, don't use them for the sake of it. You pay a small cost\r\n * every time you create one, try to structure your game around avoiding that where possible.\r\n *\r\n * @class Container\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.4.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {Phaser.GameObjects.GameObject[]} [children] - An optional array of Game Objects to add to this Container.\r\n */\n\n\nvar Container = new Class({\n  Extends: GameObject,\n  Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Depth, Components.Mask, Components.ScrollFactor, Components.Transform, Components.Visible, Render],\n  initialize: function Container(scene, x, y, children) {\n    GameObject.call(this, scene, 'Container');\n    /**\r\n     * An array holding the children of this Container.\r\n     *\r\n     * @name Phaser.GameObjects.Container#list\r\n     * @type {Phaser.GameObjects.GameObject[]}\r\n     * @since 3.4.0\r\n     */\n\n    this.list = [];\n    /**\r\n     * Does this Container exclusively manage its children?\r\n     *\r\n     * The default is `true` which means a child added to this Container cannot\r\n     * belong in another Container, which includes the Scene display list.\r\n     *\r\n     * If you disable this then this Container will no longer exclusively manage its children.\r\n     * This allows you to create all kinds of interesting graphical effects, such as replicating\r\n     * Game Objects without reparenting them all over the Scene.\r\n     * However, doing so will prevent children from receiving any kind of input event or have\r\n     * their physics bodies work by default, as they're no longer a single entity on the\r\n     * display list, but are being replicated where-ever this Container is.\r\n     *\r\n     * @name Phaser.GameObjects.Container#exclusive\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.4.0\r\n     */\n\n    this.exclusive = true;\n    /**\r\n     * Containers can have an optional maximum size. If set to anything above 0 it\r\n     * will constrict the addition of new Game Objects into the Container, capping off\r\n     * the maximum limit the Container can grow in size to.\r\n     *\r\n     * @name Phaser.GameObjects.Container#maxSize\r\n     * @type {integer}\r\n     * @default -1\r\n     * @since 3.4.0\r\n     */\n\n    this.maxSize = -1;\n    /**\r\n     * The cursor position.\r\n     *\r\n     * @name Phaser.GameObjects.Container#position\r\n     * @type {integer}\r\n     * @since 3.4.0\r\n     */\n\n    this.position = 0;\n    /**\r\n     * Internal Transform Matrix used for local space conversion.\r\n     *\r\n     * @name Phaser.GameObjects.Container#localTransform\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.4.0\r\n     */\n\n    this.localTransform = new Components.TransformMatrix();\n    /**\r\n     * Internal temporary Transform Matrix used to avoid object creation.\r\n     *\r\n     * @name Phaser.GameObjects.Container#tempTransformMatrix\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @private\r\n     * @since 3.4.0\r\n     */\n\n    this.tempTransformMatrix = new Components.TransformMatrix();\n    /**\r\n     * A reference to the Scene Display List.\r\n     *\r\n     * @name Phaser.GameObjects.Container#_displayList\r\n     * @type {Phaser.GameObjects.DisplayList}\r\n     * @private\r\n     * @since 3.4.0\r\n     */\n\n    this._displayList = scene.sys.displayList;\n    /**\r\n     * The property key to sort by.\r\n     *\r\n     * @name Phaser.GameObjects.Container#_sortKey\r\n     * @type {string}\r\n     * @private\r\n     * @since 3.4.0\r\n     */\n\n    this._sortKey = '';\n    /**\r\n     * A reference to the Scene Systems Event Emitter.\r\n     *\r\n     * @name Phaser.GameObjects.Container#_sysEvents\r\n     * @type {Phaser.Events.EventEmitter}\r\n     * @private\r\n     * @since 3.9.0\r\n     */\n\n    this._sysEvents = scene.sys.events;\n    this.setPosition(x, y);\n    this.clearAlpha();\n    this.setBlendMode(BlendModes.SKIP_CHECK);\n\n    if (children) {\n      this.add(children);\n    }\n  },\n\n  /**\r\n   * Internal value to allow Containers to be used for input and physics.\r\n   * Do not change this value. It has no effect other than to break things.\r\n   *\r\n   * @name Phaser.GameObjects.Container#originX\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.4.0\r\n   */\n  originX: {\n    get: function get() {\n      return 0.5;\n    }\n  },\n\n  /**\r\n   * Internal value to allow Containers to be used for input and physics.\r\n   * Do not change this value. It has no effect other than to break things.\r\n   *\r\n   * @name Phaser.GameObjects.Container#originY\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.4.0\r\n   */\n  originY: {\n    get: function get() {\n      return 0.5;\n    }\n  },\n\n  /**\r\n   * Internal value to allow Containers to be used for input and physics.\r\n   * Do not change this value. It has no effect other than to break things.\r\n   *\r\n   * @name Phaser.GameObjects.Container#displayOriginX\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.4.0\r\n   */\n  displayOriginX: {\n    get: function get() {\n      return this.width * 0.5;\n    }\n  },\n\n  /**\r\n   * Internal value to allow Containers to be used for input and physics.\r\n   * Do not change this value. It has no effect other than to break things.\r\n   *\r\n   * @name Phaser.GameObjects.Container#displayOriginY\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.4.0\r\n   */\n  displayOriginY: {\n    get: function get() {\n      return this.height * 0.5;\n    }\n  },\n\n  /**\r\n   * Does this Container exclusively manage its children?\r\n   *\r\n   * The default is `true` which means a child added to this Container cannot\r\n   * belong in another Container, which includes the Scene display list.\r\n   *\r\n   * If you disable this then this Container will no longer exclusively manage its children.\r\n   * This allows you to create all kinds of interesting graphical effects, such as replicating\r\n   * Game Objects without reparenting them all over the Scene.\r\n   * However, doing so will prevent children from receiving any kind of input event or have\r\n   * their physics bodies work by default, as they're no longer a single entity on the\r\n   * display list, but are being replicated where-ever this Container is.\r\n   *\r\n   * @method Phaser.GameObjects.Container#setExclusive\r\n   * @since 3.4.0\r\n   *\r\n   * @param {boolean} [value=true] - The exclusive state of this Container.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container.\r\n   */\n  setExclusive: function setExclusive(value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.exclusive = value;\n    return this;\n  },\n\n  /**\r\n   * Gets the bounds of this Container. It works by iterating all children of the Container,\r\n   * getting their respective bounds, and then working out a min-max rectangle from that.\r\n   * It does not factor in if the children render or not, all are included.\r\n   *\r\n   * Some children are unable to return their bounds, such as Graphics objects, in which case\r\n   * they are skipped.\r\n   *\r\n   * Depending on the quantity of children in this Container it could be a really expensive call,\r\n   * so cache it and only poll it as needed.\r\n   *\r\n   * The values are stored and returned in a Rectangle object.\r\n   *\r\n   * @method Phaser.GameObjects.Container#getBounds\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.Geom.Rectangle} [output] - A Geom.Rectangle object to store the values in. If not provided a new Rectangle will be created.\r\n   *\r\n   * @return {Phaser.Geom.Rectangle} The values stored in the output object.\r\n   */\n  getBounds: function getBounds(output) {\n    if (output === undefined) {\n      output = new Rectangle();\n    }\n\n    output.setTo(this.x, this.y, 0, 0);\n\n    if (this.list.length > 0) {\n      var children = this.list;\n      var tempRect = new Rectangle();\n\n      for (var i = 0; i < children.length; i++) {\n        var entry = children[i];\n\n        if (entry.getBounds) {\n          entry.getBounds(tempRect);\n          Union(tempRect, output, output);\n        }\n      }\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Internal add handler.\r\n   *\r\n   * @method Phaser.GameObjects.Container#addHandler\r\n   * @private\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was just added to this Container.\r\n   */\n  addHandler: function addHandler(gameObject) {\n    gameObject.once(Events.DESTROY, this.remove, this);\n\n    if (this.exclusive) {\n      this._displayList.remove(gameObject);\n\n      if (gameObject.parentContainer) {\n        gameObject.parentContainer.remove(gameObject);\n      }\n\n      gameObject.parentContainer = this;\n    }\n  },\n\n  /**\r\n   * Internal remove handler.\r\n   *\r\n   * @method Phaser.GameObjects.Container#removeHandler\r\n   * @private\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was just removed from this Container.\r\n   */\n  removeHandler: function removeHandler(gameObject) {\n    gameObject.off(Events.DESTROY, this.remove);\n\n    if (this.exclusive) {\n      gameObject.parentContainer = null;\n    }\n  },\n\n  /**\r\n   * Takes a Point-like object, such as a Vector2, Geom.Point or object with public x and y properties,\r\n   * and transforms it into the space of this Container, then returns it in the output object.\r\n   *\r\n   * @method Phaser.GameObjects.Container#pointToContainer\r\n   * @since 3.4.0\r\n   *\r\n   * @param {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} source - The Source Point to be transformed.\r\n   * @param {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} [output] - A destination object to store the transformed point in. If none given a Vector2 will be created and returned.\r\n   *\r\n   * @return {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} The transformed point.\r\n   */\n  pointToContainer: function pointToContainer(source, output) {\n    if (output === undefined) {\n      output = new Vector2();\n    }\n\n    if (this.parentContainer) {\n      return this.parentContainer.pointToContainer(source, output);\n    }\n\n    var tempMatrix = this.tempTransformMatrix; //  No need to loadIdentity because applyITRS overwrites every value anyway\n\n    tempMatrix.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY);\n    tempMatrix.invert();\n    tempMatrix.transformPoint(source.x, source.y, output);\n    return output;\n  },\n\n  /**\r\n   * Returns the world transform matrix as used for Bounds checks.\r\n   * \r\n   * The returned matrix is temporal and shouldn't be stored.\r\n   *\r\n   * @method Phaser.GameObjects.Container#getBoundsTransformMatrix\r\n   * @since 3.4.0\r\n   *\r\n   * @return {Phaser.GameObjects.Components.TransformMatrix} The world transform matrix.\r\n   */\n  getBoundsTransformMatrix: function getBoundsTransformMatrix() {\n    return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform);\n  },\n\n  /**\r\n   * Adds the given Game Object, or array of Game Objects, to this Container.\r\n   *\r\n   * Each Game Object must be unique within the Container.\r\n   *\r\n   * @method Phaser.GameObjects.Container#add\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to add to the Container.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  add: function add(child) {\n    ArrayUtils.Add(this.list, child, this.maxSize, this.addHandler, this);\n    return this;\n  },\n\n  /**\r\n   * Adds the given Game Object, or array of Game Objects, to this Container at the specified position.\r\n   *\r\n   * Existing Game Objects in the Container are shifted up.\r\n   *\r\n   * Each Game Object must be unique within the Container.\r\n   *\r\n   * @method Phaser.GameObjects.Container#addAt\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to add to the Container.\r\n   * @param {integer} [index=0] - The position to insert the Game Object/s at.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  addAt: function addAt(child, index) {\n    ArrayUtils.AddAt(this.list, child, index, this.maxSize, this.addHandler, this);\n    return this;\n  },\n\n  /**\r\n   * Returns the Game Object at the given position in this Container.\r\n   *\r\n   * @method Phaser.GameObjects.Container#getAt\r\n   * @since 3.4.0\r\n   *\r\n   * @param {integer} index - The position to get the Game Object from.\r\n   *\r\n   * @return {?Phaser.GameObjects.GameObject} The Game Object at the specified index, or `null` if none found.\r\n   */\n  getAt: function getAt(index) {\n    return this.list[index];\n  },\n\n  /**\r\n   * Returns the index of the given Game Object in this Container.\r\n   *\r\n   * @method Phaser.GameObjects.Container#getIndex\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} child - The Game Object to search for in this Container.\r\n   *\r\n   * @return {integer} The index of the Game Object in this Container, or -1 if not found.\r\n   */\n  getIndex: function getIndex(child) {\n    return this.list.indexOf(child);\n  },\n\n  /**\r\n   * Sort the contents of this Container so the items are in order based on the given property.\r\n   * For example: `sort('alpha')` would sort the elements based on the value of their `alpha` property.\r\n   *\r\n   * @method Phaser.GameObjects.Container#sort\r\n   * @since 3.4.0\r\n   *\r\n   * @param {string} property - The property to lexically sort by.\r\n   * @param {function} [handler] - Provide your own custom handler function. Will receive 2 children which it should compare and return a boolean.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  sort: function sort(property, handler) {\n    if (!property) {\n      return this;\n    }\n\n    if (handler === undefined) {\n      handler = function handler(childA, childB) {\n        return childA[property] - childB[property];\n      };\n    }\n\n    ArrayUtils.StableSort.inplace(this.list, handler);\n    return this;\n  },\n\n  /**\r\n   * Searches for the first instance of a child with its `name` property matching the given argument.\r\n   * Should more than one child have the same name only the first is returned.\r\n   *\r\n   * @method Phaser.GameObjects.Container#getByName\r\n   * @since 3.4.0\r\n   *\r\n   * @param {string} name - The name to search for.\r\n   *\r\n   * @return {?Phaser.GameObjects.GameObject} The first child with a matching name, or `null` if none were found.\r\n   */\n  getByName: function getByName(name) {\n    return ArrayUtils.GetFirst(this.list, 'name', name);\n  },\n\n  /**\r\n   * Returns a random Game Object from this Container.\r\n   *\r\n   * @method Phaser.GameObjects.Container#getRandom\r\n   * @since 3.4.0\r\n   *\r\n   * @param {integer} [startIndex=0] - An optional start index.\r\n   * @param {integer} [length] - An optional length, the total number of elements (from the startIndex) to choose from.\r\n   *\r\n   * @return {?Phaser.GameObjects.GameObject} A random child from the Container, or `null` if the Container is empty.\r\n   */\n  getRandom: function getRandom(startIndex, length) {\n    return ArrayUtils.GetRandom(this.list, startIndex, length);\n  },\n\n  /**\r\n   * Gets the first Game Object in this Container.\r\n   *\r\n   * You can also specify a property and value to search for, in which case it will return the first\r\n   * Game Object in this Container with a matching property and / or value.\r\n   *\r\n   * For example: `getFirst('visible', true)` would return the first Game Object that had its `visible` property set.\r\n   *\r\n   * You can limit the search to the `startIndex` - `endIndex` range.\r\n   *\r\n   * @method Phaser.GameObjects.Container#getFirst\r\n   * @since 3.4.0\r\n   *\r\n   * @param {string} property - The property to test on each Game Object in the Container.\r\n   * @param {*} value - The value to test the property against. Must pass a strict (`===`) comparison check.\r\n   * @param {integer} [startIndex=0] - An optional start index to search from.\r\n   * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n   *\r\n   * @return {?Phaser.GameObjects.GameObject} The first matching Game Object, or `null` if none was found.\r\n   */\n  getFirst: function getFirst(property, value, startIndex, endIndex) {\n    return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);\n  },\n\n  /**\r\n   * Returns all Game Objects in this Container.\r\n   *\r\n   * You can optionally specify a matching criteria using the `property` and `value` arguments.\r\n   *\r\n   * For example: `getAll('body')` would return only Game Objects that have a body property.\r\n   *\r\n   * You can also specify a value to compare the property to:\r\n   *\r\n   * `getAll('visible', true)` would return only Game Objects that have their visible property set to `true`.\r\n   *\r\n   * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,\r\n   * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n   * the first 50 Game Objects.\r\n   *\r\n   * @method Phaser.GameObjects.Container#getAll\r\n   * @since 3.4.0\r\n   *\r\n   * @param {string} [property] - The property to test on each Game Object in the Container.\r\n   * @param {any} [value] - If property is set then the `property` must strictly equal this value to be included in the results.\r\n   * @param {integer} [startIndex=0] - An optional start index to search from.\r\n   * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject[]} An array of matching Game Objects from this Container.\r\n   */\n  getAll: function getAll(property, value, startIndex, endIndex) {\n    return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);\n  },\n\n  /**\r\n   * Returns the total number of Game Objects in this Container that have a property\r\n   * matching the given value.\r\n   *\r\n   * For example: `count('visible', true)` would count all the elements that have their visible property set.\r\n   *\r\n   * You can optionally limit the operation to the `startIndex` - `endIndex` range.\r\n   *\r\n   * @method Phaser.GameObjects.Container#count\r\n   * @since 3.4.0\r\n   *\r\n   * @param {string} property - The property to check.\r\n   * @param {any} value - The value to check.\r\n   * @param {integer} [startIndex=0] - An optional start index to search from.\r\n   * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n   *\r\n   * @return {integer} The total number of Game Objects in this Container with a property matching the given value.\r\n   */\n  count: function count(property, value, startIndex, endIndex) {\n    return ArrayUtils.CountAllMatching(this.list, property, value, startIndex, endIndex);\n  },\n\n  /**\r\n   * Swaps the position of two Game Objects in this Container.\r\n   * Both Game Objects must belong to this Container.\r\n   *\r\n   * @method Phaser.GameObjects.Container#swap\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} child1 - The first Game Object to swap.\r\n   * @param {Phaser.GameObjects.GameObject} child2 - The second Game Object to swap.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  swap: function swap(child1, child2) {\n    ArrayUtils.Swap(this.list, child1, child2);\n    return this;\n  },\n\n  /**\r\n   * Moves a Game Object to a new position within this Container.\r\n   *\r\n   * The Game Object must already be a child of this Container.\r\n   *\r\n   * The Game Object is removed from its old position and inserted into the new one.\r\n   * Therefore the Container size does not change. Other children will change position accordingly.\r\n   *\r\n   * @method Phaser.GameObjects.Container#moveTo\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} child - The Game Object to move.\r\n   * @param {integer} index - The new position of the Game Object in this Container.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  moveTo: function moveTo(child, index) {\n    ArrayUtils.MoveTo(this.list, child, index);\n    return this;\n  },\n\n  /**\r\n   * Removes the given Game Object, or array of Game Objects, from this Container.\r\n   *\r\n   * The Game Objects must already be children of this Container.\r\n   *\r\n   * You can also optionally call `destroy` on each Game Object that is removed from the Container.\r\n   *\r\n   * @method Phaser.GameObjects.Container#remove\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to be removed from the Container.\r\n   * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each child successfully removed from this Container.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  remove: function remove(child, destroyChild) {\n    var removed = ArrayUtils.Remove(this.list, child, this.removeHandler, this);\n\n    if (destroyChild && removed) {\n      if (!Array.isArray(removed)) {\n        removed = [removed];\n      }\n\n      for (var i = 0; i < removed.length; i++) {\n        removed[i].destroy();\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes the Game Object at the given position in this Container.\r\n   *\r\n   * You can also optionally call `destroy` on the Game Object, if one is found.\r\n   *\r\n   * @method Phaser.GameObjects.Container#removeAt\r\n   * @since 3.4.0\r\n   *\r\n   * @param {integer} index - The index of the Game Object to be removed.\r\n   * @param {boolean} [destroyChild=false] - Optionally call `destroy` on the Game Object if successfully removed from this Container.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  removeAt: function removeAt(index, destroyChild) {\n    var removed = ArrayUtils.RemoveAt(this.list, index, this.removeHandler, this);\n\n    if (destroyChild && removed) {\n      removed.destroy();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes the Game Objects between the given positions in this Container.\r\n   *\r\n   * You can also optionally call `destroy` on each Game Object that is removed from the Container.\r\n   *\r\n   * @method Phaser.GameObjects.Container#removeBetween\r\n   * @since 3.4.0\r\n   *\r\n   * @param {integer} [startIndex=0] - An optional start index to search from.\r\n   * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n   * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each Game Object successfully removed from this Container.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  removeBetween: function removeBetween(startIndex, endIndex, destroyChild) {\n    var removed = ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeHandler, this);\n\n    if (destroyChild) {\n      for (var i = 0; i < removed.length; i++) {\n        removed[i].destroy();\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes all Game Objects from this Container.\r\n   *\r\n   * You can also optionally call `destroy` on each Game Object that is removed from the Container.\r\n   *\r\n   * @method Phaser.GameObjects.Container#removeAll\r\n   * @since 3.4.0\r\n   *\r\n   * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each Game Object successfully removed from this Container.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  removeAll: function removeAll(destroyChild) {\n    var removed = ArrayUtils.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this);\n\n    if (destroyChild) {\n      for (var i = 0; i < removed.length; i++) {\n        removed[i].destroy();\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Brings the given Game Object to the top of this Container.\r\n   * This will cause it to render on-top of any other objects in the Container.\r\n   *\r\n   * @method Phaser.GameObjects.Container#bringToTop\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} child - The Game Object to bring to the top of the Container.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  bringToTop: function bringToTop(child) {\n    ArrayUtils.BringToTop(this.list, child);\n    return this;\n  },\n\n  /**\r\n   * Sends the given Game Object to the bottom of this Container.\r\n   * This will cause it to render below any other objects in the Container.\r\n   *\r\n   * @method Phaser.GameObjects.Container#sendToBack\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} child - The Game Object to send to the bottom of the Container.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  sendToBack: function sendToBack(child) {\n    ArrayUtils.SendToBack(this.list, child);\n    return this;\n  },\n\n  /**\r\n   * Moves the given Game Object up one place in this Container, unless it's already at the top.\r\n   *\r\n   * @method Phaser.GameObjects.Container#moveUp\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} child - The Game Object to be moved in the Container.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  moveUp: function moveUp(child) {\n    ArrayUtils.MoveUp(this.list, child);\n    return this;\n  },\n\n  /**\r\n   * Moves the given Game Object down one place in this Container, unless it's already at the bottom.\r\n   *\r\n   * @method Phaser.GameObjects.Container#moveDown\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} child - The Game Object to be moved in the Container.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  moveDown: function moveDown(child) {\n    ArrayUtils.MoveDown(this.list, child);\n    return this;\n  },\n\n  /**\r\n   * Reverses the order of all Game Objects in this Container.\r\n   *\r\n   * @method Phaser.GameObjects.Container#reverse\r\n   * @since 3.4.0\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  reverse: function reverse() {\n    this.list.reverse();\n    return this;\n  },\n\n  /**\r\n   * Shuffles the all Game Objects in this Container using the Fisher-Yates implementation.\r\n   *\r\n   * @method Phaser.GameObjects.Container#shuffle\r\n   * @since 3.4.0\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  shuffle: function shuffle() {\n    ArrayUtils.Shuffle(this.list);\n    return this;\n  },\n\n  /**\r\n   * Replaces a Game Object in this Container with the new Game Object.\r\n   * The new Game Object cannot already be a child of this Container.\r\n   *\r\n   * @method Phaser.GameObjects.Container#replace\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} oldChild - The Game Object in this Container that will be replaced.\r\n   * @param {Phaser.GameObjects.GameObject} newChild - The Game Object to be added to this Container.\r\n   * @param {boolean} [destroyChild=false] - Optionally call `destroy` on the Game Object if successfully removed from this Container.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  replace: function replace(oldChild, newChild, destroyChild) {\n    var moved = ArrayUtils.Replace(this.list, oldChild, newChild);\n\n    if (moved) {\n      this.addHandler(newChild);\n      this.removeHandler(oldChild);\n\n      if (destroyChild) {\n        oldChild.destroy();\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Returns `true` if the given Game Object is a direct child of this Container.\r\n   *\r\n   * This check does not scan nested Containers.\r\n   *\r\n   * @method Phaser.GameObjects.Container#exists\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} child - The Game Object to check for within this Container.\r\n   *\r\n   * @return {boolean} True if the Game Object is an immediate child of this Container, otherwise false.\r\n   */\n  exists: function exists(child) {\n    return this.list.indexOf(child) > -1;\n  },\n\n  /**\r\n   * Sets the property to the given value on all Game Objects in this Container.\r\n   *\r\n   * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,\r\n   * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n   * the first 50 Game Objects.\r\n   *\r\n   * @method Phaser.GameObjects.Container#setAll\r\n   * @since 3.4.0\r\n   *\r\n   * @param {string} property - The property that must exist on the Game Object.\r\n   * @param {any} value - The value to get the property to.\r\n   * @param {integer} [startIndex=0] - An optional start index to search from.\r\n   * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  setAll: function setAll(property, value, startIndex, endIndex) {\n    ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);\n    return this;\n  },\n\n  /**\r\n   * @callback EachContainerCallback\r\n   * @generic I - [item]\r\n   *\r\n   * @param {*} item - The child Game Object of the Container.\r\n   * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n   */\n\n  /**\r\n   * Passes all Game Objects in this Container to the given callback.\r\n   *\r\n   * A copy of the Container is made before passing each entry to your callback.\r\n   * This protects against the callback itself modifying the Container.\r\n   *\r\n   * If you know for sure that the callback will not change the size of this Container\r\n   * then you can use the more performant `Container.iterate` method instead.\r\n   *\r\n   * @method Phaser.GameObjects.Container#each\r\n   * @since 3.4.0\r\n   *\r\n   * @param {function} callback - The function to call.\r\n   * @param {object} [context] - Value to use as `this` when executing callback.\r\n   * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  each: function each(callback, context) {\n    var args = [null];\n    var i;\n    var temp = this.list.slice();\n    var len = temp.length;\n\n    for (i = 2; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    for (i = 0; i < len; i++) {\n      args[0] = temp[i];\n      callback.apply(context, args);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Passes all Game Objects in this Container to the given callback.\r\n   *\r\n   * Only use this method when you absolutely know that the Container will not be modified during\r\n   * the iteration, i.e. by removing or adding to its contents.\r\n   *\r\n   * @method Phaser.GameObjects.Container#iterate\r\n   * @since 3.4.0\r\n   *\r\n   * @param {function} callback - The function to call.\r\n   * @param {object} [context] - Value to use as `this` when executing callback.\r\n   * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n   *\r\n   * @return {Phaser.GameObjects.Container} This Container instance.\r\n   */\n  iterate: function iterate(callback, context) {\n    var args = [null];\n    var i;\n\n    for (i = 2; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    for (i = 0; i < this.list.length; i++) {\n      args[0] = this.list[i];\n      callback.apply(context, args);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * The number of Game Objects inside this Container.\r\n   *\r\n   * @name Phaser.GameObjects.Container#length\r\n   * @type {integer}\r\n   * @readonly\r\n   * @since 3.4.0\r\n   */\n  length: {\n    get: function get() {\n      return this.list.length;\n    }\n  },\n\n  /**\r\n   * Returns the first Game Object within the Container, or `null` if it is empty.\r\n   *\r\n   * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n   *\r\n   * @name Phaser.GameObjects.Container#first\r\n   * @type {?Phaser.GameObjects.GameObject}\r\n   * @readonly\r\n   * @since 3.4.0\r\n   */\n  first: {\n    get: function get() {\n      this.position = 0;\n\n      if (this.list.length > 0) {\n        return this.list[0];\n      } else {\n        return null;\n      }\n    }\n  },\n\n  /**\r\n   * Returns the last Game Object within the Container, or `null` if it is empty.\r\n   *\r\n   * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n   *\r\n   * @name Phaser.GameObjects.Container#last\r\n   * @type {?Phaser.GameObjects.GameObject}\r\n   * @readonly\r\n   * @since 3.4.0\r\n   */\n  last: {\n    get: function get() {\n      if (this.list.length > 0) {\n        this.position = this.list.length - 1;\n        return this.list[this.position];\n      } else {\n        return null;\n      }\n    }\n  },\n\n  /**\r\n   * Returns the next Game Object within the Container, or `null` if it is empty.\r\n   *\r\n   * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n   *\r\n   * @name Phaser.GameObjects.Container#next\r\n   * @type {?Phaser.GameObjects.GameObject}\r\n   * @readonly\r\n   * @since 3.4.0\r\n   */\n  next: {\n    get: function get() {\n      if (this.position < this.list.length) {\n        this.position++;\n        return this.list[this.position];\n      } else {\n        return null;\n      }\n    }\n  },\n\n  /**\r\n   * Returns the previous Game Object within the Container, or `null` if it is empty.\r\n   *\r\n   * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n   *\r\n   * @name Phaser.GameObjects.Container#previous\r\n   * @type {?Phaser.GameObjects.GameObject}\r\n   * @readonly\r\n   * @since 3.4.0\r\n   */\n  previous: {\n    get: function get() {\n      if (this.position > 0) {\n        this.position--;\n        return this.list[this.position];\n      } else {\n        return null;\n      }\n    }\n  },\n\n  /**\r\n   * Internal destroy handler, called as part of the destroy process.\r\n   *\r\n   * @method Phaser.GameObjects.Container#preDestroy\r\n   * @protected\r\n   * @since 3.9.0\r\n   */\n  preDestroy: function preDestroy() {\n    this.removeAll(!!this.exclusive);\n    this.localTransform.destroy();\n    this.tempTransformMatrix.destroy();\n    this.list = [];\n    this._displayList = null;\n  }\n});\nmodule.exports = Container;","map":null,"metadata":{},"sourceType":"script"}