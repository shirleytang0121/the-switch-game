{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar GetTilesWithin = require('./GetTilesWithin');\n/**\r\n * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n * specified layer. Each tile will receive a new index. New indexes are drawn from the given\r\n * weightedIndexes array. An example weighted array:\r\n *\r\n * [\r\n *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8\r\n *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8\r\n *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8\r\n *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8\r\n * ]\r\n *\r\n * The probability of any index being choose is (the index's weight) / (sum of all weights). This\r\n * method only modifies tile indexes and does not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.WeightedRandomize\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n * @param {object[]} [weightedIndexes] - An array of objects to randomly draw from during\r\n * randomization. They should be in the form: { index: 0, weight: 4 } or\r\n * { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\n\n\nvar WeightedRandomize = function WeightedRandomize(tileX, tileY, width, height, weightedIndexes, layer) {\n  if (weightedIndexes === undefined) {\n    return;\n  }\n\n  var i;\n  var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\n  var weightTotal = 0;\n\n  for (i = 0; i < weightedIndexes.length; i++) {\n    weightTotal += weightedIndexes[i].weight;\n  }\n\n  if (weightTotal <= 0) {\n    return;\n  }\n\n  for (i = 0; i < tiles.length; i++) {\n    var rand = Math.random() * weightTotal;\n    var sum = 0;\n    var randomIndex = -1;\n\n    for (var j = 0; j < weightedIndexes.length; j++) {\n      sum += weightedIndexes[j].weight;\n\n      if (rand <= sum) {\n        var chosen = weightedIndexes[j].index;\n        randomIndex = Array.isArray(chosen) ? chosen[Math.floor(Math.random() * chosen.length)] : chosen;\n        break;\n      }\n    }\n\n    tiles[i].index = randomIndex;\n  }\n};\n\nmodule.exports = WeightedRandomize;","map":null,"metadata":{},"sourceType":"script"}