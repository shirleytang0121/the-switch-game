{"ast":null,"code":"/**\r\n* The `Matter.Body` module contains methods for creating and manipulating body models.\r\n* A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.\r\n* Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n\r\n* @class Body\r\n*/\nvar Body = {};\nmodule.exports = Body;\n\nvar Vertices = require('../geometry/Vertices');\n\nvar Vector = require('../geometry/Vector');\n\nvar Sleeping = require('../core/Sleeping');\n\nvar Common = require('../core/Common');\n\nvar Bounds = require('../geometry/Bounds');\n\nvar Axes = require('../geometry/Axes');\n\n(function () {\n  Body._inertiaScale = 4;\n  Body._nextCollidingGroupId = 1;\n  Body._nextNonCollidingGroupId = -1;\n  Body._nextCategory = 0x0001;\n  /**\r\n   * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n   * All properties have default values, and many are pre-calculated automatically based on other properties.\r\n   * Vertices must be specified in clockwise order.\r\n   * See the properties section below for detailed information on what you can pass via the `options` object.\r\n   * @method create\r\n   * @param {} options\r\n   * @return {body} body\r\n   */\n\n  Body.create = function (options) {\n    var defaults = {\n      id: Common.nextId(),\n      type: 'body',\n      label: 'Body',\n      gameObject: null,\n      parts: [],\n      plugin: {},\n      angle: 0,\n      vertices: Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40'),\n      position: {\n        x: 0,\n        y: 0\n      },\n      force: {\n        x: 0,\n        y: 0\n      },\n      torque: 0,\n      positionImpulse: {\n        x: 0,\n        y: 0\n      },\n      previousPositionImpulse: {\n        x: 0,\n        y: 0\n      },\n      constraintImpulse: {\n        x: 0,\n        y: 0,\n        angle: 0\n      },\n      totalContacts: 0,\n      speed: 0,\n      angularSpeed: 0,\n      velocity: {\n        x: 0,\n        y: 0\n      },\n      angularVelocity: 0,\n      isSensor: false,\n      isStatic: false,\n      isSleeping: false,\n      ignoreGravity: false,\n      ignorePointer: false,\n      motion: 0,\n      sleepThreshold: 60,\n      density: 0.001,\n      restitution: 0,\n      friction: 0.1,\n      frictionStatic: 0.5,\n      frictionAir: 0.01,\n      collisionFilter: {\n        category: 0x0001,\n        mask: 0xFFFFFFFF,\n        group: 0\n      },\n      slop: 0.05,\n      timeScale: 1,\n      render: {\n        visible: true,\n        opacity: 1,\n        sprite: {\n          xScale: 1,\n          yScale: 1,\n          xOffset: 0,\n          yOffset: 0\n        },\n        lineWidth: 0\n      },\n      events: null,\n      bounds: null,\n      chamfer: null,\n      circleRadius: 0,\n      positionPrev: null,\n      anglePrev: 0,\n      parent: null,\n      axes: null,\n      area: 0,\n      mass: 0,\n      inertia: 0,\n      _original: null\n    };\n    var body = Common.extend(defaults, options);\n\n    _initProperties(body, options);\n\n    return body;\n  };\n  /**\r\n   * Returns the next unique group index for which bodies will collide.\r\n   * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.\r\n   * See `body.collisionFilter` for more information.\r\n   * @method nextGroup\r\n   * @param {bool} [isNonColliding=false]\r\n   * @return {Number} Unique group index\r\n   */\n\n\n  Body.nextGroup = function (isNonColliding) {\n    if (isNonColliding) return Body._nextNonCollidingGroupId--;\n    return Body._nextCollidingGroupId++;\n  };\n  /**\r\n   * Returns the next unique category bitfield (starting after the initial default category `0x0001`).\r\n   * There are 32 available. See `body.collisionFilter` for more information.\r\n   * @method nextCategory\r\n   * @return {Number} Unique category bitfield\r\n   */\n\n\n  Body.nextCategory = function () {\n    Body._nextCategory = Body._nextCategory << 1;\n    return Body._nextCategory;\n  };\n  /**\r\n   * Initialises body properties.\r\n   * @method _initProperties\r\n   * @private\r\n   * @param {body} body\r\n   * @param {} [options]\r\n   */\n\n\n  var _initProperties = function _initProperties(body, options) {\n    options = options || {}; // init required properties (order is important)\n\n    Body.set(body, {\n      bounds: body.bounds || Bounds.create(body.vertices),\n      positionPrev: body.positionPrev || Vector.clone(body.position),\n      anglePrev: body.anglePrev || body.angle,\n      vertices: body.vertices,\n      parts: body.parts || [body],\n      isStatic: body.isStatic,\n      isSleeping: body.isSleeping,\n      parent: body.parent || body\n    });\n    Vertices.rotate(body.vertices, body.angle, body.position);\n    Axes.rotate(body.axes, body.angle);\n    Bounds.update(body.bounds, body.vertices, body.velocity); // allow options to override the automatically calculated properties\n\n    Body.set(body, {\n      axes: options.axes || body.axes,\n      area: options.area || body.area,\n      mass: options.mass || body.mass,\n      inertia: options.inertia || body.inertia\n    }); // render properties\n\n    var defaultFillStyle = body.isStatic ? '#2e2b44' : Common.choose(['#006BA6', '#0496FF', '#FFBC42', '#D81159', '#8F2D56']),\n        defaultStrokeStyle = '#000';\n    body.render.fillStyle = body.render.fillStyle || defaultFillStyle;\n    body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;\n    body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);\n    body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);\n  };\n  /**\r\n   * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.\r\n   * Prefer to use the actual setter functions in performance critical situations.\r\n   * @method set\r\n   * @param {body} body\r\n   * @param {} settings A property name (or map of properties and values) to set on the body.\r\n   * @param {} value The value to set if `settings` is a single property name.\r\n   */\n\n\n  Body.set = function (body, settings, value) {\n    var property;\n\n    if (typeof settings === 'string') {\n      property = settings;\n      settings = {};\n      settings[property] = value;\n    }\n\n    for (property in settings) {\n      if (!settings.hasOwnProperty(property)) continue;\n      value = settings[property];\n\n      switch (property) {\n        case 'isStatic':\n          Body.setStatic(body, value);\n          break;\n\n        case 'isSleeping':\n          Sleeping.set(body, value);\n          break;\n\n        case 'mass':\n          Body.setMass(body, value);\n          break;\n\n        case 'density':\n          Body.setDensity(body, value);\n          break;\n\n        case 'inertia':\n          Body.setInertia(body, value);\n          break;\n\n        case 'vertices':\n          Body.setVertices(body, value);\n          break;\n\n        case 'position':\n          Body.setPosition(body, value);\n          break;\n\n        case 'angle':\n          Body.setAngle(body, value);\n          break;\n\n        case 'velocity':\n          Body.setVelocity(body, value);\n          break;\n\n        case 'angularVelocity':\n          Body.setAngularVelocity(body, value);\n          break;\n\n        case 'parts':\n          Body.setParts(body, value);\n          break;\n\n        default:\n          body[property] = value;\n      }\n    }\n  };\n  /**\r\n   * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.\r\n   * @method setStatic\r\n   * @param {body} body\r\n   * @param {bool} isStatic\r\n   */\n\n\n  Body.setStatic = function (body, isStatic) {\n    for (var i = 0; i < body.parts.length; i++) {\n      var part = body.parts[i];\n      part.isStatic = isStatic;\n\n      if (isStatic) {\n        part._original = {\n          restitution: part.restitution,\n          friction: part.friction,\n          mass: part.mass,\n          inertia: part.inertia,\n          density: part.density,\n          inverseMass: part.inverseMass,\n          inverseInertia: part.inverseInertia\n        };\n        part.restitution = 0;\n        part.friction = 1;\n        part.mass = part.inertia = part.density = Infinity;\n        part.inverseMass = part.inverseInertia = 0;\n        part.positionPrev.x = part.position.x;\n        part.positionPrev.y = part.position.y;\n        part.anglePrev = part.angle;\n        part.angularVelocity = 0;\n        part.speed = 0;\n        part.angularSpeed = 0;\n        part.motion = 0;\n      } else if (part._original) {\n        part.restitution = part._original.restitution;\n        part.friction = part._original.friction;\n        part.mass = part._original.mass;\n        part.inertia = part._original.inertia;\n        part.density = part._original.density;\n        part.inverseMass = part._original.inverseMass;\n        part.inverseInertia = part._original.inverseInertia;\n        part._original = null;\n      }\n    }\n  };\n  /**\r\n   * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.\r\n   * @method setMass\r\n   * @param {body} body\r\n   * @param {number} mass\r\n   */\n\n\n  Body.setMass = function (body, mass) {\n    var moment = body.inertia / (body.mass / 6);\n    body.inertia = moment * (mass / 6);\n    body.inverseInertia = 1 / body.inertia;\n    body.mass = mass;\n    body.inverseMass = 1 / body.mass;\n    body.density = body.mass / body.area;\n  };\n  /**\r\n   * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.\r\n   * @method setDensity\r\n   * @param {body} body\r\n   * @param {number} density\r\n   */\n\n\n  Body.setDensity = function (body, density) {\n    Body.setMass(body, density * body.area);\n    body.density = density;\n  };\n  /**\r\n   * Sets the moment of inertia (i.e. second moment of area) of the body of the body. \r\n   * Inverse inertia is automatically updated to reflect the change. Mass is not changed.\r\n   * @method setInertia\r\n   * @param {body} body\r\n   * @param {number} inertia\r\n   */\n\n\n  Body.setInertia = function (body, inertia) {\n    body.inertia = inertia;\n    body.inverseInertia = 1 / body.inertia;\n  };\n  /**\r\n   * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).\r\n   * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.\r\n   * They are then automatically translated to world space based on `body.position`.\r\n   *\r\n   * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).\r\n   * Vertices must form a convex hull, concave hulls are not supported.\r\n   *\r\n   * @method setVertices\r\n   * @param {body} body\r\n   * @param {vector[]} vertices\r\n   */\n\n\n  Body.setVertices = function (body, vertices) {\n    // change vertices\n    if (vertices[0].body === body) {\n      body.vertices = vertices;\n    } else {\n      body.vertices = Vertices.create(vertices, body);\n    } // update properties\n\n\n    body.axes = Axes.fromVertices(body.vertices);\n    body.area = Vertices.area(body.vertices);\n    Body.setMass(body, body.density * body.area); // orient vertices around the centre of mass at origin (0, 0)\n\n    var centre = Vertices.centre(body.vertices);\n    Vertices.translate(body.vertices, centre, -1); // update inertia while vertices are at origin (0, 0)\n\n    Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass)); // update geometry\n\n    Vertices.translate(body.vertices, body.position);\n    Bounds.update(body.bounds, body.vertices, body.velocity);\n  };\n  /**\r\n   * Sets the parts of the `body` and updates mass, inertia and centroid.\r\n   * Each part will have its parent set to `body`.\r\n   * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`\r\n   * Note that this method will ensure that the first part in `body.parts` will always be the `body`.\r\n   * @method setParts\r\n   * @param {body} body\r\n   * @param [body] parts\r\n   * @param {bool} [autoHull=true]\r\n   */\n\n\n  Body.setParts = function (body, parts, autoHull) {\n    var i; // add all the parts, ensuring that the first part is always the parent body\n\n    parts = parts.slice(0);\n    body.parts.length = 0;\n    body.parts.push(body);\n    body.parent = body;\n\n    for (i = 0; i < parts.length; i++) {\n      var part = parts[i];\n\n      if (part !== body) {\n        part.parent = body;\n        body.parts.push(part);\n      }\n    }\n\n    if (body.parts.length === 1) return;\n    autoHull = typeof autoHull !== 'undefined' ? autoHull : true; // find the convex hull of all parts to set on the parent body\n\n    if (autoHull) {\n      var vertices = [];\n\n      for (i = 0; i < parts.length; i++) {\n        vertices = vertices.concat(parts[i].vertices);\n      }\n\n      Vertices.clockwiseSort(vertices);\n      var hull = Vertices.hull(vertices),\n          hullCentre = Vertices.centre(hull);\n      Body.setVertices(body, hull);\n      Vertices.translate(body.vertices, hullCentre);\n    } // sum the properties of all compound parts of the parent body\n\n\n    var total = Body._totalProperties(body);\n\n    body.area = total.area;\n    body.parent = body;\n    body.position.x = total.centre.x;\n    body.position.y = total.centre.y;\n    body.positionPrev.x = total.centre.x;\n    body.positionPrev.y = total.centre.y;\n    Body.setMass(body, total.mass);\n    Body.setInertia(body, total.inertia);\n    Body.setPosition(body, total.centre);\n  };\n  /**\r\n   * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.\r\n   * @method setPosition\r\n   * @param {body} body\r\n   * @param {vector} position\r\n   */\n\n\n  Body.setPosition = function (body, position) {\n    var delta = Vector.sub(position, body.position);\n    body.positionPrev.x += delta.x;\n    body.positionPrev.y += delta.y;\n\n    for (var i = 0; i < body.parts.length; i++) {\n      var part = body.parts[i];\n      part.position.x += delta.x;\n      part.position.y += delta.y;\n      Vertices.translate(part.vertices, delta);\n      Bounds.update(part.bounds, part.vertices, body.velocity);\n    }\n  };\n  /**\r\n   * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.\r\n   * @method setAngle\r\n   * @param {body} body\r\n   * @param {number} angle\r\n   */\n\n\n  Body.setAngle = function (body, angle) {\n    var delta = angle - body.angle;\n    body.anglePrev += delta;\n\n    for (var i = 0; i < body.parts.length; i++) {\n      var part = body.parts[i];\n      part.angle += delta;\n      Vertices.rotate(part.vertices, delta, body.position);\n      Axes.rotate(part.axes, delta);\n      Bounds.update(part.bounds, part.vertices, body.velocity);\n\n      if (i > 0) {\n        Vector.rotateAbout(part.position, delta, body.position, part.position);\n      }\n    }\n  };\n  /**\r\n   * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\r\n   * @method setVelocity\r\n   * @param {body} body\r\n   * @param {vector} velocity\r\n   */\n\n\n  Body.setVelocity = function (body, velocity) {\n    body.positionPrev.x = body.position.x - velocity.x;\n    body.positionPrev.y = body.position.y - velocity.y;\n    body.velocity.x = velocity.x;\n    body.velocity.y = velocity.y;\n    body.speed = Vector.magnitude(body.velocity);\n  };\n  /**\r\n   * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\r\n   * @method setAngularVelocity\r\n   * @param {body} body\r\n   * @param {number} velocity\r\n   */\n\n\n  Body.setAngularVelocity = function (body, velocity) {\n    body.anglePrev = body.angle - velocity;\n    body.angularVelocity = velocity;\n    body.angularSpeed = Math.abs(body.angularVelocity);\n  };\n  /**\r\n   * Moves a body by a given vector relative to its current position, without imparting any velocity.\r\n   * @method translate\r\n   * @param {body} body\r\n   * @param {vector} translation\r\n   */\n\n\n  Body.translate = function (body, translation) {\n    Body.setPosition(body, Vector.add(body.position, translation));\n  };\n  /**\r\n   * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.\r\n   * @method rotate\r\n   * @param {body} body\r\n   * @param {number} rotation\r\n   * @param {vector} [point]\r\n   */\n\n\n  Body.rotate = function (body, rotation, point) {\n    if (!point) {\n      Body.setAngle(body, body.angle + rotation);\n    } else {\n      var cos = Math.cos(rotation),\n          sin = Math.sin(rotation),\n          dx = body.position.x - point.x,\n          dy = body.position.y - point.y;\n      Body.setPosition(body, {\n        x: point.x + (dx * cos - dy * sin),\n        y: point.y + (dx * sin + dy * cos)\n      });\n      Body.setAngle(body, body.angle + rotation);\n    }\n  };\n  /**\r\n   * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).\r\n   * @method scale\r\n   * @param {body} body\r\n   * @param {number} scaleX\r\n   * @param {number} scaleY\r\n   * @param {vector} [point]\r\n   */\n\n\n  Body.scale = function (body, scaleX, scaleY, point) {\n    var totalArea = 0,\n        totalInertia = 0;\n    point = point || body.position;\n\n    for (var i = 0; i < body.parts.length; i++) {\n      var part = body.parts[i]; // scale vertices\n\n      Vertices.scale(part.vertices, scaleX, scaleY, point); // update properties\n\n      part.axes = Axes.fromVertices(part.vertices);\n      part.area = Vertices.area(part.vertices);\n      Body.setMass(part, body.density * part.area); // update inertia (requires vertices to be at origin)\n\n      Vertices.translate(part.vertices, {\n        x: -part.position.x,\n        y: -part.position.y\n      });\n      Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));\n      Vertices.translate(part.vertices, {\n        x: part.position.x,\n        y: part.position.y\n      });\n\n      if (i > 0) {\n        totalArea += part.area;\n        totalInertia += part.inertia;\n      } // scale position\n\n\n      part.position.x = point.x + (part.position.x - point.x) * scaleX;\n      part.position.y = point.y + (part.position.y - point.y) * scaleY; // update bounds\n\n      Bounds.update(part.bounds, part.vertices, body.velocity);\n    } // handle parent body\n\n\n    if (body.parts.length > 1) {\n      body.area = totalArea;\n\n      if (!body.isStatic) {\n        Body.setMass(body, body.density * totalArea);\n        Body.setInertia(body, totalInertia);\n      }\n    } // handle circles\n\n\n    if (body.circleRadius) {\n      if (scaleX === scaleY) {\n        body.circleRadius *= scaleX;\n      } else {\n        // body is no longer a circle\n        body.circleRadius = null;\n      }\n    }\n  };\n  /**\r\n   * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.\r\n   * @method update\r\n   * @param {body} body\r\n   * @param {number} deltaTime\r\n   * @param {number} timeScale\r\n   * @param {number} correction\r\n   */\n\n\n  Body.update = function (body, deltaTime, timeScale, correction) {\n    var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2); // from the previous step\n\n    var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale,\n        velocityPrevX = body.position.x - body.positionPrev.x,\n        velocityPrevY = body.position.y - body.positionPrev.y; // update velocity with Verlet integration\n\n    body.velocity.x = velocityPrevX * frictionAir * correction + body.force.x / body.mass * deltaTimeSquared;\n    body.velocity.y = velocityPrevY * frictionAir * correction + body.force.y / body.mass * deltaTimeSquared;\n    body.positionPrev.x = body.position.x;\n    body.positionPrev.y = body.position.y;\n    body.position.x += body.velocity.x;\n    body.position.y += body.velocity.y; // update angular velocity with Verlet integration\n\n    body.angularVelocity = (body.angle - body.anglePrev) * frictionAir * correction + body.torque / body.inertia * deltaTimeSquared;\n    body.anglePrev = body.angle;\n    body.angle += body.angularVelocity; // track speed and acceleration\n\n    body.speed = Vector.magnitude(body.velocity);\n    body.angularSpeed = Math.abs(body.angularVelocity); // transform the body geometry\n\n    for (var i = 0; i < body.parts.length; i++) {\n      var part = body.parts[i];\n      Vertices.translate(part.vertices, body.velocity);\n\n      if (i > 0) {\n        part.position.x += body.velocity.x;\n        part.position.y += body.velocity.y;\n      }\n\n      if (body.angularVelocity !== 0) {\n        Vertices.rotate(part.vertices, body.angularVelocity, body.position);\n        Axes.rotate(part.axes, body.angularVelocity);\n\n        if (i > 0) {\n          Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);\n        }\n      }\n\n      Bounds.update(part.bounds, part.vertices, body.velocity);\n    }\n  };\n  /**\r\n   * Applies a force to a body from a given world-space position, including resulting torque.\r\n   * @method applyForce\r\n   * @param {body} body\r\n   * @param {vector} position\r\n   * @param {vector} force\r\n   */\n\n\n  Body.applyForce = function (body, position, force) {\n    body.force.x += force.x;\n    body.force.y += force.y;\n    var offset = {\n      x: position.x - body.position.x,\n      y: position.y - body.position.y\n    };\n    body.torque += offset.x * force.y - offset.y * force.x;\n  };\n  /**\r\n   * Returns the sums of the properties of all compound parts of the parent body.\r\n   * @method _totalProperties\r\n   * @private\r\n   * @param {body} body\r\n   * @return {}\r\n   */\n\n\n  Body._totalProperties = function (body) {\n    // from equations at:\n    // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory\n    // http://output.to/sideway/default.asp?qno=121100087\n    var properties = {\n      mass: 0,\n      area: 0,\n      inertia: 0,\n      centre: {\n        x: 0,\n        y: 0\n      }\n    }; // sum the properties of all compound parts of the parent body\n\n    for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {\n      var part = body.parts[i],\n          mass = part.mass !== Infinity ? part.mass : 1;\n      properties.mass += mass;\n      properties.area += part.area;\n      properties.inertia += part.inertia;\n      properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));\n    }\n\n    properties.centre = Vector.div(properties.centre, properties.mass);\n    return properties;\n  };\n  /*\r\n  *\r\n  *  Events Documentation\r\n  *\r\n  */\n\n  /**\r\n  * Fired when a body starts sleeping (where `this` is the body).\r\n  *\r\n  * @event sleepStart\r\n  * @this {body} The body that has started sleeping\r\n  * @param {} event An event object\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired when a body ends sleeping (where `this` is the body).\r\n  *\r\n  * @event sleepEnd\r\n  * @this {body} The body that has ended sleeping\r\n  * @param {} event An event object\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /*\r\n  *\r\n  *  Properties Documentation\r\n  *\r\n  */\n\n  /**\r\n   * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.\r\n   *\r\n   * @property id\r\n   * @type number\r\n   */\n\n  /**\r\n   * A `String` denoting the type of object.\r\n   *\r\n   * @property type\r\n   * @type string\r\n   * @default \"body\"\r\n   * @readOnly\r\n   */\n\n  /**\r\n   * An arbitrary `String` name to help the user identify and manage bodies.\r\n   *\r\n   * @property label\r\n   * @type string\r\n   * @default \"Body\"\r\n   */\n\n  /**\r\n   * An array of bodies that make up this body. \r\n   * The first body in the array must always be a self reference to the current body instance.\r\n   * All bodies in the `parts` array together form a single rigid compound body.\r\n   * Parts are allowed to overlap, have gaps or holes or even form concave bodies.\r\n   * Parts themselves should never be added to a `World`, only the parent body should be.\r\n   * Use `Body.setParts` when setting parts to ensure correct updates of all properties.\r\n   *\r\n   * @property parts\r\n   * @type body[]\r\n   */\n\n  /**\r\n   * An object reserved for storing plugin-specific properties.\r\n   *\r\n   * @property plugin\r\n   * @type {}\r\n   */\n\n  /**\r\n   * A self reference if the body is _not_ a part of another body.\r\n   * Otherwise this is a reference to the body that this is a part of.\r\n   * See `body.parts`.\r\n   *\r\n   * @property parent\r\n   * @type body\r\n   */\n\n  /**\r\n   * A `Number` specifying the angle of the body, in radians.\r\n   *\r\n   * @property angle\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * An array of `Vector` objects that specify the convex hull of the rigid body.\r\n   * These should be provided about the origin `(0, 0)`. E.g.\r\n   *\r\n   *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\r\n   *\r\n   * When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).\r\n   * The `Vector` objects are also augmented with additional properties required for efficient collision detection. \r\n   *\r\n   * Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).\r\n   * Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.\r\n   *\r\n   * @property vertices\r\n   * @type vector[]\r\n   */\n\n  /**\r\n   * A `Vector` that specifies the current world-space position of the body.\r\n   *\r\n   * @property position\r\n   * @type vector\r\n   * @default { x: 0, y: 0 }\r\n   */\n\n  /**\r\n   * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.\r\n   *\r\n   * @property force\r\n   * @type vector\r\n   * @default { x: 0, y: 0 }\r\n   */\n\n  /**\r\n   * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.\r\n   *\r\n   * @property torque\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).\r\n   *\r\n   * @readOnly\r\n   * @property speed\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).\r\n   *\r\n   * @readOnly\r\n   * @property angularSpeed\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only. \r\n   * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).\r\n   *\r\n   * @readOnly\r\n   * @property velocity\r\n   * @type vector\r\n   * @default { x: 0, y: 0 }\r\n   */\n\n  /**\r\n   * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only. \r\n   * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).\r\n   *\r\n   * @readOnly\r\n   * @property angularVelocity\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.\r\n   * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.\r\n   *\r\n   * @property isStatic\r\n   * @type boolean\r\n   * @default false\r\n   */\n\n  /**\r\n   * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.\r\n   *\r\n   * @property isSensor\r\n   * @type boolean\r\n   * @default false\r\n   */\n\n  /**\r\n   * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.\r\n   * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.\r\n   *\r\n   * @property isSleeping\r\n   * @type boolean\r\n   * @default false\r\n   */\n\n  /**\r\n   * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.\r\n   * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.\r\n   *\r\n   * @readOnly\r\n   * @property motion\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).\r\n   *\r\n   * @property sleepThreshold\r\n   * @type number\r\n   * @default 60\r\n   */\n\n  /**\r\n   * A `Number` that defines the density of the body, that is its mass per unit area.\r\n   * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.\r\n   * This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).\r\n   *\r\n   * @property density\r\n   * @type number\r\n   * @default 0.001\r\n   */\n\n  /**\r\n   * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.\r\n   * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).\r\n   *\r\n   * @property mass\r\n   * @type number\r\n   */\n\n  /**\r\n   * A `Number` that defines the inverse mass of the body (`1 / mass`).\r\n   * If you modify this value, you must also modify the `body.mass` property.\r\n   *\r\n   * @property inverseMass\r\n   * @type number\r\n   */\n\n  /**\r\n   * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.\r\n   * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.\r\n   * If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).\r\n   *\r\n   * @property inertia\r\n   * @type number\r\n   */\n\n  /**\r\n   * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).\r\n   * If you modify this value, you must also modify the `body.inertia` property.\r\n   *\r\n   * @property inverseInertia\r\n   * @type number\r\n   */\n\n  /**\r\n   * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.\r\n   * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. \r\n   * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.\r\n   * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:\r\n   *\r\n   *     Math.max(bodyA.restitution, bodyB.restitution)\r\n   *\r\n   * @property restitution\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.\r\n   * A value of `0` means that the body may slide indefinitely.\r\n   * A value of `1` means the body may come to a stop almost instantly after a force is applied.\r\n   *\r\n   * The effects of the value may be non-linear. \r\n   * High values may be unstable depending on the body.\r\n   * The engine uses a Coulomb friction model including static and kinetic friction.\r\n   * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:\r\n   *\r\n   *     Math.min(bodyA.friction, bodyB.friction)\r\n   *\r\n   * @property friction\r\n   * @type number\r\n   * @default 0.1\r\n   */\n\n  /**\r\n   * A `Number` that defines the static friction of the body (in the Coulomb friction model). \r\n   * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.\r\n   * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.\r\n   * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.\r\n   *\r\n   * @property frictionStatic\r\n   * @type number\r\n   * @default 0.5\r\n   */\n\n  /**\r\n   * A `Number` that defines the air friction of the body (air resistance). \r\n   * A value of `0` means the body will never slow as it moves through space.\r\n   * The higher the value, the faster a body slows when moving through space.\r\n   * The effects of the value are non-linear. \r\n   *\r\n   * @property frictionAir\r\n   * @type number\r\n   * @default 0.01\r\n   */\n\n  /**\r\n   * An `Object` that specifies the collision filtering properties of this body.\r\n   *\r\n   * Collisions between two bodies will obey the following rules:\r\n   * - If the two bodies have the same non-zero value of `collisionFilter.group`,\r\n   *   they will always collide if the value is positive, and they will never collide\r\n   *   if the value is negative.\r\n   * - If the two bodies have different values of `collisionFilter.group` or if one\r\n   *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:\r\n   *\r\n   * Each body belongs to a collision category, given by `collisionFilter.category`. This\r\n   * value is used as a bit field and the category should have only one bit set, meaning that\r\n   * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32\r\n   * different collision categories available.\r\n   *\r\n   * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies\r\n   * the categories it collides with (the value is the bitwise AND value of all these categories).\r\n   *\r\n   * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's\r\n   * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`\r\n   * are both true.\r\n   *\r\n   * @property collisionFilter\r\n   * @type object\r\n   */\n\n  /**\r\n   * An Integer `Number`, that specifies the collision group this body belongs to.\r\n   * See `body.collisionFilter` for more information.\r\n   *\r\n   * @property collisionFilter.group\r\n   * @type object\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A bit field that specifies the collision category this body belongs to.\r\n   * The category value should have only one bit set, for example `0x0001`.\r\n   * This means there are up to 32 unique collision categories available.\r\n   * See `body.collisionFilter` for more information.\r\n   *\r\n   * @property collisionFilter.category\r\n   * @type object\r\n   * @default 1\r\n   */\n\n  /**\r\n   * A bit mask that specifies the collision categories this body may collide with.\r\n   * See `body.collisionFilter` for more information.\r\n   *\r\n   * @property collisionFilter.mask\r\n   * @type object\r\n   * @default -1\r\n   */\n\n  /**\r\n   * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.\r\n   * Avoid changing this value unless you understand the purpose of `slop` in physics engines.\r\n   * The default should generally suffice, although very large bodies may require larger values for stable stacking.\r\n   *\r\n   * @property slop\r\n   * @type number\r\n   * @default 0.05\r\n   */\n\n  /**\r\n   * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.\r\n   *\r\n   * @property timeScale\r\n   * @type number\r\n   * @default 1\r\n   */\n\n  /**\r\n   * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\r\n   *\r\n   * @property render\r\n   * @type object\r\n   */\n\n  /**\r\n   * A flag that indicates if the body should be rendered.\r\n   *\r\n   * @property render.visible\r\n   * @type boolean\r\n   * @default true\r\n   */\n\n  /**\r\n   * Sets the opacity to use when rendering.\r\n   *\r\n   * @property render.opacity\r\n   * @type number\r\n   * @default 1\r\n  */\n\n  /**\r\n   * An `Object` that defines the sprite properties to use when rendering, if any.\r\n   *\r\n   * @property render.sprite\r\n   * @type object\r\n   */\n\n  /**\r\n   * An `String` that defines the path to the image to use as the sprite texture, if any.\r\n   *\r\n   * @property render.sprite.texture\r\n   * @type string\r\n   */\n\n  /**\r\n   * A `Number` that defines the scaling in the x-axis for the sprite, if any.\r\n   *\r\n   * @property render.sprite.xScale\r\n   * @type number\r\n   * @default 1\r\n   */\n\n  /**\r\n   * A `Number` that defines the scaling in the y-axis for the sprite, if any.\r\n   *\r\n   * @property render.sprite.yScale\r\n   * @type number\r\n   * @default 1\r\n   */\n\n  /**\r\n   * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).\r\n   *\r\n   * @property render.sprite.xOffset\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).\r\n   *\r\n   * @property render.sprite.yOffset\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).\r\n   * A value of `0` means no outline will be rendered.\r\n   *\r\n   * @property render.lineWidth\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).\r\n   * It is the same as when using a canvas, so it accepts CSS style property values.\r\n   *\r\n   * @property render.fillStyle\r\n   * @type string\r\n   * @default a random colour\r\n   */\n\n  /**\r\n   * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).\r\n   * It is the same as when using a canvas, so it accepts CSS style property values.\r\n   *\r\n   * @property render.strokeStyle\r\n   * @type string\r\n   * @default a random colour\r\n   */\n\n  /**\r\n   * An array of unique axis vectors (edge normals) used for collision detection.\r\n   * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.\r\n   * They are constantly updated by `Body.update` during the simulation.\r\n   *\r\n   * @property axes\r\n   * @type vector[]\r\n   */\n\n  /**\r\n   * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.\r\n   *\r\n   * @property area\r\n   * @type string\r\n   * @default \r\n   */\n\n  /**\r\n   * A `Bounds` object that defines the AABB region for the body.\r\n   * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.\r\n   *\r\n   * @property bounds\r\n   * @type bounds\r\n   */\n\n})();","map":null,"metadata":{},"sourceType":"script"}