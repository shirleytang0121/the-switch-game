{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar GameEvents = require('../core/events');\n\nvar EventEmitter = require('eventemitter3');\n\nvar FileTypesManager = require('../loader/FileTypesManager');\n\nvar GameObjectCreator = require('../gameobjects/GameObjectCreator');\n\nvar GameObjectFactory = require('../gameobjects/GameObjectFactory');\n\nvar GetFastValue = require('../utils/object/GetFastValue');\n\nvar PluginCache = require('./PluginCache');\n\nvar Remove = require('../utils/array/Remove');\n/**\r\n * @typedef {object} GlobalPlugin\r\n *\r\n * @property {string} key - The unique name of this plugin within the plugin cache.\r\n * @property {function} plugin - An instance of the plugin.\r\n * @property {boolean} [active] - Is the plugin active or not?\r\n * @property {string} [mapping] - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n */\n\n/**\r\n * @classdesc\r\n * The PluginManager is responsible for installing and adding plugins to Phaser.\r\n *\r\n * It is a global system and therefore belongs to the Game instance, not a specific Scene.\r\n *\r\n * It works in conjunction with the PluginCache. Core internal plugins automatically register themselves \r\n * with the Cache, but it's the Plugin Manager that is responsible for injecting them into the Scenes.\r\n *\r\n * There are two types of plugin:\r\n *\r\n * 1. A Global Plugin\r\n * 2. A Scene Plugin\r\n *\r\n * A Global Plugin is a plugin that lives within the Plugin Manager rather than a Scene. You can get\r\n * access to it by calling `PluginManager.get` and providing a key. Any Scene that requests a plugin in\r\n * this way will all get access to the same plugin instance, allowing you to use a single plugin across\r\n * multiple Scenes.\r\n *\r\n * A Scene Plugin is a plugin dedicated to running within a Scene. These are different to Global Plugins\r\n * in that their instances do not live within the Plugin Manager, but within the Scene Systems class instead.\r\n * And that every Scene created is given its own unique instance of a Scene Plugin. Examples of core Scene\r\n * Plugins include the Input Plugin, the Tween Plugin and the physics Plugins.\r\n *\r\n * You can add a plugin to Phaser in three different ways:\r\n *\r\n * 1. Preload it\r\n * 2. Include it in your source code and install it via the Game Config\r\n * 3. Include it in your source code and install it within a Scene\r\n *\r\n * For examples of all of these approaches please see the Phaser 3 Examples Repo `plugins` folder.\r\n *\r\n * For information on creating your own plugin please see the Phaser 3 Plugin Template.\r\n *\r\n * @class PluginManager\r\n * @memberof Phaser.Plugins\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The game instance that owns this Plugin Manager.\r\n */\n\n\nvar PluginManager = new Class({\n  Extends: EventEmitter,\n  initialize: function PluginManager(game) {\n    EventEmitter.call(this);\n    /**\r\n     * The game instance that owns this Plugin Manager.\r\n     *\r\n     * @name Phaser.Plugins.PluginManager#game\r\n     * @type {Phaser.Game}\r\n     * @since 3.0.0\r\n     */\n\n    this.game = game;\n    /**\r\n     * The global plugins currently running and managed by this Plugin Manager.\r\n     * A plugin must have been started at least once in order to appear in this list.\r\n     *\r\n     * @name Phaser.Plugins.PluginManager#plugins\r\n     * @type {GlobalPlugin[]}\r\n     * @since 3.8.0\r\n     */\n\n    this.plugins = [];\n    /**\r\n     * A list of plugin keys that should be installed into Scenes as well as the Core Plugins.\r\n     *\r\n     * @name Phaser.Plugins.PluginManager#scenePlugins\r\n     * @type {string[]}\r\n     * @since 3.8.0\r\n     */\n\n    this.scenePlugins = [];\n    /**\r\n     * A temporary list of plugins to install when the game has booted.\r\n     *\r\n     * @name Phaser.Plugins.PluginManager#_pendingGlobal\r\n     * @private\r\n     * @type {array}\r\n     * @since 3.8.0\r\n     */\n\n    this._pendingGlobal = [];\n    /**\r\n     * A temporary list of scene plugins to install when the game has booted.\r\n     *\r\n     * @name Phaser.Plugins.PluginManager#_pendingScene\r\n     * @private\r\n     * @type {array}\r\n     * @since 3.8.0\r\n     */\n\n    this._pendingScene = [];\n\n    if (game.isBooted) {\n      this.boot();\n    } else {\n      game.events.once(GameEvents.BOOT, this.boot, this);\n    }\n  },\n\n  /**\r\n   * Run once the game has booted and installs all of the plugins configured in the Game Config.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#boot\r\n   * @protected\r\n   * @since 3.0.0\r\n   */\n  boot: function boot() {\n    var i;\n    var entry;\n    var key;\n    var plugin;\n    var start;\n    var mapping;\n    var data;\n    var config = this.game.config; //  Any plugins to install?\n\n    var list = config.installGlobalPlugins; //  Any plugins added outside of the game config, but before the game booted?\n\n    list = list.concat(this._pendingGlobal);\n\n    for (i = 0; i < list.length; i++) {\n      entry = list[i]; // { key: 'TestPlugin', plugin: TestPlugin, start: true, mapping: 'test', data: { msg: 'The plugin is alive' } }\n\n      key = GetFastValue(entry, 'key', null);\n      plugin = GetFastValue(entry, 'plugin', null);\n      start = GetFastValue(entry, 'start', false);\n      mapping = GetFastValue(entry, 'mapping', null);\n      data = GetFastValue(entry, 'data', null);\n\n      if (key && plugin) {\n        this.install(key, plugin, start, mapping, data);\n      }\n    } //  Any scene plugins to install?\n\n\n    list = config.installScenePlugins; //  Any plugins added outside of the game config, but before the game booted?\n\n    list = list.concat(this._pendingScene);\n\n    for (i = 0; i < list.length; i++) {\n      entry = list[i]; // { key: 'moveSpritePlugin', plugin: MoveSpritePlugin, , mapping: 'move' }\n\n      key = GetFastValue(entry, 'key', null);\n      plugin = GetFastValue(entry, 'plugin', null);\n      mapping = GetFastValue(entry, 'mapping', null);\n\n      if (key && plugin) {\n        this.installScenePlugin(key, plugin, mapping);\n      }\n    }\n\n    this._pendingGlobal = [];\n    this._pendingScene = [];\n    this.game.events.once(GameEvents.DESTROY, this.destroy, this);\n  },\n\n  /**\r\n   * Called by the Scene Systems class. Tells the plugin manager to install all Scene plugins into it.\r\n   *\r\n   * First it will install global references, i.e. references from the Game systems into the Scene Systems (and Scene if mapped.)\r\n   * Then it will install Core Scene Plugins followed by Scene Plugins registered with the PluginManager.\r\n   * Finally it will install any references to Global Plugins that have a Scene mapping property into the Scene itself.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#addToScene\r\n   * @protected\r\n   * @since 3.8.0\r\n   *\r\n   * @param {Phaser.Scenes.Systems} sys - The Scene Systems class to install all the plugins in to.\r\n   * @param {array} globalPlugins - An array of global plugins to install.\r\n   * @param {array} scenePlugins - An array of scene plugins to install.\r\n   */\n  addToScene: function addToScene(sys, globalPlugins, scenePlugins) {\n    var i;\n    var pluginKey;\n    var pluginList;\n    var game = this.game;\n    var scene = sys.scene;\n    var map = sys.settings.map;\n    var isBooted = sys.settings.isBooted; //  Reference the GlobalPlugins from Game into Scene.Systems\n\n    for (i = 0; i < globalPlugins.length; i++) {\n      pluginKey = globalPlugins[i];\n\n      if (game[pluginKey]) {\n        sys[pluginKey] = game[pluginKey]; //  Scene level injection\n\n        if (map.hasOwnProperty(pluginKey)) {\n          scene[map[pluginKey]] = sys[pluginKey];\n        }\n      } else if (pluginKey === 'game' && map.hasOwnProperty(pluginKey)) {\n        scene[map[pluginKey]] = game;\n      }\n    }\n\n    for (var s = 0; s < scenePlugins.length; s++) {\n      pluginList = scenePlugins[s];\n\n      for (i = 0; i < pluginList.length; i++) {\n        pluginKey = pluginList[i];\n\n        if (!PluginCache.hasCore(pluginKey)) {\n          continue;\n        }\n\n        var source = PluginCache.getCore(pluginKey);\n        var plugin = new source.plugin(scene, this);\n        sys[source.mapping] = plugin; //  Scene level injection\n\n        if (source.custom) {\n          scene[source.mapping] = plugin;\n        } else if (map.hasOwnProperty(source.mapping)) {\n          scene[map[source.mapping]] = plugin;\n        } //  Scene is already booted, usually because this method is being called at run-time, so boot the plugin\n\n\n        if (isBooted) {\n          plugin.boot();\n        }\n      }\n    } //  And finally, inject any 'global scene plugins'\n\n\n    pluginList = this.plugins;\n\n    for (i = 0; i < pluginList.length; i++) {\n      var entry = pluginList[i];\n\n      if (entry.mapping) {\n        scene[entry.mapping] = entry.plugin;\n      }\n    }\n  },\n\n  /**\r\n   * Called by the Scene Systems class. Returns a list of plugins to be installed.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#getDefaultScenePlugins\r\n   * @protected\r\n   * @since 3.8.0\r\n   *\r\n   * @return {string[]} A list keys of all the Scene Plugins to install.\r\n   */\n  getDefaultScenePlugins: function getDefaultScenePlugins() {\n    var list = this.game.config.defaultPlugins; //  Merge in custom Scene plugins\n\n    list = list.concat(this.scenePlugins);\n    return list;\n  },\n\n  /**\r\n   * Installs a new Scene Plugin into the Plugin Manager and optionally adds it\r\n   * to the given Scene as well. A Scene Plugin added to the manager in this way\r\n   * will be automatically installed into all new Scenes using the key and mapping given.\r\n   *\r\n   * The `key` property is what the plugin is injected into Scene.Systems as.\r\n   * The `mapping` property is optional, and if specified is what the plugin is installed into\r\n   * the Scene as. For example:\r\n   *\r\n   * ```javascript\r\n   * this.plugins.installScenePlugin('powerupsPlugin', pluginCode, 'powerups');\r\n   * \r\n   * // and from within the scene:\r\n   * this.sys.powerupsPlugin; // key value\r\n   * this.powerups; // mapping value\r\n   * ```\r\n   *\r\n   * This method is called automatically by Phaser if you install your plugins using either the\r\n   * Game Configuration object, or by preloading them via the Loader.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#installScenePlugin\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The property key that will be used to add this plugin to Scene.Systems.\r\n   * @param {function} plugin - The plugin code. This should be the non-instantiated version.\r\n   * @param {string} [mapping] - If this plugin is injected into the Phaser.Scene class, this is the property key to use.\r\n   * @param {Phaser.Scene} [addToScene] - Optionally automatically add this plugin to the given Scene.\r\n   */\n  installScenePlugin: function installScenePlugin(key, plugin, mapping, addToScene) {\n    if (typeof plugin !== 'function') {\n      console.warn('Invalid Scene Plugin: ' + key);\n      return;\n    }\n\n    if (PluginCache.hasCore(key)) {\n      console.warn('Scene Plugin key in use: ' + key);\n      return;\n    }\n\n    PluginCache.register(key, plugin, mapping, true);\n    this.scenePlugins.push(key);\n\n    if (addToScene) {\n      var instance = new plugin(addToScene, this);\n      addToScene.sys[key] = instance;\n\n      if (mapping && mapping !== '') {\n        addToScene[mapping] = instance;\n      }\n\n      instance.boot();\n    }\n  },\n\n  /**\r\n   * Installs a new Global Plugin into the Plugin Manager and optionally starts it running.\r\n   * A global plugin belongs to the Plugin Manager, rather than a specific Scene, and can be accessed\r\n   * and used by all Scenes in your game.\r\n   *\r\n   * The `key` property is what you use to access this plugin from the Plugin Manager.\r\n   *\r\n   * ```javascript\r\n   * this.plugins.install('powerupsPlugin', pluginCode);\r\n   * \r\n   * // and from within the scene:\r\n   * this.plugins.get('powerupsPlugin');\r\n   * ```\r\n   *\r\n   * This method is called automatically by Phaser if you install your plugins using either the\r\n   * Game Configuration object, or by preloading them via the Loader.\r\n   *\r\n   * The same plugin can be installed multiple times into the Plugin Manager by simply giving each\r\n   * instance its own unique key.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#install\r\n   * @since 3.8.0\r\n   * \r\n   * @param {string} key - The unique handle given to this plugin within the Plugin Manager.\r\n   * @param {function} plugin - The plugin code. This should be the non-instantiated version.\r\n   * @param {boolean} [start=false] - Automatically start the plugin running? This is always `true` if you provide a mapping value.\r\n   * @param {string} [mapping] - If this plugin is injected into the Phaser.Scene class, this is the property key to use.\r\n   * @param {any} [data] - A value passed to the plugin's `init` method.\r\n   *\r\n   * @return {?Phaser.Plugins.BasePlugin} The plugin that was started, or `null` if `start` was false, or game isn't yet booted.\r\n   */\n  install: function install(key, plugin, start, mapping, data) {\n    if (start === undefined) {\n      start = false;\n    }\n\n    if (mapping === undefined) {\n      mapping = null;\n    }\n\n    if (data === undefined) {\n      data = null;\n    }\n\n    if (typeof plugin !== 'function') {\n      console.warn('Invalid Plugin: ' + key);\n      return null;\n    }\n\n    if (PluginCache.hasCustom(key)) {\n      console.warn('Plugin key in use: ' + key);\n      return null;\n    }\n\n    if (mapping !== null) {\n      start = true;\n    }\n\n    if (!this.game.isBooted) {\n      this._pendingGlobal.push({\n        key: key,\n        plugin: plugin,\n        start: start,\n        mapping: mapping,\n        data: data\n      });\n    } else {\n      //  Add it to the plugin store\n      PluginCache.registerCustom(key, plugin, mapping, data);\n\n      if (start) {\n        return this.start(key);\n      }\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Gets an index of a global plugin based on the given key.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#getIndex\r\n   * @protected\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The unique plugin key.\r\n   *\r\n   * @return {integer} The index of the plugin within the plugins array.\r\n   */\n  getIndex: function getIndex(key) {\n    var list = this.plugins;\n\n    for (var i = 0; i < list.length; i++) {\n      var entry = list[i];\n\n      if (entry.key === key) {\n        return i;\n      }\n    }\n\n    return -1;\n  },\n\n  /**\r\n   * Gets a global plugin based on the given key.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#getEntry\r\n   * @protected\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The unique plugin key.\r\n   *\r\n   * @return {GlobalPlugin} The plugin entry.\r\n   */\n  getEntry: function getEntry(key) {\n    var idx = this.getIndex(key);\n\n    if (idx !== -1) {\n      return this.plugins[idx];\n    }\n  },\n\n  /**\r\n   * Checks if the given global plugin, based on its key, is active or not.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#isActive\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The unique plugin key.\r\n   *\r\n   * @return {boolean} `true` if the plugin is active, otherwise `false`.\r\n   */\n  isActive: function isActive(key) {\n    var entry = this.getEntry(key);\n    return entry && entry.active;\n  },\n\n  /**\r\n   * Starts a global plugin running.\r\n   *\r\n   * If the plugin was previously active then calling `start` will reset it to an active state and then\r\n   * call its `start` method.\r\n   *\r\n   * If the plugin has never been run before a new instance of it will be created within the Plugin Manager,\r\n   * its active state set and then both of its `init` and `start` methods called, in that order.\r\n   *\r\n   * If the plugin is already running under the given key then nothing happens.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#start\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the plugin to start.\r\n   * @param {string} [runAs] - Run the plugin under a new key. This allows you to run one plugin multiple times.\r\n   *\r\n   * @return {?Phaser.Plugins.BasePlugin} The plugin that was started, or `null` if invalid key given or plugin is already stopped.\r\n   */\n  start: function start(key, runAs) {\n    if (runAs === undefined) {\n      runAs = key;\n    }\n\n    var entry = this.getEntry(runAs); //  Plugin already running under this key?\n\n    if (entry && !entry.active) {\n      //  It exists, we just need to start it up again\n      entry.active = true;\n      entry.plugin.start();\n    } else if (!entry) {\n      entry = this.createEntry(key, runAs);\n    }\n\n    return entry ? entry.plugin : null;\n  },\n\n  /**\r\n   * Creates a new instance of a global plugin, adds an entry into the plugins array and returns it.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#createEntry\r\n   * @private\r\n   * @since 3.9.0\r\n   *\r\n   * @param {string} key - The key of the plugin to create an instance of.\r\n   * @param {string} [runAs] - Run the plugin under a new key. This allows you to run one plugin multiple times.\r\n   *\r\n   * @return {?Phaser.Plugins.BasePlugin} The plugin that was started, or `null` if invalid key given.\r\n   */\n  createEntry: function createEntry(key, runAs) {\n    var entry = PluginCache.getCustom(key);\n\n    if (entry) {\n      var instance = new entry.plugin(this);\n      entry = {\n        key: runAs,\n        plugin: instance,\n        active: true,\n        mapping: entry.mapping,\n        data: entry.data\n      };\n      this.plugins.push(entry);\n      instance.init(entry.data);\n      instance.start();\n    }\n\n    return entry;\n  },\n\n  /**\r\n   * Stops a global plugin from running.\r\n   *\r\n   * If the plugin is active then its active state will be set to false and the plugins `stop` method\r\n   * will be called.\r\n   *\r\n   * If the plugin is not already running, nothing will happen.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#stop\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the plugin to stop.\r\n   *\r\n   * @return {Phaser.Plugins.PluginManager} The Plugin Manager.\r\n   */\n  stop: function stop(key) {\n    var entry = this.getEntry(key);\n\n    if (entry && entry.active) {\n      entry.active = false;\n      entry.plugin.stop();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Gets a global plugin from the Plugin Manager based on the given key and returns it.\r\n   *\r\n   * If it cannot find an active plugin based on the key, but there is one in the Plugin Cache with the same key,\r\n   * then it will create a new instance of the cached plugin and return that.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#get\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the plugin to get.\r\n   * @param {boolean} [autoStart=true] - Automatically start a new instance of the plugin if found in the cache, but not actively running.\r\n   *\r\n   * @return {?(Phaser.Plugins.BasePlugin|function)} The plugin, or `null` if no plugin was found matching the key.\r\n   */\n  get: function get(key, autoStart) {\n    if (autoStart === undefined) {\n      autoStart = true;\n    }\n\n    var entry = this.getEntry(key);\n\n    if (entry) {\n      return entry.plugin;\n    } else {\n      var plugin = this.getClass(key);\n\n      if (plugin && autoStart) {\n        entry = this.createEntry(key, key);\n        return entry ? entry.plugin : null;\n      } else if (plugin) {\n        return plugin;\n      }\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Returns the plugin class from the cache.\r\n   * Used internally by the Plugin Manager.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#getClass\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the plugin to get.\r\n   *\r\n   * @return {Phaser.Plugins.BasePlugin} A Plugin object\r\n   */\n  getClass: function getClass(key) {\n    return PluginCache.getCustomClass(key);\n  },\n\n  /**\r\n   * Removes a global plugin from the Plugin Manager and Plugin Cache.\r\n   *\r\n   * It is up to you to remove all references to this plugin that you may hold within your game code.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#removeGlobalPlugin\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the plugin to remove.\r\n   */\n  removeGlobalPlugin: function removeGlobalPlugin(key) {\n    var entry = this.getEntry(key);\n\n    if (entry) {\n      Remove(this.plugins, entry);\n    }\n\n    PluginCache.removeCustom(key);\n  },\n\n  /**\r\n   * Removes a scene plugin from the Plugin Manager and Plugin Cache.\r\n   *\r\n   * This will not remove the plugin from any active Scenes that are already using it.\r\n   *\r\n   * It is up to you to remove all references to this plugin that you may hold within your game code.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#removeScenePlugin\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the plugin to remove.\r\n   */\n  removeScenePlugin: function removeScenePlugin(key) {\n    Remove(this.scenePlugins, key);\n    PluginCache.remove(key);\n  },\n\n  /**\r\n   * Registers a new type of Game Object with the global Game Object Factory and / or Creator.\r\n   * This is usually called from within your Plugin code and is a helpful short-cut for creating\r\n   * new Game Objects.\r\n   *\r\n   * The key is the property that will be injected into the factories and used to create the\r\n   * Game Object. For example:\r\n   *\r\n   * ```javascript\r\n   * this.plugins.registerGameObject('clown', clownFactoryCallback, clownCreatorCallback);\r\n   * // later in your game code:\r\n   * this.add.clown();\r\n   * this.make.clown();\r\n   * ```\r\n   * \r\n   * The callbacks are what are called when the factories try to create a Game Object\r\n   * matching the given key. It's important to understand that the callbacks are invoked within\r\n   * the context of the GameObjectFactory. In this context there are several properties available\r\n   * to use:\r\n   * \r\n   * this.scene - A reference to the Scene that owns the GameObjectFactory.\r\n   * this.displayList - A reference to the Display List the Scene owns.\r\n   * this.updateList - A reference to the Update List the Scene owns.\r\n   * \r\n   * See the GameObjectFactory and GameObjectCreator classes for more details.\r\n   * Any public property or method listed is available from your callbacks under `this`.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#registerGameObject\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the Game Object that the given callbacks will create, i.e. `image`, `sprite`.\r\n   * @param {function} [factoryCallback] - The callback to invoke when the Game Object Factory is called.\r\n   * @param {function} [creatorCallback] - The callback to invoke when the Game Object Creator is called.\r\n   */\n  registerGameObject: function registerGameObject(key, factoryCallback, creatorCallback) {\n    if (factoryCallback) {\n      GameObjectFactory.register(key, factoryCallback);\n    }\n\n    if (creatorCallback) {\n      GameObjectCreator.register(key, creatorCallback);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Registers a new file type with the global File Types Manager, making it available to all Loader\r\n   * Plugins created after this.\r\n   * \r\n   * This is usually called from within your Plugin code and is a helpful short-cut for creating\r\n   * new loader file types.\r\n   *\r\n   * The key is the property that will be injected into the Loader Plugin and used to load the\r\n   * files. For example:\r\n   *\r\n   * ```javascript\r\n   * this.plugins.registerFileType('wad', doomWadLoaderCallback);\r\n   * // later in your preload code:\r\n   * this.load.wad();\r\n   * ```\r\n   * \r\n   * The callback is what is called when the loader tries to load a file  matching the given key.\r\n   * It's important to understand that the callback is invoked within\r\n   * the context of the LoaderPlugin. In this context there are several properties / methods available\r\n   * to use:\r\n   * \r\n   * this.addFile - A method to add the new file to the load queue.\r\n   * this.scene - The Scene that owns the Loader Plugin instance.\r\n   *\r\n   * See the LoaderPlugin class for more details. Any public property or method listed is available from\r\n   * your callback under `this`.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#registerFileType\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the Game Object that the given callbacks will create, i.e. `image`, `sprite`.\r\n   * @param {function} callback - The callback to invoke when the Game Object Factory is called.\r\n   * @param {Phaser.Scene} [addToScene] - Optionally add this file type into the Loader Plugin owned by the given Scene.\r\n   */\n  registerFileType: function registerFileType(key, callback, addToScene) {\n    FileTypesManager.register(key, callback);\n\n    if (addToScene && addToScene.sys.load) {\n      addToScene.sys.load[key] = callback;\n    }\n  },\n\n  /**\r\n   * Destroys this Plugin Manager and all associated plugins.\r\n   * It will iterate all plugins found and call their `destroy` methods.\r\n   * \r\n   * The PluginCache will remove all custom plugins.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#destroy\r\n   * @since 3.8.0\r\n   */\n  destroy: function destroy() {\n    for (var i = 0; i < this.plugins.length; i++) {\n      this.plugins[i].plugin.destroy();\n    }\n\n    PluginCache.destroyCustomPlugins();\n\n    if (this.game.noReturn) {\n      PluginCache.destroyCorePlugins();\n    }\n\n    this.game = null;\n    this.plugins = [];\n    this.scenePlugins = [];\n  }\n});\n/*\r\n * \"Sometimes, the elegant implementation is just a function.\r\n * Not a method. Not a class. Not a framework. Just a function.\"\r\n *  -- John Carmack\r\n */\n\nmodule.exports = PluginManager;","map":null,"metadata":{},"sourceType":"script"}