{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Bodies = require('./lib/factory/Bodies');\n\nvar Body = require('./lib/body/Body');\n\nvar Class = require('../../utils/Class');\n\nvar Components = require('./components');\n\nvar GetFastValue = require('../../utils/object/GetFastValue');\n\nvar HasValue = require('../../utils/object/HasValue');\n\nvar Vertices = require('./lib/geometry/Vertices');\n/**\r\n * @typedef {object} MatterTileOptions\r\n * \r\n * @property {MatterJS.Body} [body=null] - An existing Matter body to be used instead of creating a new one.\r\n * @property {boolean} [isStatic=true] - Whether or not the newly created body should be made static. This defaults to true since typically tiles should not be moved.\r\n * @property {boolean} [addToWorld=true] - Whether or not to add the newly created body (or existing body if options.body is used) to the Matter world.\r\n */\n\n/**\r\n * @classdesc\r\n * A wrapper around a Tile that provides access to a corresponding Matter body. A tile can only\r\n * have one Matter body associated with it. You can either pass in an existing Matter body for\r\n * the tile or allow the constructor to create the corresponding body for you. If the Tile has a\r\n * collision group (defined in Tiled), those shapes will be used to create the body. If not, the\r\n * tile's rectangle bounding box will be used.\r\n *\r\n * The corresponding body will be accessible on the Tile itself via Tile.physics.matterBody.\r\n *\r\n * Note: not all Tiled collision shapes are supported. See\r\n * Phaser.Physics.Matter.TileBody#setFromTileCollision for more information.\r\n *\r\n * @class TileBody\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Matter.Components.Bounce\r\n * @extends Phaser.Physics.Matter.Components.Collision\r\n * @extends Phaser.Physics.Matter.Components.Friction\r\n * @extends Phaser.Physics.Matter.Components.Gravity\r\n * @extends Phaser.Physics.Matter.Components.Mass\r\n * @extends Phaser.Physics.Matter.Components.Sensor\r\n * @extends Phaser.Physics.Matter.Components.Sleep\r\n * @extends Phaser.Physics.Matter.Components.Static\r\n *\r\n * @param {Phaser.Physics.Matter.World} world - [description]\r\n * @param {Phaser.Tilemaps.Tile} tile - The target tile that should have a Matter body.\r\n * @param {MatterTileOptions} [options] - Options to be used when creating the Matter body.\r\n */\n\n\nvar MatterTileBody = new Class({\n  Mixins: [Components.Bounce, Components.Collision, Components.Friction, Components.Gravity, Components.Mass, Components.Sensor, Components.Sleep, Components.Static],\n  initialize: function MatterTileBody(world, tile, options) {\n    /**\r\n     * The tile object the body is associated with.\r\n     *\r\n     * @name Phaser.Physics.Matter.TileBody#tile\r\n     * @type {Phaser.Tilemaps.Tile}\r\n     * @since 3.0.0\r\n     */\n    this.tile = tile;\n    /**\r\n     * The Matter world the body exists within.\r\n     *\r\n     * @name Phaser.Physics.Matter.TileBody#world\r\n     * @type {Phaser.Physics.Matter.World}\r\n     * @since 3.0.0\r\n     */\n\n    this.world = world; // Install a reference to 'this' on the tile and ensure there can only be one matter body\n    // associated with the tile\n\n    if (tile.physics.matterBody) {\n      tile.physics.matterBody.destroy();\n    }\n\n    tile.physics.matterBody = this; // Set the body either from an existing body (if provided), the shapes in the tileset\n    // collision layer (if it exists) or a rectangle matching the tile.\n\n    var body = GetFastValue(options, 'body', null);\n    var addToWorld = GetFastValue(options, 'addToWorld', true);\n\n    if (!body) {\n      var collisionGroup = tile.getCollisionGroup();\n      var collisionObjects = GetFastValue(collisionGroup, 'objects', []);\n\n      if (collisionObjects.length > 0) {\n        this.setFromTileCollision(options);\n      } else {\n        this.setFromTileRectangle(options);\n      }\n    } else {\n      this.setBody(body, addToWorld);\n    }\n  },\n\n  /**\r\n   * @typedef {object} MatterBodyTileOptions\r\n   * \r\n   * @property {boolean} [isStatic=true] - Whether or not the newly created body should be made static. This defaults to true since typically tiles should not be moved.\r\n   * @property {boolean} [addToWorld=true] - Whether or not to add the newly created body (or existing body if options.body is used) to the Matter world.\r\n   */\n\n  /**\r\n   * Sets the current body to a rectangle that matches the bounds of the tile.\r\n   *\r\n   * @method Phaser.Physics.Matter.TileBody#setFromTileRectangle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {MatterBodyTileOptions} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.\r\n   * \r\n   * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n   */\n  setFromTileRectangle: function setFromTileRectangle(options) {\n    if (options === undefined) {\n      options = {};\n    }\n\n    if (!HasValue(options, 'isStatic')) {\n      options.isStatic = true;\n    }\n\n    if (!HasValue(options, 'addToWorld')) {\n      options.addToWorld = true;\n    }\n\n    var bounds = this.tile.getBounds();\n    var cx = bounds.x + bounds.width / 2;\n    var cy = bounds.y + bounds.height / 2;\n    var body = Bodies.rectangle(cx, cy, bounds.width, bounds.height, options);\n    this.setBody(body, options.addToWorld);\n    return this;\n  },\n\n  /**\r\n   * Sets the current body from the collision group associated with the Tile. This is typically\r\n   * set up in Tiled's collision editor.\r\n   *\r\n   * Note: Matter doesn't support all shapes from Tiled. Rectangles and polygons are directly\r\n   * supported. Ellipses are converted into circle bodies. Polylines are treated as if they are\r\n   * closed polygons. If a tile has multiple shapes, a multi-part body will be created. Concave\r\n   * shapes are supported if poly-decomp library is included. Decomposition is not guaranteed to\r\n   * work for complex shapes (e.g. holes), so it's often best to manually decompose a concave\r\n   * polygon into multiple convex polygons yourself.\r\n   *\r\n   * @method Phaser.Physics.Matter.TileBody#setFromTileCollision\r\n   * @since 3.0.0\r\n   *\r\n   * @param {MatterBodyTileOptions} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.\r\n   * \r\n   * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n   */\n  setFromTileCollision: function setFromTileCollision(options) {\n    if (options === undefined) {\n      options = {};\n    }\n\n    if (!HasValue(options, 'isStatic')) {\n      options.isStatic = true;\n    }\n\n    if (!HasValue(options, 'addToWorld')) {\n      options.addToWorld = true;\n    }\n\n    var sx = this.tile.tilemapLayer.scaleX;\n    var sy = this.tile.tilemapLayer.scaleY;\n    var tileX = this.tile.getLeft();\n    var tileY = this.tile.getTop();\n    var collisionGroup = this.tile.getCollisionGroup();\n    var collisionObjects = GetFastValue(collisionGroup, 'objects', []);\n    var parts = [];\n\n    for (var i = 0; i < collisionObjects.length; i++) {\n      var object = collisionObjects[i];\n      var ox = tileX + object.x * sx;\n      var oy = tileY + object.y * sy;\n      var ow = object.width * sx;\n      var oh = object.height * sy;\n      var body = null;\n\n      if (object.rectangle) {\n        body = Bodies.rectangle(ox + ow / 2, oy + oh / 2, ow, oh, options);\n      } else if (object.ellipse) {\n        body = Bodies.circle(ox + ow / 2, oy + oh / 2, ow / 2, options);\n      } else if (object.polygon || object.polyline) {\n        // Polygons and polylines are both treated as closed polygons\n        var originalPoints = object.polygon ? object.polygon : object.polyline;\n        var points = originalPoints.map(function (p) {\n          return {\n            x: p.x * sx,\n            y: p.y * sy\n          };\n        });\n        var vertices = Vertices.create(points); // Points are relative to the object's origin (first point placed in Tiled), but\n        // matter expects points to be relative to the center of mass. This only applies to\n        // convex shapes. When a concave shape is decomposed, multiple parts are created and\n        // the individual parts are positioned relative to (ox, oy).\n        //\n        //  Update: 8th January 2019 - the latest version of Matter needs the Vertices adjusted,\n        //  regardless if convex or concave.\n\n        var center = Vertices.centre(vertices);\n        ox += center.x;\n        oy += center.y;\n        body = Bodies.fromVertices(ox, oy, vertices, options);\n      }\n\n      if (body) {\n        parts.push(body);\n      }\n    }\n\n    if (parts.length === 1) {\n      this.setBody(parts[0], options.addToWorld);\n    } else if (parts.length > 1) {\n      options.parts = parts;\n      this.setBody(Body.create(options), options.addToWorld);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the current body to the given body. This will remove the previous body, if one already\r\n   * exists.\r\n   *\r\n   * @method Phaser.Physics.Matter.TileBody#setBody\r\n   * @since 3.0.0\r\n   *\r\n   * @param {MatterJS.Body} body - The new Matter body to use.\r\n   * @param {boolean} [addToWorld=true] - Whether or not to add the body to the Matter world.\r\n   * \r\n   * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n   */\n  setBody: function setBody(body, addToWorld) {\n    if (addToWorld === undefined) {\n      addToWorld = true;\n    }\n\n    if (this.body) {\n      this.removeBody();\n    }\n\n    this.body = body;\n    this.body.gameObject = this;\n\n    if (addToWorld) {\n      this.world.add(this.body);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes the current body from the TileBody and from the Matter world\r\n   *\r\n   * @method Phaser.Physics.Matter.TileBody#removeBody\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n   */\n  removeBody: function removeBody() {\n    if (this.body) {\n      this.world.remove(this.body);\n      this.body.gameObject = undefined;\n      this.body = undefined;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes the current body from the tile and the world.\r\n   *\r\n   * @method Phaser.Physics.Matter.TileBody#destroy\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n   */\n  destroy: function destroy() {\n    this.removeBody();\n    this.tile.physics.matterBody = undefined;\n  }\n});\nmodule.exports = MatterTileBody;","map":null,"metadata":{},"sourceType":"script"}