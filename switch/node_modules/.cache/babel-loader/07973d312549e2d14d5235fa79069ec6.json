{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\nvar Class = require('../utils/Class');\n\nvar EPSILON = 0.000001;\n/**\r\n * @classdesc\r\n * A four-dimensional matrix.\r\n *\r\n * @class Matrix4\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Matrix4} [m] - Optional Matrix4 to copy values from.\r\n */\n\nvar Matrix4 = new Class({\n  initialize: function Matrix4(m) {\n    /**\r\n     * The matrix values.\r\n     *\r\n     * @name Phaser.Math.Matrix4#val\r\n     * @type {Float32Array}\r\n     * @since 3.0.0\r\n     */\n    this.val = new Float32Array(16);\n\n    if (m) {\n      //  Assume Matrix4 with val:\n      this.copy(m);\n    } else {\n      //  Default to identity\n      this.identity();\n    }\n  },\n\n  /**\r\n   * Make a clone of this Matrix4.\r\n   *\r\n   * @method Phaser.Math.Matrix4#clone\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Matrix4} A clone of this Matrix4.\r\n   */\n  clone: function clone() {\n    return new Matrix4(this);\n  },\n  //  TODO - Should work with basic values\n\n  /**\r\n   * This method is an alias for `Matrix4.copy`.\r\n   *\r\n   * @method Phaser.Math.Matrix4#set\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Matrix4} src - The Matrix to set the values of this Matrix's from.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  set: function set(src) {\n    return this.copy(src);\n  },\n\n  /**\r\n   * Copy the values of a given Matrix into this Matrix.\r\n   *\r\n   * @method Phaser.Math.Matrix4#copy\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Matrix4} src - The Matrix to copy the values from.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  copy: function copy(src) {\n    var out = this.val;\n    var a = src.val;\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return this;\n  },\n\n  /**\r\n   * Set the values of this Matrix from the given array.\r\n   *\r\n   * @method Phaser.Math.Matrix4#fromArray\r\n   * @since 3.0.0\r\n   *\r\n   * @param {array} a - The array to copy the values from.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  fromArray: function fromArray(a) {\n    var out = this.val;\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return this;\n  },\n\n  /**\r\n   * Reset this Matrix.\r\n   *\r\n   * Sets all values to `0`.\r\n   *\r\n   * @method Phaser.Math.Matrix4#zero\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  zero: function zero() {\n    var out = this.val;\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 0;\n    return this;\n  },\n\n  /**\r\n   * Set the `x`, `y` and `z` values of this Matrix.\r\n   *\r\n   * @method Phaser.Math.Matrix4#xyz\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The x value.\r\n   * @param {number} y - The y value.\r\n   * @param {number} z - The z value.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  xyz: function xyz(x, y, z) {\n    this.identity();\n    var out = this.val;\n    out[12] = x;\n    out[13] = y;\n    out[14] = z;\n    return this;\n  },\n\n  /**\r\n   * Set the scaling values of this Matrix.\r\n   *\r\n   * @method Phaser.Math.Matrix4#scaling\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The x scaling value.\r\n   * @param {number} y - The y scaling value.\r\n   * @param {number} z - The z scaling value.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  scaling: function scaling(x, y, z) {\n    this.zero();\n    var out = this.val;\n    out[0] = x;\n    out[5] = y;\n    out[10] = z;\n    out[15] = 1;\n    return this;\n  },\n\n  /**\r\n   * Reset this Matrix to an identity (default) matrix.\r\n   *\r\n   * @method Phaser.Math.Matrix4#identity\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  identity: function identity() {\n    var out = this.val;\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return this;\n  },\n\n  /**\r\n   * Transpose this Matrix.\r\n   *\r\n   * @method Phaser.Math.Matrix4#transpose\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  transpose: function transpose() {\n    var a = this.val;\n    var a01 = a[1];\n    var a02 = a[2];\n    var a03 = a[3];\n    var a12 = a[6];\n    var a13 = a[7];\n    var a23 = a[11];\n    a[1] = a[4];\n    a[2] = a[8];\n    a[3] = a[12];\n    a[4] = a01;\n    a[6] = a[9];\n    a[7] = a[13];\n    a[8] = a02;\n    a[9] = a12;\n    a[11] = a[14];\n    a[12] = a03;\n    a[13] = a13;\n    a[14] = a23;\n    return this;\n  },\n\n  /**\r\n   * Invert this Matrix.\r\n   *\r\n   * @method Phaser.Math.Matrix4#invert\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  invert: function invert() {\n    var a = this.val;\n    var a00 = a[0];\n    var a01 = a[1];\n    var a02 = a[2];\n    var a03 = a[3];\n    var a10 = a[4];\n    var a11 = a[5];\n    var a12 = a[6];\n    var a13 = a[7];\n    var a20 = a[8];\n    var a21 = a[9];\n    var a22 = a[10];\n    var a23 = a[11];\n    var a30 = a[12];\n    var a31 = a[13];\n    var a32 = a[14];\n    var a33 = a[15];\n    var b00 = a00 * a11 - a01 * a10;\n    var b01 = a00 * a12 - a02 * a10;\n    var b02 = a00 * a13 - a03 * a10;\n    var b03 = a01 * a12 - a02 * a11;\n    var b04 = a01 * a13 - a03 * a11;\n    var b05 = a02 * a13 - a03 * a12;\n    var b06 = a20 * a31 - a21 * a30;\n    var b07 = a20 * a32 - a22 * a30;\n    var b08 = a20 * a33 - a23 * a30;\n    var b09 = a21 * a32 - a22 * a31;\n    var b10 = a21 * a33 - a23 * a31;\n    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) {\n      return null;\n    }\n\n    det = 1 / det;\n    a[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    a[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    a[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    a[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n    a[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    a[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    a[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    a[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n    a[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n    a[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n    a[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n    a[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n    a[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n    a[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n    a[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n    a[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n    return this;\n  },\n\n  /**\r\n   * Calculate the adjoint, or adjugate, of this Matrix.\r\n   *\r\n   * @method Phaser.Math.Matrix4#adjoint\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  adjoint: function adjoint() {\n    var a = this.val;\n    var a00 = a[0];\n    var a01 = a[1];\n    var a02 = a[2];\n    var a03 = a[3];\n    var a10 = a[4];\n    var a11 = a[5];\n    var a12 = a[6];\n    var a13 = a[7];\n    var a20 = a[8];\n    var a21 = a[9];\n    var a22 = a[10];\n    var a23 = a[11];\n    var a30 = a[12];\n    var a31 = a[13];\n    var a32 = a[14];\n    var a33 = a[15];\n    a[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n    a[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n    a[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n    a[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n    a[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n    a[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n    a[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n    a[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n    a[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n    a[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n    a[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n    a[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n    a[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n    a[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n    a[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n    a[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n    return this;\n  },\n\n  /**\r\n   * Calculate the determinant of this Matrix.\r\n   *\r\n   * @method Phaser.Math.Matrix4#determinant\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The determinant of this Matrix.\r\n   */\n  determinant: function determinant() {\n    var a = this.val;\n    var a00 = a[0];\n    var a01 = a[1];\n    var a02 = a[2];\n    var a03 = a[3];\n    var a10 = a[4];\n    var a11 = a[5];\n    var a12 = a[6];\n    var a13 = a[7];\n    var a20 = a[8];\n    var a21 = a[9];\n    var a22 = a[10];\n    var a23 = a[11];\n    var a30 = a[12];\n    var a31 = a[13];\n    var a32 = a[14];\n    var a33 = a[15];\n    var b00 = a00 * a11 - a01 * a10;\n    var b01 = a00 * a12 - a02 * a10;\n    var b02 = a00 * a13 - a03 * a10;\n    var b03 = a01 * a12 - a02 * a11;\n    var b04 = a01 * a13 - a03 * a11;\n    var b05 = a02 * a13 - a03 * a12;\n    var b06 = a20 * a31 - a21 * a30;\n    var b07 = a20 * a32 - a22 * a30;\n    var b08 = a20 * a33 - a23 * a30;\n    var b09 = a21 * a32 - a22 * a31;\n    var b10 = a21 * a33 - a23 * a31;\n    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  },\n\n  /**\r\n   * Multiply this Matrix by the given Matrix.\r\n   *\r\n   * @method Phaser.Math.Matrix4#multiply\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Matrix4} src - The Matrix to multiply this Matrix by.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  multiply: function multiply(src) {\n    var a = this.val;\n    var a00 = a[0];\n    var a01 = a[1];\n    var a02 = a[2];\n    var a03 = a[3];\n    var a10 = a[4];\n    var a11 = a[5];\n    var a12 = a[6];\n    var a13 = a[7];\n    var a20 = a[8];\n    var a21 = a[9];\n    var a22 = a[10];\n    var a23 = a[11];\n    var a30 = a[12];\n    var a31 = a[13];\n    var a32 = a[14];\n    var a33 = a[15];\n    var b = src.val; // Cache only the current line of the second matrix\n\n    var b0 = b[0];\n    var b1 = b[1];\n    var b2 = b[2];\n    var b3 = b[3];\n    a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[4];\n    b1 = b[5];\n    b2 = b[6];\n    b3 = b[7];\n    a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[8];\n    b1 = b[9];\n    b2 = b[10];\n    b3 = b[11];\n    a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[12];\n    b1 = b[13];\n    b2 = b[14];\n    b3 = b[15];\n    a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Math.Matrix4#multiplyLocal\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Matrix4} src - [description]\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  multiplyLocal: function multiplyLocal(src) {\n    var a = [];\n    var m1 = this.val;\n    var m2 = src.val;\n    a[0] = m1[0] * m2[0] + m1[1] * m2[4] + m1[2] * m2[8] + m1[3] * m2[12];\n    a[1] = m1[0] * m2[1] + m1[1] * m2[5] + m1[2] * m2[9] + m1[3] * m2[13];\n    a[2] = m1[0] * m2[2] + m1[1] * m2[6] + m1[2] * m2[10] + m1[3] * m2[14];\n    a[3] = m1[0] * m2[3] + m1[1] * m2[7] + m1[2] * m2[11] + m1[3] * m2[15];\n    a[4] = m1[4] * m2[0] + m1[5] * m2[4] + m1[6] * m2[8] + m1[7] * m2[12];\n    a[5] = m1[4] * m2[1] + m1[5] * m2[5] + m1[6] * m2[9] + m1[7] * m2[13];\n    a[6] = m1[4] * m2[2] + m1[5] * m2[6] + m1[6] * m2[10] + m1[7] * m2[14];\n    a[7] = m1[4] * m2[3] + m1[5] * m2[7] + m1[6] * m2[11] + m1[7] * m2[15];\n    a[8] = m1[8] * m2[0] + m1[9] * m2[4] + m1[10] * m2[8] + m1[11] * m2[12];\n    a[9] = m1[8] * m2[1] + m1[9] * m2[5] + m1[10] * m2[9] + m1[11] * m2[13];\n    a[10] = m1[8] * m2[2] + m1[9] * m2[6] + m1[10] * m2[10] + m1[11] * m2[14];\n    a[11] = m1[8] * m2[3] + m1[9] * m2[7] + m1[10] * m2[11] + m1[11] * m2[15];\n    a[12] = m1[12] * m2[0] + m1[13] * m2[4] + m1[14] * m2[8] + m1[15] * m2[12];\n    a[13] = m1[12] * m2[1] + m1[13] * m2[5] + m1[14] * m2[9] + m1[15] * m2[13];\n    a[14] = m1[12] * m2[2] + m1[13] * m2[6] + m1[14] * m2[10] + m1[15] * m2[14];\n    a[15] = m1[12] * m2[3] + m1[13] * m2[7] + m1[14] * m2[11] + m1[15] * m2[15];\n    return this.fromArray(a);\n  },\n\n  /**\r\n   * Translate this Matrix using the given Vector.\r\n   *\r\n   * @method Phaser.Math.Matrix4#translate\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to translate this Matrix with.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  translate: function translate(v) {\n    var x = v.x;\n    var y = v.y;\n    var z = v.z;\n    var a = this.val;\n    a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n    return this;\n  },\n\n  /**\r\n   * Translate this Matrix using the given values.\r\n   *\r\n   * @method Phaser.Math.Matrix4#translateXYZ\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} x - The x component.\r\n   * @param {number} y - The y component.\r\n   * @param {number} z - The z component.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  translateXYZ: function translateXYZ(x, y, z) {\n    var a = this.val;\n    a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n    return this;\n  },\n\n  /**\r\n   * Apply a scale transformation to this Matrix.\r\n   *\r\n   * Uses the `x`, `y` and `z` components of the given Vector to scale the Matrix.\r\n   *\r\n   * @method Phaser.Math.Matrix4#scale\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to scale this Matrix with.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  scale: function scale(v) {\n    var x = v.x;\n    var y = v.y;\n    var z = v.z;\n    var a = this.val;\n    a[0] = a[0] * x;\n    a[1] = a[1] * x;\n    a[2] = a[2] * x;\n    a[3] = a[3] * x;\n    a[4] = a[4] * y;\n    a[5] = a[5] * y;\n    a[6] = a[6] * y;\n    a[7] = a[7] * y;\n    a[8] = a[8] * z;\n    a[9] = a[9] * z;\n    a[10] = a[10] * z;\n    a[11] = a[11] * z;\n    return this;\n  },\n\n  /**\r\n   * Apply a scale transformation to this Matrix.\r\n   *\r\n   * @method Phaser.Math.Matrix4#scaleXYZ\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} x - The x component.\r\n   * @param {number} y - The y component.\r\n   * @param {number} z - The z component.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  scaleXYZ: function scaleXYZ(x, y, z) {\n    var a = this.val;\n    a[0] = a[0] * x;\n    a[1] = a[1] * x;\n    a[2] = a[2] * x;\n    a[3] = a[3] * x;\n    a[4] = a[4] * y;\n    a[5] = a[5] * y;\n    a[6] = a[6] * y;\n    a[7] = a[7] * y;\n    a[8] = a[8] * z;\n    a[9] = a[9] * z;\n    a[10] = a[10] * z;\n    a[11] = a[11] * z;\n    return this;\n  },\n\n  /**\r\n   * Derive a rotation matrix around the given axis.\r\n   *\r\n   * @method Phaser.Math.Matrix4#makeRotationAxis\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} axis - The rotation axis.\r\n   * @param {number} angle - The rotation angle in radians.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  makeRotationAxis: function makeRotationAxis(axis, angle) {\n    // Based on http://www.gamedev.net/reference/articles/article1199.asp\n    var c = Math.cos(angle);\n    var s = Math.sin(angle);\n    var t = 1 - c;\n    var x = axis.x;\n    var y = axis.y;\n    var z = axis.z;\n    var tx = t * x;\n    var ty = t * y;\n    this.fromArray([tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1]);\n    return this;\n  },\n\n  /**\r\n   * Apply a rotation transformation to this Matrix.\r\n   *\r\n   * @method Phaser.Math.Matrix4#rotate\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} rad - The angle in radians to rotate by.\r\n   * @param {Phaser.Math.Vector3} axis - The axis to rotate upon.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  rotate: function rotate(rad, axis) {\n    var a = this.val;\n    var x = axis.x;\n    var y = axis.y;\n    var z = axis.z;\n    var len = Math.sqrt(x * x + y * y + z * z);\n\n    if (Math.abs(len) < EPSILON) {\n      return null;\n    }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n    var s = Math.sin(rad);\n    var c = Math.cos(rad);\n    var t = 1 - c;\n    var a00 = a[0];\n    var a01 = a[1];\n    var a02 = a[2];\n    var a03 = a[3];\n    var a10 = a[4];\n    var a11 = a[5];\n    var a12 = a[6];\n    var a13 = a[7];\n    var a20 = a[8];\n    var a21 = a[9];\n    var a22 = a[10];\n    var a23 = a[11]; // Construct the elements of the rotation matrix\n\n    var b00 = x * x * t + c;\n    var b01 = y * x * t + z * s;\n    var b02 = z * x * t - y * s;\n    var b10 = x * y * t - z * s;\n    var b11 = y * y * t + c;\n    var b12 = z * y * t + x * s;\n    var b20 = x * z * t + y * s;\n    var b21 = y * z * t - x * s;\n    var b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n    a[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    a[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    a[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    a[3] = a03 * b00 + a13 * b01 + a23 * b02;\n    a[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    a[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    a[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    a[7] = a03 * b10 + a13 * b11 + a23 * b12;\n    a[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    a[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    a[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    a[11] = a03 * b20 + a13 * b21 + a23 * b22;\n    return this;\n  },\n\n  /**\r\n   * Rotate this matrix on its X axis.\r\n   *\r\n   * @method Phaser.Math.Matrix4#rotateX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} rad - The angle in radians to rotate by.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  rotateX: function rotateX(rad) {\n    var a = this.val;\n    var s = Math.sin(rad);\n    var c = Math.cos(rad);\n    var a10 = a[4];\n    var a11 = a[5];\n    var a12 = a[6];\n    var a13 = a[7];\n    var a20 = a[8];\n    var a21 = a[9];\n    var a22 = a[10];\n    var a23 = a[11]; // Perform axis-specific matrix multiplication\n\n    a[4] = a10 * c + a20 * s;\n    a[5] = a11 * c + a21 * s;\n    a[6] = a12 * c + a22 * s;\n    a[7] = a13 * c + a23 * s;\n    a[8] = a20 * c - a10 * s;\n    a[9] = a21 * c - a11 * s;\n    a[10] = a22 * c - a12 * s;\n    a[11] = a23 * c - a13 * s;\n    return this;\n  },\n\n  /**\r\n   * Rotate this matrix on its Y axis.\r\n   *\r\n   * @method Phaser.Math.Matrix4#rotateY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} rad - The angle to rotate by, in radians.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  rotateY: function rotateY(rad) {\n    var a = this.val;\n    var s = Math.sin(rad);\n    var c = Math.cos(rad);\n    var a00 = a[0];\n    var a01 = a[1];\n    var a02 = a[2];\n    var a03 = a[3];\n    var a20 = a[8];\n    var a21 = a[9];\n    var a22 = a[10];\n    var a23 = a[11]; // Perform axis-specific matrix multiplication\n\n    a[0] = a00 * c - a20 * s;\n    a[1] = a01 * c - a21 * s;\n    a[2] = a02 * c - a22 * s;\n    a[3] = a03 * c - a23 * s;\n    a[8] = a00 * s + a20 * c;\n    a[9] = a01 * s + a21 * c;\n    a[10] = a02 * s + a22 * c;\n    a[11] = a03 * s + a23 * c;\n    return this;\n  },\n\n  /**\r\n   * Rotate this matrix on its Z axis.\r\n   *\r\n   * @method Phaser.Math.Matrix4#rotateZ\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} rad - The angle to rotate by, in radians.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  rotateZ: function rotateZ(rad) {\n    var a = this.val;\n    var s = Math.sin(rad);\n    var c = Math.cos(rad);\n    var a00 = a[0];\n    var a01 = a[1];\n    var a02 = a[2];\n    var a03 = a[3];\n    var a10 = a[4];\n    var a11 = a[5];\n    var a12 = a[6];\n    var a13 = a[7]; // Perform axis-specific matrix multiplication\n\n    a[0] = a00 * c + a10 * s;\n    a[1] = a01 * c + a11 * s;\n    a[2] = a02 * c + a12 * s;\n    a[3] = a03 * c + a13 * s;\n    a[4] = a10 * c - a00 * s;\n    a[5] = a11 * c - a01 * s;\n    a[6] = a12 * c - a02 * s;\n    a[7] = a13 * c - a03 * s;\n    return this;\n  },\n\n  /**\r\n   * Set the values of this Matrix from the given rotation Quaternion and translation Vector.\r\n   *\r\n   * @method Phaser.Math.Matrix4#fromRotationTranslation\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Quaternion} q - The Quaternion to set rotation from.\r\n   * @param {Phaser.Math.Vector3} v - The Vector to set translation from.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  fromRotationTranslation: function fromRotationTranslation(q, v) {\n    // Quaternion math\n    var out = this.val;\n    var x = q.x;\n    var y = q.y;\n    var z = q.z;\n    var w = q.w;\n    var x2 = x + x;\n    var y2 = y + y;\n    var z2 = z + z;\n    var xx = x * x2;\n    var xy = x * y2;\n    var xz = x * z2;\n    var yy = y * y2;\n    var yz = y * z2;\n    var zz = z * z2;\n    var wx = w * x2;\n    var wy = w * y2;\n    var wz = w * z2;\n    out[0] = 1 - (yy + zz);\n    out[1] = xy + wz;\n    out[2] = xz - wy;\n    out[3] = 0;\n    out[4] = xy - wz;\n    out[5] = 1 - (xx + zz);\n    out[6] = yz + wx;\n    out[7] = 0;\n    out[8] = xz + wy;\n    out[9] = yz - wx;\n    out[10] = 1 - (xx + yy);\n    out[11] = 0;\n    out[12] = v.x;\n    out[13] = v.y;\n    out[14] = v.z;\n    out[15] = 1;\n    return this;\n  },\n\n  /**\r\n   * Set the values of this Matrix from the given Quaternion.\r\n   *\r\n   * @method Phaser.Math.Matrix4#fromQuat\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Quaternion} q - The Quaternion to set the values of this Matrix from.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  fromQuat: function fromQuat(q) {\n    var out = this.val;\n    var x = q.x;\n    var y = q.y;\n    var z = q.z;\n    var w = q.w;\n    var x2 = x + x;\n    var y2 = y + y;\n    var z2 = z + z;\n    var xx = x * x2;\n    var xy = x * y2;\n    var xz = x * z2;\n    var yy = y * y2;\n    var yz = y * z2;\n    var zz = z * z2;\n    var wx = w * x2;\n    var wy = w * y2;\n    var wz = w * z2;\n    out[0] = 1 - (yy + zz);\n    out[1] = xy + wz;\n    out[2] = xz - wy;\n    out[3] = 0;\n    out[4] = xy - wz;\n    out[5] = 1 - (xx + zz);\n    out[6] = yz + wx;\n    out[7] = 0;\n    out[8] = xz + wy;\n    out[9] = yz - wx;\n    out[10] = 1 - (xx + yy);\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return this;\n  },\n\n  /**\r\n   * Generate a frustum matrix with the given bounds.\r\n   *\r\n   * @method Phaser.Math.Matrix4#frustum\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} left - The left bound of the frustum.\r\n   * @param {number} right - The right bound of the frustum.\r\n   * @param {number} bottom - The bottom bound of the frustum.\r\n   * @param {number} top - The top bound of the frustum.\r\n   * @param {number} near - The near bound of the frustum.\r\n   * @param {number} far - The far bound of the frustum.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  frustum: function frustum(left, right, bottom, top, near, far) {\n    var out = this.val;\n    var rl = 1 / (right - left);\n    var tb = 1 / (top - bottom);\n    var nf = 1 / (near - far);\n    out[0] = near * 2 * rl;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = near * 2 * tb;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = (right + left) * rl;\n    out[9] = (top + bottom) * tb;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = far * near * 2 * nf;\n    out[15] = 0;\n    return this;\n  },\n\n  /**\r\n   * Generate a perspective projection matrix with the given bounds.\r\n   *\r\n   * @method Phaser.Math.Matrix4#perspective\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} fovy - Vertical field of view in radians\r\n   * @param {number} aspect - Aspect ratio. Typically viewport width  /height.\r\n   * @param {number} near - Near bound of the frustum.\r\n   * @param {number} far - Far bound of the frustum.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  perspective: function perspective(fovy, aspect, near, far) {\n    var out = this.val;\n    var f = 1.0 / Math.tan(fovy / 2);\n    var nf = 1 / (near - far);\n    out[0] = f / aspect;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = f;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 2 * far * near * nf;\n    out[15] = 0;\n    return this;\n  },\n\n  /**\r\n   * Generate a perspective projection matrix with the given bounds.\r\n   *\r\n   * @method Phaser.Math.Matrix4#perspectiveLH\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} width - The width of the frustum.\r\n   * @param {number} height - The height of the frustum.\r\n   * @param {number} near - Near bound of the frustum.\r\n   * @param {number} far - Far bound of the frustum.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  perspectiveLH: function perspectiveLH(width, height, near, far) {\n    var out = this.val;\n    out[0] = 2 * near / width;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 2 * near / height;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = -far / (near - far);\n    out[11] = 1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = near * far / (near - far);\n    out[15] = 0;\n    return this;\n  },\n\n  /**\r\n   * Generate an orthogonal projection matrix with the given bounds.\r\n   *\r\n   * @method Phaser.Math.Matrix4#ortho\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} left - The left bound of the frustum.\r\n   * @param {number} right - The right bound of the frustum.\r\n   * @param {number} bottom - The bottom bound of the frustum.\r\n   * @param {number} top - The top bound of the frustum.\r\n   * @param {number} near - The near bound of the frustum.\r\n   * @param {number} far - The far bound of the frustum.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  ortho: function ortho(left, right, bottom, top, near, far) {\n    var out = this.val;\n    var lr = left - right;\n    var bt = bottom - top;\n    var nf = near - far; //  Avoid division by zero\n\n    lr = lr === 0 ? lr : 1 / lr;\n    bt = bt === 0 ? bt : 1 / bt;\n    nf = nf === 0 ? nf : 1 / nf;\n    out[0] = -2 * lr;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = -2 * bt;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 2 * nf;\n    out[11] = 0;\n    out[12] = (left + right) * lr;\n    out[13] = (top + bottom) * bt;\n    out[14] = (far + near) * nf;\n    out[15] = 1;\n    return this;\n  },\n\n  /**\r\n   * Generate a look-at matrix with the given eye position, focal point, and up axis.\r\n   *\r\n   * @method Phaser.Math.Matrix4#lookAt\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector3} eye - Position of the viewer\r\n   * @param {Phaser.Math.Vector3} center - Point the viewer is looking at\r\n   * @param {Phaser.Math.Vector3} up - vec3 pointing up.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  lookAt: function lookAt(eye, center, up) {\n    var out = this.val;\n    var eyex = eye.x;\n    var eyey = eye.y;\n    var eyez = eye.z;\n    var upx = up.x;\n    var upy = up.y;\n    var upz = up.z;\n    var centerx = center.x;\n    var centery = center.y;\n    var centerz = center.z;\n\n    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {\n      return this.identity();\n    }\n\n    var z0 = eyex - centerx;\n    var z1 = eyey - centery;\n    var z2 = eyez - centerz;\n    var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n    var x0 = upy * z2 - upz * z1;\n    var x1 = upz * z0 - upx * z2;\n    var x2 = upx * z1 - upy * z0;\n    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n\n    if (!len) {\n      x0 = 0;\n      x1 = 0;\n      x2 = 0;\n    } else {\n      len = 1 / len;\n      x0 *= len;\n      x1 *= len;\n      x2 *= len;\n    }\n\n    var y0 = z1 * x2 - z2 * x1;\n    var y1 = z2 * x0 - z0 * x2;\n    var y2 = z0 * x1 - z1 * x0;\n    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n\n    if (!len) {\n      y0 = 0;\n      y1 = 0;\n      y2 = 0;\n    } else {\n      len = 1 / len;\n      y0 *= len;\n      y1 *= len;\n      y2 *= len;\n    }\n\n    out[0] = x0;\n    out[1] = y0;\n    out[2] = z0;\n    out[3] = 0;\n    out[4] = x1;\n    out[5] = y1;\n    out[6] = z1;\n    out[7] = 0;\n    out[8] = x2;\n    out[9] = y2;\n    out[10] = z2;\n    out[11] = 0;\n    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n    out[15] = 1;\n    return this;\n  },\n\n  /**\r\n   * Set the values of this matrix from the given `yaw`, `pitch` and `roll` values.\r\n   *\r\n   * @method Phaser.Math.Matrix4#yawPitchRoll\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} yaw - [description]\r\n   * @param {number} pitch - [description]\r\n   * @param {number} roll - [description]\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  yawPitchRoll: function yawPitchRoll(yaw, pitch, roll) {\n    this.zero();\n\n    _tempMat1.zero();\n\n    _tempMat2.zero();\n\n    var m0 = this.val;\n    var m1 = _tempMat1.val;\n    var m2 = _tempMat2.val; //  Rotate Z\n\n    var s = Math.sin(roll);\n    var c = Math.cos(roll);\n    m0[10] = 1;\n    m0[15] = 1;\n    m0[0] = c;\n    m0[1] = s;\n    m0[4] = -s;\n    m0[5] = c; //  Rotate X\n\n    s = Math.sin(pitch);\n    c = Math.cos(pitch);\n    m1[0] = 1;\n    m1[15] = 1;\n    m1[5] = c;\n    m1[10] = c;\n    m1[9] = -s;\n    m1[6] = s; //  Rotate Y\n\n    s = Math.sin(yaw);\n    c = Math.cos(yaw);\n    m2[5] = 1;\n    m2[15] = 1;\n    m2[0] = c;\n    m2[2] = -s;\n    m2[8] = s;\n    m2[10] = c;\n    this.multiplyLocal(_tempMat1);\n    this.multiplyLocal(_tempMat2);\n    return this;\n  },\n\n  /**\r\n   * Generate a world matrix from the given rotation, position, scale, view matrix and projection matrix.\r\n   *\r\n   * @method Phaser.Math.Matrix4#setWorldMatrix\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector3} rotation - The rotation of the world matrix.\r\n   * @param {Phaser.Math.Vector3} position - The position of the world matrix.\r\n   * @param {Phaser.Math.Vector3} scale - The scale of the world matrix.\r\n   * @param {Phaser.Math.Matrix4} [viewMatrix] - The view matrix.\r\n   * @param {Phaser.Math.Matrix4} [projectionMatrix] - The projection matrix.\r\n   *\r\n   * @return {Phaser.Math.Matrix4} This Matrix4.\r\n   */\n  setWorldMatrix: function setWorldMatrix(rotation, position, scale, viewMatrix, projectionMatrix) {\n    this.yawPitchRoll(rotation.y, rotation.x, rotation.z);\n\n    _tempMat1.scaling(scale.x, scale.y, scale.z);\n\n    _tempMat2.xyz(position.x, position.y, position.z);\n\n    this.multiplyLocal(_tempMat1);\n    this.multiplyLocal(_tempMat2);\n\n    if (viewMatrix !== undefined) {\n      this.multiplyLocal(viewMatrix);\n    }\n\n    if (projectionMatrix !== undefined) {\n      this.multiplyLocal(projectionMatrix);\n    }\n\n    return this;\n  }\n});\n\nvar _tempMat1 = new Matrix4();\n\nvar _tempMat2 = new Matrix4();\n\nmodule.exports = Matrix4;","map":null,"metadata":{},"sourceType":"script"}