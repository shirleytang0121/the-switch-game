{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\n\n/**\r\n * Read an integer value from an XML Node.\r\n *\r\n * @function getValue\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Node} node - The XML Node.\r\n * @param {string} attribute - The attribute to read.\r\n *\r\n * @return {integer} The parsed value.\r\n */\nfunction getValue(node, attribute) {\n  return parseInt(node.getAttribute(attribute), 10);\n}\n/**\r\n * Parse an XML font to Bitmap Font data for the Bitmap Font cache.\r\n *\r\n * @function ParseXMLBitmapFont\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {XMLDocument} xml - The XML Document to parse the font from.\r\n * @param {integer} [xSpacing=0] - The x-axis spacing to add between each letter.\r\n * @param {integer} [ySpacing=0] - The y-axis spacing to add to the line height.\r\n * @param {Phaser.Textures.Frame} [frame] - The texture frame to take into account while parsing.\r\n *\r\n * @return {BitmapFontData} The parsed Bitmap Font data.\r\n */\n\n\nvar ParseXMLBitmapFont = function ParseXMLBitmapFont(xml, xSpacing, ySpacing, frame) {\n  if (xSpacing === undefined) {\n    xSpacing = 0;\n  }\n\n  if (ySpacing === undefined) {\n    ySpacing = 0;\n  }\n\n  var data = {};\n  var info = xml.getElementsByTagName('info')[0];\n  var common = xml.getElementsByTagName('common')[0];\n  data.font = info.getAttribute('face');\n  data.size = getValue(info, 'size');\n  data.lineHeight = getValue(common, 'lineHeight') + ySpacing;\n  data.chars = {};\n  var letters = xml.getElementsByTagName('char');\n  var adjustForTrim = frame !== undefined && frame.trimmed;\n\n  if (adjustForTrim) {\n    var top = frame.height;\n    var left = frame.width;\n  }\n\n  for (var i = 0; i < letters.length; i++) {\n    var node = letters[i];\n    var charCode = getValue(node, 'id');\n    var gx = getValue(node, 'x');\n    var gy = getValue(node, 'y');\n    var gw = getValue(node, 'width');\n    var gh = getValue(node, 'height'); //  Handle frame trim issues\n\n    if (adjustForTrim) {\n      if (gx < left) {\n        left = gx;\n      }\n\n      if (gy < top) {\n        top = gy;\n      }\n    }\n\n    data.chars[charCode] = {\n      x: gx,\n      y: gy,\n      width: gw,\n      height: gh,\n      centerX: Math.floor(gw / 2),\n      centerY: Math.floor(gh / 2),\n      xOffset: getValue(node, 'xoffset'),\n      yOffset: getValue(node, 'yoffset'),\n      xAdvance: getValue(node, 'xadvance') + xSpacing,\n      data: {},\n      kerning: {}\n    };\n  }\n\n  if (adjustForTrim && top !== 0 && left !== 0) {\n    // console.log('top and left', top, left, frame.x, frame.y);\n    //  Now we know the top and left coordinates of the glyphs in the original data\n    //  so we can work out how much to adjust the glyphs by\n    for (var code in data.chars) {\n      var glyph = data.chars[code];\n      glyph.x -= frame.x;\n      glyph.y -= frame.y;\n    }\n  }\n\n  var kernings = xml.getElementsByTagName('kerning');\n\n  for (i = 0; i < kernings.length; i++) {\n    var kern = kernings[i];\n    var first = getValue(kern, 'first');\n    var second = getValue(kern, 'second');\n    var amount = getValue(kern, 'amount');\n    data.chars[second].kerning[first] = amount;\n  }\n\n  return data;\n};\n\nmodule.exports = ParseXMLBitmapFont;","map":null,"metadata":{},"sourceType":"script"}