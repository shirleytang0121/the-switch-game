{"ast":null,"code":"/**\r\n* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\r\n* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\r\n* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Vertices\r\n*/\nvar Vertices = {};\nmodule.exports = Vertices;\n\nvar Vector = require('../geometry/Vector');\n\nvar Common = require('../core/Common');\n\n(function () {\n  /**\r\n   * Creates a new set of `Matter.Body` compatible vertices.\r\n   * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:\r\n   *\r\n   *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\r\n   *\r\n   * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,\r\n   * but with some additional references required for efficient collision detection routines.\r\n   *\r\n   * Vertices must be specified in clockwise order.\r\n   *\r\n   * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.\r\n   *\r\n   * @method create\r\n   * @param {vector[]} points\r\n   * @param {body} body\r\n   */\n  Vertices.create = function (points, body) {\n    var vertices = [];\n\n    for (var i = 0; i < points.length; i++) {\n      var point = points[i],\n          vertex = {\n        x: point.x,\n        y: point.y,\n        index: i,\n        body: body,\n        isInternal: false,\n        contact: null\n      };\n      vertex.contact = {\n        vertex: vertex,\n        normalImpulse: 0,\n        tangentImpulse: 0\n      };\n      vertices.push(vertex);\n    }\n\n    return vertices;\n  };\n  /**\r\n   * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), \r\n   * into a `Matter.Vertices` object for the given `Matter.Body`.\r\n   * For parsing SVG paths, see `Svg.pathToVertices`.\r\n   * @method fromPath\r\n   * @param {string} path\r\n   * @param {body} body\r\n   * @return {vertices} vertices\r\n   */\n\n\n  Vertices.fromPath = function (path, body) {\n    var pathPattern = /L?\\s*([\\-\\d\\.e]+)[\\s,]*([\\-\\d\\.e]+)*/ig,\n        points = [];\n    path.replace(pathPattern, function (match, x, y) {\n      points.push({\n        x: parseFloat(x),\n        y: parseFloat(y)\n      });\n    });\n    return Vertices.create(points, body);\n  };\n  /**\r\n   * Returns the centre (centroid) of the set of vertices.\r\n   * @method centre\r\n   * @param {vertices} vertices\r\n   * @return {vector} The centre point\r\n   */\n\n\n  Vertices.centre = function (vertices) {\n    var area = Vertices.area(vertices, true),\n        centre = {\n      x: 0,\n      y: 0\n    },\n        cross,\n        temp,\n        j;\n\n    for (var i = 0; i < vertices.length; i++) {\n      j = (i + 1) % vertices.length;\n      cross = Vector.cross(vertices[i], vertices[j]);\n      temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);\n      centre = Vector.add(centre, temp);\n    }\n\n    return Vector.div(centre, 6 * area);\n  };\n  /**\r\n   * Returns the average (mean) of the set of vertices.\r\n   * @method mean\r\n   * @param {vertices} vertices\r\n   * @return {vector} The average point\r\n   */\n\n\n  Vertices.mean = function (vertices) {\n    var average = {\n      x: 0,\n      y: 0\n    };\n\n    for (var i = 0; i < vertices.length; i++) {\n      average.x += vertices[i].x;\n      average.y += vertices[i].y;\n    }\n\n    return Vector.div(average, vertices.length);\n  };\n  /**\r\n   * Returns the area of the set of vertices.\r\n   * @method area\r\n   * @param {vertices} vertices\r\n   * @param {bool} signed\r\n   * @return {number} The area\r\n   */\n\n\n  Vertices.area = function (vertices, signed) {\n    var area = 0,\n        j = vertices.length - 1;\n\n    for (var i = 0; i < vertices.length; i++) {\n      area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);\n      j = i;\n    }\n\n    if (signed) return area / 2;\n    return Math.abs(area) / 2;\n  };\n  /**\r\n   * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.\r\n   * @method inertia\r\n   * @param {vertices} vertices\r\n   * @param {number} mass\r\n   * @return {number} The polygon's moment of inertia\r\n   */\n\n\n  Vertices.inertia = function (vertices, mass) {\n    var numerator = 0,\n        denominator = 0,\n        v = vertices,\n        cross,\n        j; // find the polygon's moment of inertia, using second moment of area\n    // from equations at http://www.physicsforums.com/showthread.php?t=25293\n\n    for (var n = 0; n < v.length; n++) {\n      j = (n + 1) % v.length;\n      cross = Math.abs(Vector.cross(v[j], v[n]));\n      numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));\n      denominator += cross;\n    }\n\n    return mass / 6 * (numerator / denominator);\n  };\n  /**\r\n   * Translates the set of vertices in-place.\r\n   * @method translate\r\n   * @param {vertices} vertices\r\n   * @param {vector} vector\r\n   * @param {number} scalar\r\n   */\n\n\n  Vertices.translate = function (vertices, vector, scalar) {\n    var i;\n\n    if (scalar) {\n      for (i = 0; i < vertices.length; i++) {\n        vertices[i].x += vector.x * scalar;\n        vertices[i].y += vector.y * scalar;\n      }\n    } else {\n      for (i = 0; i < vertices.length; i++) {\n        vertices[i].x += vector.x;\n        vertices[i].y += vector.y;\n      }\n    }\n\n    return vertices;\n  };\n  /**\r\n   * Rotates the set of vertices in-place.\r\n   * @method rotate\r\n   * @param {vertices} vertices\r\n   * @param {number} angle\r\n   * @param {vector} point\r\n   */\n\n\n  Vertices.rotate = function (vertices, angle, point) {\n    if (angle === 0) return;\n    var cos = Math.cos(angle),\n        sin = Math.sin(angle);\n\n    for (var i = 0; i < vertices.length; i++) {\n      var vertice = vertices[i],\n          dx = vertice.x - point.x,\n          dy = vertice.y - point.y;\n      vertice.x = point.x + (dx * cos - dy * sin);\n      vertice.y = point.y + (dx * sin + dy * cos);\n    }\n\n    return vertices;\n  };\n  /**\r\n   * Returns `true` if the `point` is inside the set of `vertices`.\r\n   * @method contains\r\n   * @param {vertices} vertices\r\n   * @param {vector} point\r\n   * @return {boolean} True if the vertices contains point, otherwise false\r\n   */\n\n\n  Vertices.contains = function (vertices, point) {\n    for (var i = 0; i < vertices.length; i++) {\n      var vertice = vertices[i],\n          nextVertice = vertices[(i + 1) % vertices.length];\n\n      if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Scales the vertices from a point (default is centre) in-place.\r\n   * @method scale\r\n   * @param {vertices} vertices\r\n   * @param {number} scaleX\r\n   * @param {number} scaleY\r\n   * @param {vector} point\r\n   */\n\n\n  Vertices.scale = function (vertices, scaleX, scaleY, point) {\n    if (scaleX === 1 && scaleY === 1) return vertices;\n    point = point || Vertices.centre(vertices);\n    var vertex, delta;\n\n    for (var i = 0; i < vertices.length; i++) {\n      vertex = vertices[i];\n      delta = Vector.sub(vertex, point);\n      vertices[i].x = point.x + delta.x * scaleX;\n      vertices[i].y = point.y + delta.y * scaleY;\n    }\n\n    return vertices;\n  };\n  /**\r\n   * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.\r\n   * The radius parameter is a single number or an array to specify the radius for each vertex.\r\n   * @method chamfer\r\n   * @param {vertices} vertices\r\n   * @param {number[]} radius\r\n   * @param {number} quality\r\n   * @param {number} qualityMin\r\n   * @param {number} qualityMax\r\n   */\n\n\n  Vertices.chamfer = function (vertices, radius, quality, qualityMin, qualityMax) {\n    if (typeof radius === 'number') {\n      radius = [radius];\n    } else {\n      radius = radius || [8];\n    } // quality defaults to -1, which is auto\n\n\n    quality = typeof quality !== 'undefined' ? quality : -1;\n    qualityMin = qualityMin || 2;\n    qualityMax = qualityMax || 14;\n    var newVertices = [];\n\n    for (var i = 0; i < vertices.length; i++) {\n      var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1],\n          vertex = vertices[i],\n          nextVertex = vertices[(i + 1) % vertices.length],\n          currentRadius = radius[i < radius.length ? i : radius.length - 1];\n\n      if (currentRadius === 0) {\n        newVertices.push(vertex);\n        continue;\n      }\n\n      var prevNormal = Vector.normalise({\n        x: vertex.y - prevVertex.y,\n        y: prevVertex.x - vertex.x\n      });\n      var nextNormal = Vector.normalise({\n        x: nextVertex.y - vertex.y,\n        y: vertex.x - nextVertex.x\n      });\n      var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),\n          radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),\n          midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)),\n          scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));\n      var precision = quality;\n\n      if (quality === -1) {\n        // automatically decide precision\n        precision = Math.pow(currentRadius, 0.32) * 1.75;\n      }\n\n      precision = Common.clamp(precision, qualityMin, qualityMax); // use an even value for precision, more likely to reduce axes by using symmetry\n\n      if (precision % 2 === 1) precision += 1;\n      var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)),\n          theta = alpha / precision;\n\n      for (var j = 0; j < precision; j++) {\n        newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));\n      }\n    }\n\n    return newVertices;\n  };\n  /**\r\n   * Sorts the input vertices into clockwise order in place.\r\n   * @method clockwiseSort\r\n   * @param {vertices} vertices\r\n   * @return {vertices} vertices\r\n   */\n\n\n  Vertices.clockwiseSort = function (vertices) {\n    var centre = Vertices.mean(vertices);\n    vertices.sort(function (vertexA, vertexB) {\n      return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);\n    });\n    return vertices;\n  };\n  /**\r\n   * Returns true if the vertices form a convex shape (vertices must be in clockwise order).\r\n   * @method isConvex\r\n   * @param {vertices} vertices\r\n   * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).\r\n   */\n\n\n  Vertices.isConvex = function (vertices) {\n    // http://paulbourke.net/geometry/polygonmesh/\n    // Copyright (c) Paul Bourke (use permitted)\n    var flag = 0,\n        n = vertices.length,\n        i,\n        j,\n        k,\n        z;\n    if (n < 3) return null;\n\n    for (i = 0; i < n; i++) {\n      j = (i + 1) % n;\n      k = (i + 2) % n;\n      z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);\n      z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);\n\n      if (z < 0) {\n        flag |= 1;\n      } else if (z > 0) {\n        flag |= 2;\n      }\n\n      if (flag === 3) {\n        return false;\n      }\n    }\n\n    if (flag !== 0) {\n      return true;\n    } else {\n      return null;\n    }\n  };\n  /**\r\n   * Returns the convex hull of the input vertices as a new array of points.\r\n   * @method hull\r\n   * @param {vertices} vertices\r\n   * @return [vertex] vertices\r\n   */\n\n\n  Vertices.hull = function (vertices) {\n    // http://geomalgorithms.com/a10-_hull-1.html\n    var upper = [],\n        lower = [],\n        vertex,\n        i; // sort vertices on x-axis (y-axis for ties)\n\n    vertices = vertices.slice(0);\n    vertices.sort(function (vertexA, vertexB) {\n      var dx = vertexA.x - vertexB.x;\n      return dx !== 0 ? dx : vertexA.y - vertexB.y;\n    }); // build lower hull\n\n    for (i = 0; i < vertices.length; i += 1) {\n      vertex = vertices[i];\n\n      while (lower.length >= 2 && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {\n        lower.pop();\n      }\n\n      lower.push(vertex);\n    } // build upper hull\n\n\n    for (i = vertices.length - 1; i >= 0; i -= 1) {\n      vertex = vertices[i];\n\n      while (upper.length >= 2 && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {\n        upper.pop();\n      }\n\n      upper.push(vertex);\n    } // concatenation of the lower and upper hulls gives the convex hull\n    // omit last points because they are repeated at the beginning of the other list\n\n\n    upper.pop();\n    lower.pop();\n    return upper.concat(lower);\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}