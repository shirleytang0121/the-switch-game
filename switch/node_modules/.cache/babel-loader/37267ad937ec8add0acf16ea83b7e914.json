{"ast":null,"code":"/**\r\n* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.\r\n*\r\n* @class Pair\r\n*/\nvar Pair = {};\nmodule.exports = Pair;\n\n(function () {\n  /**\r\n   * Creates a pair.\r\n   * @method create\r\n   * @param {collision} collision\r\n   * @param {number} timestamp\r\n   * @return {pair} A new pair\r\n   */\n  Pair.create = function (collision, timestamp) {\n    var bodyA = collision.bodyA,\n        bodyB = collision.bodyB;\n    var pair = {\n      id: Pair.id(bodyA, bodyB),\n      bodyA: bodyA,\n      bodyB: bodyB,\n      activeContacts: [],\n      separation: 0,\n      isActive: true,\n      confirmedActive: true,\n      isSensor: bodyA.isSensor || bodyB.isSensor,\n      timeCreated: timestamp,\n      timeUpdated: timestamp,\n      collision: null,\n      inverseMass: 0,\n      friction: 0,\n      frictionStatic: 0,\n      restitution: 0,\n      slop: 0\n    };\n    Pair.update(pair, collision, timestamp);\n    return pair;\n  };\n  /**\r\n   * Updates a pair given a collision.\r\n   * @method update\r\n   * @param {pair} pair\r\n   * @param {collision} collision\r\n   * @param {number} timestamp\r\n   */\n\n\n  Pair.update = function (pair, collision, timestamp) {\n    pair.collision = collision;\n\n    if (collision.collided) {\n      var supports = collision.supports,\n          activeContacts = pair.activeContacts,\n          parentA = collision.parentA,\n          parentB = collision.parentB;\n      pair.inverseMass = parentA.inverseMass + parentB.inverseMass;\n      pair.friction = Math.min(parentA.friction, parentB.friction);\n      pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);\n      pair.restitution = Math.max(parentA.restitution, parentB.restitution);\n      pair.slop = Math.max(parentA.slop, parentB.slop);\n\n      for (var i = 0; i < supports.length; i++) {\n        activeContacts[i] = supports[i].contact;\n      } // optimise array size\n\n\n      var supportCount = supports.length;\n\n      if (supportCount < activeContacts.length) {\n        activeContacts.length = supportCount;\n      }\n\n      pair.separation = collision.depth;\n      Pair.setActive(pair, true, timestamp);\n    } else {\n      if (pair.isActive === true) Pair.setActive(pair, false, timestamp);\n    }\n  };\n  /**\r\n   * Set a pair as active or inactive.\r\n   * @method setActive\r\n   * @param {pair} pair\r\n   * @param {bool} isActive\r\n   * @param {number} timestamp\r\n   */\n\n\n  Pair.setActive = function (pair, isActive, timestamp) {\n    if (isActive) {\n      pair.isActive = true;\n      pair.timeUpdated = timestamp;\n    } else {\n      pair.isActive = false;\n      pair.activeContacts.length = 0;\n    }\n  };\n  /**\r\n   * Get the id for the given pair.\r\n   * @method id\r\n   * @param {body} bodyA\r\n   * @param {body} bodyB\r\n   * @return {string} Unique pairId\r\n   */\n\n\n  Pair.id = function (bodyA, bodyB) {\n    if (bodyA.id < bodyB.id) {\n      return 'A' + bodyA.id + 'B' + bodyB.id;\n    } else {\n      return 'A' + bodyB.id + 'B' + bodyA.id;\n    }\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}