{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\nvar Class = require('../utils/Class');\n/**\r\n * @typedef {object} Vector2Like\r\n *\r\n * @property {number} x - The x component.\r\n * @property {number} y - The y component.\r\n */\n\n/**\r\n * @classdesc\r\n * A representation of a vector in 2D space.\r\n *\r\n * A two-component vector.\r\n *\r\n * @class Vector2\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number|Vector2Like} [x] - The x component, or an object with `x` and `y` properties.\r\n * @param {number} [y] - The y component.\r\n */\n\n\nvar Vector2 = new Class({\n  initialize: function Vector2(x, y) {\n    /**\r\n     * The x component of this Vector.\r\n     *\r\n     * @name Phaser.Math.Vector2#x\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n    this.x = 0;\n    /**\r\n     * The y component of this Vector.\r\n     *\r\n     * @name Phaser.Math.Vector2#y\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.y = 0;\n\n    if (typeof x === 'object') {\n      this.x = x.x || 0;\n      this.y = x.y || 0;\n    } else {\n      if (y === undefined) {\n        y = x;\n      }\n\n      this.x = x || 0;\n      this.y = y || 0;\n    }\n  },\n\n  /**\r\n   * Make a clone of this Vector2.\r\n   *\r\n   * @method Phaser.Math.Vector2#clone\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Vector2} A clone of this Vector2.\r\n   */\n  clone: function clone() {\n    return new Vector2(this.x, this.y);\n  },\n\n  /**\r\n   * Copy the components of a given Vector into this Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#copy\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector to copy the components from.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  copy: function copy(src) {\n    this.x = src.x || 0;\n    this.y = src.y || 0;\n    return this;\n  },\n\n  /**\r\n   * Set the component values of this Vector from a given Vector2Like object.\r\n   *\r\n   * @method Phaser.Math.Vector2#setFromObject\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Vector2Like} obj - The object containing the component values to set for this Vector.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  setFromObject: function setFromObject(obj) {\n    this.x = obj.x || 0;\n    this.y = obj.y || 0;\n    return this;\n  },\n\n  /**\r\n   * Set the `x` and `y` components of the this Vector to the given `x` and `y` values.\r\n   *\r\n   * @method Phaser.Math.Vector2#set\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The x value to set for this Vector.\r\n   * @param {number} [y=x] - The y value to set for this Vector.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  set: function set(x, y) {\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n\n  /**\r\n   * This method is an alias for `Vector2.set`.\r\n   *\r\n   * @method Phaser.Math.Vector2#setTo\r\n   * @since 3.4.0\r\n   *\r\n   * @param {number} x - The x value to set for this Vector.\r\n   * @param {number} [y=x] - The y value to set for this Vector.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  setTo: function setTo(x, y) {\n    return this.set(x, y);\n  },\n\n  /**\r\n   * Sets the `x` and `y` values of this object from a given polar coordinate.\r\n   *\r\n   * @method Phaser.Math.Vector2#setToPolar\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} azimuth - The angular coordinate, in radians.\r\n   * @param {number} [radius=1] - The radial coordinate (length).\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  setToPolar: function setToPolar(azimuth, radius) {\n    if (radius == null) {\n      radius = 1;\n    }\n\n    this.x = Math.cos(azimuth) * radius;\n    this.y = Math.sin(azimuth) * radius;\n    return this;\n  },\n\n  /**\r\n   * Check whether this Vector is equal to a given Vector.\r\n   *\r\n   * Performs a strict equality check against each Vector's components.\r\n   *\r\n   * @method Phaser.Math.Vector2#equals\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} v - The vector to compare with this Vector.\r\n   *\r\n   * @return {boolean} Whether the given Vector is equal to this Vector.\r\n   */\n  equals: function equals(v) {\n    return this.x === v.x && this.y === v.y;\n  },\n\n  /**\r\n   * Calculate the angle between this Vector and the positive x-axis, in radians.\r\n   *\r\n   * @method Phaser.Math.Vector2#angle\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The angle between this Vector, and the positive x-axis, given in radians.\r\n   */\n  angle: function angle() {\n    // computes the angle in radians with respect to the positive x-axis\n    var angle = Math.atan2(this.y, this.x);\n\n    if (angle < 0) {\n      angle += 2 * Math.PI;\n    }\n\n    return angle;\n  },\n\n  /**\r\n   * Add a given Vector to this Vector. Addition is component-wise.\r\n   *\r\n   * @method Phaser.Math.Vector2#add\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector to add to this Vector.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  add: function add(src) {\n    this.x += src.x;\n    this.y += src.y;\n    return this;\n  },\n\n  /**\r\n   * Subtract the given Vector from this Vector. Subtraction is component-wise.\r\n   *\r\n   * @method Phaser.Math.Vector2#subtract\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector to subtract from this Vector.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  subtract: function subtract(src) {\n    this.x -= src.x;\n    this.y -= src.y;\n    return this;\n  },\n\n  /**\r\n   * Perform a component-wise multiplication between this Vector and the given Vector.\r\n   *\r\n   * Multiplies this Vector by the given Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#multiply\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector to multiply this Vector by.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  multiply: function multiply(src) {\n    this.x *= src.x;\n    this.y *= src.y;\n    return this;\n  },\n\n  /**\r\n   * Scale this Vector by the given value.\r\n   *\r\n   * @method Phaser.Math.Vector2#scale\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The value to scale this Vector by.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  scale: function scale(value) {\n    if (isFinite(value)) {\n      this.x *= value;\n      this.y *= value;\n    } else {\n      this.x = 0;\n      this.y = 0;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Perform a component-wise division between this Vector and the given Vector.\r\n   *\r\n   * Divides this Vector by the given Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#divide\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector to divide this Vector by.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  divide: function divide(src) {\n    this.x /= src.x;\n    this.y /= src.y;\n    return this;\n  },\n\n  /**\r\n   * Negate the `x` and `y` components of this Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#negate\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  negate: function negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  },\n\n  /**\r\n   * Calculate the distance between this Vector and the given Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#distance\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.\r\n   *\r\n   * @return {number} The distance from this Vector to the given Vector.\r\n   */\n  distance: function distance(src) {\n    var dx = src.x - this.x;\n    var dy = src.y - this.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  },\n\n  /**\r\n   * Calculate the distance between this Vector and the given Vector, squared.\r\n   *\r\n   * @method Phaser.Math.Vector2#distanceSq\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.\r\n   *\r\n   * @return {number} The distance from this Vector to the given Vector, squared.\r\n   */\n  distanceSq: function distanceSq(src) {\n    var dx = src.x - this.x;\n    var dy = src.y - this.y;\n    return dx * dx + dy * dy;\n  },\n\n  /**\r\n   * Calculate the length (or magnitude) of this Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#length\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The length of this Vector.\r\n   */\n  length: function length() {\n    var x = this.x;\n    var y = this.y;\n    return Math.sqrt(x * x + y * y);\n  },\n\n  /**\r\n   * Calculate the length of this Vector squared.\r\n   *\r\n   * @method Phaser.Math.Vector2#lengthSq\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The length of this Vector, squared.\r\n   */\n  lengthSq: function lengthSq() {\n    var x = this.x;\n    var y = this.y;\n    return x * x + y * y;\n  },\n\n  /**\r\n   * Normalize this Vector.\r\n   *\r\n   * Makes the vector a unit length vector (magnitude of 1) in the same direction.\r\n   *\r\n   * @method Phaser.Math.Vector2#normalize\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  normalize: function normalize() {\n    var x = this.x;\n    var y = this.y;\n    var len = x * x + y * y;\n\n    if (len > 0) {\n      len = 1 / Math.sqrt(len);\n      this.x = x * len;\n      this.y = y * len;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Right-hand normalize (make unit length) this Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#normalizeRightHand\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  normalizeRightHand: function normalizeRightHand() {\n    var x = this.x;\n    this.x = this.y * -1;\n    this.y = x;\n    return this;\n  },\n\n  /**\r\n   * Calculate the dot product of this Vector and the given Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#dot\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector2 to dot product with this Vector2.\r\n   *\r\n   * @return {number} The dot product of this Vector and the given Vector.\r\n   */\n  dot: function dot(src) {\n    return this.x * src.x + this.y * src.y;\n  },\n\n  /**\r\n   * Calculate the cross product of this Vector and the given Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#cross\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector2 to cross with this Vector2.\r\n   *\r\n   * @return {number} The cross product of this Vector and the given Vector.\r\n   */\n  cross: function cross(src) {\n    return this.x * src.y - this.y * src.x;\n  },\n\n  /**\r\n   * Linearly interpolate between this Vector and the given Vector.\r\n   *\r\n   * Interpolates this Vector towards the given Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#lerp\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector2 to interpolate towards.\r\n   * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  lerp: function lerp(src, t) {\n    if (t === undefined) {\n      t = 0;\n    }\n\n    var ax = this.x;\n    var ay = this.y;\n    this.x = ax + t * (src.x - ax);\n    this.y = ay + t * (src.y - ay);\n    return this;\n  },\n\n  /**\r\n   * Transform this Vector with the given Matrix.\r\n   *\r\n   * @method Phaser.Math.Vector2#transformMat3\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector2 with.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  transformMat3: function transformMat3(mat) {\n    var x = this.x;\n    var y = this.y;\n    var m = mat.val;\n    this.x = m[0] * x + m[3] * y + m[6];\n    this.y = m[1] * x + m[4] * y + m[7];\n    return this;\n  },\n\n  /**\r\n   * Transform this Vector with the given Matrix.\r\n   *\r\n   * @method Phaser.Math.Vector2#transformMat4\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector2 with.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  transformMat4: function transformMat4(mat) {\n    var x = this.x;\n    var y = this.y;\n    var m = mat.val;\n    this.x = m[0] * x + m[4] * y + m[12];\n    this.y = m[1] * x + m[5] * y + m[13];\n    return this;\n  },\n\n  /**\r\n   * Make this Vector the zero vector (0, 0).\r\n   *\r\n   * @method Phaser.Math.Vector2#reset\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  reset: function reset() {\n    this.x = 0;\n    this.y = 0;\n    return this;\n  }\n});\n/**\r\n * A static zero Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.ZERO\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.1.0\r\n */\n\nVector2.ZERO = new Vector2();\n/**\r\n * A static right Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.RIGHT\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\n\nVector2.RIGHT = new Vector2(1, 0);\n/**\r\n * A static left Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.LEFT\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\n\nVector2.LEFT = new Vector2(-1, 0);\n/**\r\n * A static up Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.UP\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\n\nVector2.UP = new Vector2(0, -1);\n/**\r\n * A static down Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.DOWN\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\n\nVector2.DOWN = new Vector2(0, 1);\n/**\r\n * A static one Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.ONE\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\n\nVector2.ONE = new Vector2(1, 1);\nmodule.exports = Vector2;","map":null,"metadata":{},"sourceType":"script"}