{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar CanvasSnapshot = require('../snapshot/CanvasSnapshot');\n\nvar CameraEvents = require('../../cameras/2d/events');\n\nvar Class = require('../../utils/Class');\n\nvar CONST = require('../../const');\n\nvar GetBlendModes = require('./utils/GetBlendModes');\n\nvar ScaleModes = require('../ScaleModes');\n\nvar Smoothing = require('../../display/canvas/Smoothing');\n\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\n/**\r\n * @classdesc\r\n * The Canvas Renderer is responsible for managing 2D canvas rendering contexts, including the one used by the Game's canvas. It tracks the internal state of a given context and can renderer textured Game Objects to it, taking into account alpha, blending, and scaling.\r\n *\r\n * @class CanvasRenderer\r\n * @memberof Phaser.Renderer.Canvas\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser Game instance that owns this renderer.\r\n */\n\n\nvar CanvasRenderer = new Class({\n  initialize: function CanvasRenderer(game) {\n    /**\r\n     * The Phaser Game instance that owns this renderer.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#game\r\n     * @type {Phaser.Game}\r\n     * @since 3.0.0\r\n     */\n    this.game = game;\n    /**\r\n     * A constant which allows the renderer to be easily identified as a Canvas Renderer.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#type\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.type = CONST.CANVAS;\n    /**\r\n     * The total number of Game Objects which were rendered in a frame.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#drawCount\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.drawCount = 0;\n    /**\r\n     * The width of the canvas being rendered to.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#width\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.width = 0;\n    /**\r\n     * The height of the canvas being rendered to.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#height\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.height = 0;\n    /**\r\n     * The local configuration settings of the CanvasRenderer.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#config\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.config = {\n      clearBeforeRender: game.config.clearBeforeRender,\n      backgroundColor: game.config.backgroundColor,\n      resolution: game.config.resolution,\n      antialias: game.config.antialias,\n      roundPixels: game.config.roundPixels\n    };\n    /**\r\n     * The scale mode which should be used by the CanvasRenderer.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#scaleMode\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.scaleMode = game.config.antialias ? ScaleModes.LINEAR : ScaleModes.NEAREST;\n    /**\r\n     * The canvas element which the Game uses.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#gameCanvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.0.0\r\n     */\n\n    this.gameCanvas = game.canvas;\n    /**\r\n     * The canvas context used to render all Cameras in all Scenes during the game loop.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#gameContext\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.0.0\r\n     */\n\n    this.gameContext = this.game.config.context ? this.game.config.context : this.gameCanvas.getContext('2d');\n    /**\r\n     * The canvas context currently used by the CanvasRenderer for all rendering operations.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#currentContext\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.0.0\r\n     */\n\n    this.currentContext = this.gameContext;\n    /**\r\n     * The blend modes supported by the Canvas Renderer.\r\n     *\r\n     * This object maps the {@link Phaser.BlendModes} to canvas compositing operations.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#blendModes\r\n     * @type {array}\r\n     * @since 3.0.0\r\n     */\n\n    this.blendModes = GetBlendModes(); // image-rendering: optimizeSpeed;\n    // image-rendering: pixelated;\n\n    /**\r\n     * The scale mode currently in use by the Canvas Renderer.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#currentScaleMode\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.currentScaleMode = 0;\n    /**\r\n     * Details about the currently scheduled snapshot.\r\n     * \r\n     * If a non-null `callback` is set in this object, a snapshot of the canvas will be taken after the current frame is fully rendered.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#snapshotState\r\n     * @type {SnapshotState}\r\n     * @since 3.16.0\r\n     */\n\n    this.snapshotState = {\n      x: 0,\n      y: 0,\n      width: 1,\n      height: 1,\n      getPixel: false,\n      callback: null,\n      type: 'image/png',\n      encoder: 0.92\n    };\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix1\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix1 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix2\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix2 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix3\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix3 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix4\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix4 = new TransformMatrix();\n    this.init();\n  },\n\n  /**\r\n   * Prepares the game canvas for rendering.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#init\r\n   * @since 3.0.0\r\n   */\n  init: function init() {\n    this.game.scale.on('resize', this.onResize, this);\n    var baseSize = this.game.scale.baseSize;\n    this.resize(baseSize.width, baseSize.height);\n  },\n\n  /**\r\n   * The event handler that manages the `resize` event dispatched by the Scale Manager.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#onResize\r\n   * @since 3.16.0\r\n   *\r\n   * @param {Phaser.Structs.Size} gameSize - The default Game Size object. This is the un-modified game dimensions.\r\n   * @param {Phaser.Structs.Size} baseSize - The base Size object. The game dimensions multiplied by the resolution. The canvas width / height values match this.\r\n   * @param {Phaser.Structs.Size} displaySize - The display Size object. The size of the canvas style width / height attributes.\r\n   * @param {number} [resolution] - The Scale Manager resolution setting.\r\n   */\n  onResize: function onResize(gameSize, baseSize) {\n    //  Has the underlying canvas size changed?\n    if (baseSize.width !== this.width || baseSize.height !== this.height) {\n      this.resize(baseSize.width, baseSize.height);\n    }\n  },\n\n  /**\r\n   * Resize the main game canvas.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#resize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [width] - The new width of the renderer.\r\n   * @param {number} [height] - The new height of the renderer.\r\n   */\n  resize: function resize(width, height) {\n    this.width = width;\n    this.height = height; //  Resizing a canvas will reset imageSmoothingEnabled (and probably other properties)\n\n    if (this.scaleMode === ScaleModes.NEAREST) {\n      Smoothing.disable(this.gameContext);\n    }\n  },\n\n  /**\r\n   * A NOOP method for handling lost context. Intentionally empty.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#onContextLost\r\n   * @since 3.0.0\r\n   *\r\n   * @param {function} callback - Ignored parameter.\r\n   */\n  onContextLost: function onContextLost() {},\n\n  /**\r\n   * A NOOP method for handling restored context. Intentionally empty.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#onContextRestored\r\n   * @since 3.0.0\r\n   *\r\n   * @param {function} callback - Ignored parameter.\r\n   */\n  onContextRestored: function onContextRestored() {},\n\n  /**\r\n   * Resets the transformation matrix of the current context to the identity matrix, thus resetting any transformation.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#resetTransform\r\n   * @since 3.0.0\r\n   */\n  resetTransform: function resetTransform() {\n    this.currentContext.setTransform(1, 0, 0, 1, 0, 0);\n  },\n\n  /**\r\n   * Sets the blend mode (compositing operation) of the current context.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#setBlendMode\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} blendMode - The new blend mode which should be used.\r\n   *\r\n   * @return {this} This CanvasRenderer object.\r\n   */\n  setBlendMode: function setBlendMode(blendMode) {\n    this.currentContext.globalCompositeOperation = blendMode;\n    return this;\n  },\n\n  /**\r\n   * Changes the Canvas Rendering Context that all draw operations are performed against.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#setContext\r\n   * @since 3.12.0\r\n   *\r\n   * @param {?CanvasRenderingContext2D} [ctx] - The new Canvas Rendering Context to draw everything to. Leave empty to reset to the Game Canvas.\r\n   *\r\n   * @return {this} The Canvas Renderer instance.\r\n   */\n  setContext: function setContext(ctx) {\n    this.currentContext = ctx ? ctx : this.gameContext;\n    return this;\n  },\n\n  /**\r\n   * Sets the global alpha of the current context.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#setAlpha\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} alpha - The new alpha to use, where 0 is fully transparent and 1 is fully opaque.\r\n   *\r\n   * @return {this} This CanvasRenderer object.\r\n   */\n  setAlpha: function setAlpha(alpha) {\n    this.currentContext.globalAlpha = alpha;\n    return this;\n  },\n\n  /**\r\n   * Called at the start of the render loop.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#preRender\r\n   * @since 3.0.0\r\n   */\n  preRender: function preRender() {\n    var ctx = this.gameContext;\n    var config = this.config;\n    var width = this.width;\n    var height = this.height;\n    ctx.globalAlpha = 1;\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n    if (config.clearBeforeRender) {\n      ctx.clearRect(0, 0, width, height);\n    }\n\n    if (!config.transparent) {\n      ctx.fillStyle = config.backgroundColor.rgba;\n      ctx.fillRect(0, 0, width, height);\n    }\n\n    ctx.save();\n    this.drawCount = 0;\n  },\n\n  /**\r\n   * Renders the Scene to the given Camera.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#render\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Scene} scene - The Scene to render.\r\n   * @param {Phaser.GameObjects.DisplayList} children - The Game Objects within the Scene to be rendered.\r\n   * @param {number} interpolationPercentage - The interpolation percentage to apply. Currently unused.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera to render with.\r\n   */\n  render: function render(scene, children, interpolationPercentage, camera) {\n    var list = children.list;\n    var childCount = list.length;\n    var cx = camera._cx;\n    var cy = camera._cy;\n    var cw = camera._cw;\n    var ch = camera._ch;\n    var ctx = camera.renderToTexture ? camera.context : scene.sys.context; //  Save context pre-clip\n\n    ctx.save();\n\n    if (this.game.scene.customViewports) {\n      ctx.beginPath();\n      ctx.rect(cx, cy, cw, ch);\n      ctx.clip();\n    }\n\n    this.currentContext = ctx;\n\n    if (!camera.transparent) {\n      ctx.fillStyle = camera.backgroundColor.rgba;\n      ctx.fillRect(cx, cy, cw, ch);\n    }\n\n    ctx.globalAlpha = camera.alpha;\n    ctx.globalCompositeOperation = 'source-over';\n    this.drawCount += list.length;\n\n    if (camera.renderToTexture) {\n      camera.emit(CameraEvents.PRE_RENDER, camera);\n    }\n\n    camera.matrix.copyToContext(ctx);\n\n    for (var i = 0; i < childCount; i++) {\n      var child = list[i];\n\n      if (!child.willRender(camera)) {\n        continue;\n      }\n\n      if (child.mask) {\n        child.mask.preRenderCanvas(this, child, camera);\n      }\n\n      child.renderCanvas(this, child, interpolationPercentage, camera);\n\n      if (child.mask) {\n        child.mask.postRenderCanvas(this, child, camera);\n      }\n    }\n\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.globalAlpha = 1;\n    camera.flashEffect.postRenderCanvas(ctx);\n    camera.fadeEffect.postRenderCanvas(ctx);\n    camera.dirty = false; //  Restore pre-clip context\n\n    ctx.restore();\n\n    if (camera.renderToTexture) {\n      camera.emit(CameraEvents.POST_RENDER, camera);\n      scene.sys.context.drawImage(camera.canvas, cx, cy);\n    }\n  },\n\n  /**\r\n   * Restores the game context's global settings and takes a snapshot if one is scheduled.\r\n   *\r\n   * The post-render step happens after all Cameras in all Scenes have been rendered.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#postRender\r\n   * @since 3.0.0\r\n   */\n  postRender: function postRender() {\n    var ctx = this.gameContext;\n    ctx.restore();\n    var state = this.snapshotState;\n\n    if (state.callback) {\n      CanvasSnapshot(this.gameCanvas, state);\n      state.callback = null;\n    }\n  },\n\n  /**\r\n   * Schedules a snapshot of the entire game viewport to be taken after the current frame is rendered.\r\n   * \r\n   * To capture a specific area see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.\r\n   * \r\n   * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n   * calling this method will override it.\r\n   * \r\n   * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets\r\n   * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshot\r\n   * @since 3.0.0\r\n   *\r\n   * @param {SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n   * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n   * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n   *\r\n   * @return {this} This WebGL Renderer.\r\n   */\n  snapshot: function snapshot(callback, type, encoderOptions) {\n    return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, callback, type, encoderOptions);\n  },\n\n  /**\r\n   * Schedules a snapshot of the given area of the game viewport to be taken after the current frame is rendered.\r\n   * \r\n   * To capture the whole game viewport see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.\r\n   * \r\n   * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n   * calling this method will override it.\r\n   * \r\n   * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets\r\n   * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotArea\r\n   * @since 3.16.0\r\n   *\r\n   * @param {integer} x - The x coordinate to grab from.\r\n   * @param {integer} y - The y coordinate to grab from.\r\n   * @param {integer} width - The width of the area to grab.\r\n   * @param {integer} height - The height of the area to grab.\r\n   * @param {SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n   * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n   * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n   *\r\n   * @return {this} This WebGL Renderer.\r\n   */\n  snapshotArea: function snapshotArea(x, y, width, height, callback, type, encoderOptions) {\n    var state = this.snapshotState;\n    state.callback = callback;\n    state.type = type;\n    state.encoder = encoderOptions;\n    state.getPixel = false;\n    state.x = x;\n    state.y = y;\n    state.width = Math.min(width, this.gameCanvas.width);\n    state.height = Math.min(height, this.gameCanvas.height);\n    return this;\n  },\n\n  /**\r\n   * Schedules a snapshot of the given pixel from the game viewport to be taken after the current frame is rendered.\r\n   * \r\n   * To capture the whole game viewport see the `snapshot` method. To capture a specific area, see `snapshotArea`.\r\n   * \r\n   * Only one snapshot can be active _per frame_. If you have already called `snapshotArea`, for example, then\r\n   * calling this method will override it.\r\n   * \r\n   * Unlike the other two snapshot methods, this one will return a `Color` object containing the color data for\r\n   * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,\r\n   * using less memory.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotPixel\r\n   * @since 3.16.0\r\n   *\r\n   * @param {integer} x - The x coordinate of the pixel to get.\r\n   * @param {integer} y - The y coordinate of the pixel to get.\r\n   * @param {SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.\r\n   *\r\n   * @return {this} This WebGL Renderer.\r\n   */\n  snapshotPixel: function snapshotPixel(x, y, callback) {\n    this.snapshotArea(x, y, 1, 1, callback);\n    this.snapshotState.getPixel = true;\n    return this;\n  },\n\n  /**\r\n   * Takes a Sprite Game Object, or any object that extends it, and draws it to the current context.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#batchSprite\r\n   * @since 3.12.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} sprite - The texture based Game Object to draw.\r\n   * @param {Phaser.Textures.Frame} frame - The frame to draw, doesn't have to be that owned by the Game Object.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use for the rendering transform.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} [parentTransformMatrix] - The transform matrix of the parent container, if set.\r\n   */\n  batchSprite: function batchSprite(sprite, frame, camera, parentTransformMatrix) {\n    var alpha = camera.alpha * sprite.alpha;\n\n    if (alpha === 0) {\n      //  Nothing to see, so abort early\n      return;\n    }\n\n    var ctx = this.currentContext;\n    var camMatrix = this._tempMatrix1;\n    var spriteMatrix = this._tempMatrix2;\n    var calcMatrix = this._tempMatrix3;\n    var cd = frame.canvasData;\n    var frameX = cd.x;\n    var frameY = cd.y;\n    var frameWidth = frame.cutWidth;\n    var frameHeight = frame.cutHeight;\n    var res = frame.source.resolution;\n    var x = -sprite.displayOriginX + frame.x;\n    var y = -sprite.displayOriginY + frame.y;\n    var fx = sprite.flipX ? -1 : 1;\n    var fy = sprite.flipY ? -1 : 1;\n\n    if (sprite.isCropped) {\n      var crop = sprite._crop;\n\n      if (crop.flipX !== sprite.flipX || crop.flipY !== sprite.flipY) {\n        frame.updateCropUVs(crop, sprite.flipX, sprite.flipY);\n      }\n\n      frameWidth = crop.cw;\n      frameHeight = crop.ch;\n      frameX = crop.cx;\n      frameY = crop.cy;\n      x = -sprite.displayOriginX + crop.x;\n      y = -sprite.displayOriginY + crop.y;\n\n      if (fx === -1) {\n        if (x >= 0) {\n          x = -(x + frameWidth);\n        } else if (x < 0) {\n          x = Math.abs(x) - frameWidth;\n        }\n      }\n\n      if (fy === -1) {\n        if (y >= 0) {\n          y = -(y + frameHeight);\n        } else if (y < 0) {\n          y = Math.abs(y) - frameHeight;\n        }\n      }\n    }\n\n    spriteMatrix.applyITRS(sprite.x, sprite.y, sprite.rotation, sprite.scaleX, sprite.scaleY);\n    camMatrix.copyFrom(camera.matrix);\n\n    if (parentTransformMatrix) {\n      //  Multiply the camera by the parent matrix\n      camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * sprite.scrollFactorX, -camera.scrollY * sprite.scrollFactorY); //  Undo the camera scroll\n\n      spriteMatrix.e = sprite.x;\n      spriteMatrix.f = sprite.y; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n      camMatrix.multiply(spriteMatrix, calcMatrix);\n    } else {\n      spriteMatrix.e -= camera.scrollX * sprite.scrollFactorX;\n      spriteMatrix.f -= camera.scrollY * sprite.scrollFactorY; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n      camMatrix.multiply(spriteMatrix, calcMatrix);\n    }\n\n    ctx.save();\n    calcMatrix.setToContext(ctx);\n    ctx.scale(fx, fy);\n    ctx.globalCompositeOperation = this.blendModes[sprite.blendMode];\n    ctx.globalAlpha = alpha;\n    ctx.drawImage(frame.source.image, frameX, frameY, frameWidth, frameHeight, x, y, frameWidth / res, frameHeight / res);\n    ctx.restore();\n  },\n\n  /**\r\n   * Destroys all object references in the Canvas Renderer.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    this.gameCanvas = null;\n    this.gameContext = null;\n    this.game = null;\n  }\n});\nmodule.exports = CanvasRenderer;","map":null,"metadata":{},"sourceType":"script"}