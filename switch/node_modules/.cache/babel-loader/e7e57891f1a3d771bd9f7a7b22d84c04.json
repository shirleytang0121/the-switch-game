{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar Components = require('../../gameobjects/components');\n\nvar DegToRad = require('../../math/DegToRad');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar Rectangle = require('../../geom/rectangle/Rectangle');\n\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\n\nvar ValueToColor = require('../../display/color/ValueToColor');\n\nvar Vector2 = require('../../math/Vector2');\n/**\r\n * @typedef {object} JSONCameraBounds\r\n * @property {number} x - The horizontal position of camera\r\n * @property {number} y - The vertical position of camera\r\n * @property {number} width - The width size of camera\r\n * @property {number} height - The height size of camera\r\n */\n\n/**\r\n * @typedef {object} JSONCamera\r\n *\r\n * @property {string} name - The name of the camera\r\n * @property {number} x - The horizontal position of camera\r\n * @property {number} y - The vertical position of camera\r\n * @property {number} width - The width size of camera\r\n * @property {number} height - The height size of camera\r\n * @property {number} zoom - The zoom of camera\r\n * @property {number} rotation - The rotation of camera\r\n * @property {boolean} roundPixels - The round pixels st status of camera\r\n * @property {number} scrollX - The horizontal scroll of camera\r\n * @property {number} scrollY - The vertical scroll of camera\r\n * @property {string} backgroundColor - The background color of camera\r\n * @property {(JSONCameraBounds|undefined)} [bounds] - The bounds of camera\r\n */\n\n/**\r\n * @classdesc\r\n * A Base Camera class.\r\n *\r\n * The Camera is the way in which all games are rendered in Phaser. They provide a view into your game world,\r\n * and can be positioned, rotated, zoomed and scrolled accordingly.\r\n *\r\n * A Camera consists of two elements: The viewport and the scroll values.\r\n *\r\n * The viewport is the physical position and size of the Camera within your game. Cameras, by default, are\r\n * created the same size as your game, but their position and size can be set to anything. This means if you\r\n * wanted to create a camera that was 320x200 in size, positioned in the bottom-right corner of your game,\r\n * you'd adjust the viewport to do that (using methods like `setViewport` and `setSize`).\r\n *\r\n * If you wish to change where the Camera is looking in your game, then you scroll it. You can do this\r\n * via the properties `scrollX` and `scrollY` or the method `setScroll`. Scrolling has no impact on the\r\n * viewport, and changing the viewport has no impact on the scrolling.\r\n *\r\n * By default a Camera will render all Game Objects it can see. You can change this using the `ignore` method,\r\n * allowing you to filter Game Objects out on a per-Camera basis.\r\n * \r\n * The Base Camera is extended by the Camera class, which adds in special effects including Fade,\r\n * Flash and Camera Shake, as well as the ability to follow Game Objects.\r\n * \r\n * The Base Camera was introduced in Phaser 3.12. It was split off from the Camera class, to allow\r\n * you to isolate special effects as needed. Therefore the 'since' values for properties of this class relate\r\n * to when they were added to the Camera class.\r\n *\r\n * @class BaseCamera\r\n * @memberof Phaser.Cameras.Scene2D\r\n * @constructor\r\n * @since 3.12.0\r\n * \r\n * @extends Phaser.Events.EventEmitter\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {number} x - The x position of the Camera, relative to the top-left of the game canvas.\r\n * @param {number} y - The y position of the Camera, relative to the top-left of the game canvas.\r\n * @param {number} width - The width of the Camera, in pixels.\r\n * @param {number} height - The height of the Camera, in pixels.\r\n */\n\n\nvar BaseCamera = new Class({\n  Extends: EventEmitter,\n  Mixins: [Components.Alpha, Components.Visible],\n  initialize: function BaseCamera(x, y, width, height) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = 0;\n    }\n\n    if (height === undefined) {\n      height = 0;\n    }\n\n    EventEmitter.call(this);\n    /**\r\n     * A reference to the Scene this camera belongs to.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n\n    this.scene;\n    /**\r\n     * A reference to the Game Scene Manager.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#sceneManager\r\n     * @type {Phaser.Scenes.SceneManager}\r\n     * @since 3.12.0\r\n     */\n\n    this.sceneManager;\n    /**\r\n     * A reference to the Game Scale Manager.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#scaleManager\r\n     * @type {Phaser.Scale.ScaleManager}\r\n     * @since 3.16.0\r\n     */\n\n    this.scaleManager;\n    /**\r\n     * The Camera ID. Assigned by the Camera Manager and used to handle camera exclusion.\r\n     * This value is a bitmask.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#id\r\n     * @type {integer}\r\n     * @readonly\r\n     * @since 3.11.0\r\n     */\n\n    this.id = 0;\n    /**\r\n     * The name of the Camera. This is left empty for your own use.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#name\r\n     * @type {string}\r\n     * @default ''\r\n     * @since 3.0.0\r\n     */\n\n    this.name = '';\n    /**\r\n     * This property is un-used in v3.16.\r\n     * \r\n     * The resolution of the Game, used in most Camera calculations.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#resolution\r\n     * @type {number}\r\n     * @readonly\r\n     * @deprecated\r\n     * @since 3.12.0\r\n     */\n\n    this.resolution = 1;\n    /**\r\n     * Should this camera round its pixel values to integers?\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#roundPixels\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.roundPixels = false;\n    /**\r\n     * Is this Camera visible or not?\r\n     *\r\n     * A visible camera will render and perform input tests.\r\n     * An invisible camera will not render anything and will skip input tests.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#visible\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.10.0\r\n     */\n\n    /**\r\n     * Is this Camera using a bounds to restrict scrolling movement?\r\n     *\r\n     * Set this property along with the bounds via `Camera.setBounds`.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#useBounds\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.useBounds = false;\n    /**\r\n     * The World View is a Rectangle that defines the area of the 'world' the Camera is currently looking at.\r\n     * This factors in the Camera viewport size, zoom and scroll position and is updated in the Camera preRender step.\r\n     * If you have enabled Camera bounds the worldview will be clamped to those bounds accordingly.\r\n     * You can use it for culling or intersection checks.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#worldView\r\n     * @type {Phaser.Geom.Rectangle}\r\n     * @readonly\r\n     * @since 3.11.0\r\n     */\n\n    this.worldView = new Rectangle();\n    /**\r\n     * Is this Camera dirty?\r\n     * \r\n     * A dirty Camera has had either its viewport size, bounds, scroll, rotation or zoom levels changed since the last frame.\r\n     * \r\n     * This flag is cleared during the `postRenderCamera` method of the renderer.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#dirty\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.11.0\r\n     */\n\n    this.dirty = true;\n    /**\r\n     * The x position of the Camera viewport, relative to the top-left of the game canvas.\r\n     * The viewport is the area into which the camera renders.\r\n     * To adjust the position the camera is looking at in the game world, see the `scrollX` value.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#x\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._x = x;\n    /**\r\n     * The y position of the Camera, relative to the top-left of the game canvas.\r\n     * The viewport is the area into which the camera renders.\r\n     * To adjust the position the camera is looking at in the game world, see the `scrollY` value.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#y\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._y = y;\n    /**\r\n     * Internal Camera X value multiplied by the resolution.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_cx\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._cx = 0;\n    /**\r\n     * Internal Camera Y value multiplied by the resolution.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_cy\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._cy = 0;\n    /**\r\n     * Internal Camera Width value multiplied by the resolution.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_cw\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._cw = 0;\n    /**\r\n     * Internal Camera Height value multiplied by the resolution.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_ch\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._ch = 0;\n    /**\r\n     * The width of the Camera viewport, in pixels.\r\n     *\r\n     * The viewport is the area into which the Camera renders. Setting the viewport does\r\n     * not restrict where the Camera can scroll to.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_width\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.11.0\r\n     */\n\n    this._width = width;\n    /**\r\n     * The height of the Camera viewport, in pixels.\r\n     *\r\n     * The viewport is the area into which the Camera renders. Setting the viewport does\r\n     * not restrict where the Camera can scroll to.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_height\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.11.0\r\n     */\n\n    this._height = height;\n    /**\r\n     * The bounds the camera is restrained to during scrolling.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_bounds\r\n     * @type {Phaser.Geom.Rectangle}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._bounds = new Rectangle();\n    /**\r\n     * The horizontal scroll position of this Camera.\r\n     *\r\n     * Change this value to cause the Camera to scroll around your Scene.\r\n     *\r\n     * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,\r\n     * will automatically adjust the Camera scroll values accordingly.\r\n     *\r\n     * You can set the bounds within which the Camera can scroll via the `setBounds` method.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_scrollX\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.11.0\r\n     */\n\n    this._scrollX = 0;\n    /**\r\n     * The vertical scroll position of this Camera.\r\n     *\r\n     * Change this value to cause the Camera to scroll around your Scene.\r\n     *\r\n     * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,\r\n     * will automatically adjust the Camera scroll values accordingly.\r\n     *\r\n     * You can set the bounds within which the Camera can scroll via the `setBounds` method.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_scrollY\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.11.0\r\n     */\n\n    this._scrollY = 0;\n    /**\r\n     * The Camera zoom value. Change this value to zoom in, or out of, a Scene.\r\n     *\r\n     * A value of 0.5 would zoom the Camera out, so you can now see twice as much\r\n     * of the Scene as before. A value of 2 would zoom the Camera in, so every pixel\r\n     * now takes up 2 pixels when rendered.\r\n     *\r\n     * Set to 1 to return to the default zoom level.\r\n     *\r\n     * Be careful to never set this value to zero.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_zoom\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.11.0\r\n     */\n\n    this._zoom = 1;\n    /**\r\n     * The rotation of the Camera in radians.\r\n     *\r\n     * Camera rotation always takes place based on the Camera viewport. By default, rotation happens\r\n     * in the center of the viewport. You can adjust this with the `originX` and `originY` properties.\r\n     *\r\n     * Rotation influences the rendering of _all_ Game Objects visible by this Camera. However, it does not\r\n     * rotate the Camera viewport itself, which always remains an axis-aligned rectangle.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_rotation\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.11.0\r\n     */\n\n    this._rotation = 0;\n    /**\r\n     * A local transform matrix used for internal calculations.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#matrix\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this.matrix = new TransformMatrix();\n    /**\r\n     * Does this Camera have a transparent background?\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#transparent\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.transparent = true;\n    /**\r\n     * The background color of this Camera. Only used if `transparent` is `false`.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#backgroundColor\r\n     * @type {Phaser.Display.Color}\r\n     * @since 3.0.0\r\n     */\n\n    this.backgroundColor = ValueToColor('rgba(0,0,0,0)');\n    /**\r\n     * The Camera alpha value. Setting this property impacts every single object that this Camera\r\n     * renders. You can either set the property directly, i.e. via a Tween, to fade a Camera in or out,\r\n     * or via the chainable `setAlpha` method instead.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#alpha\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.11.0\r\n     */\n\n    /**\r\n     * Should the camera cull Game Objects before checking them for input hit tests?\r\n     * In some special cases it may be beneficial to disable this.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#disableCull\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.disableCull = false;\n    /**\r\n     * A temporary array of culled objects.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#culledObjects\r\n     * @type {Phaser.GameObjects.GameObject[]}\r\n     * @default []\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this.culledObjects = [];\n    /**\r\n     * The mid-point of the Camera in 'world' coordinates.\r\n     *\r\n     * Use it to obtain exactly where in the world the center of the camera is currently looking.\r\n     *\r\n     * This value is updated in the preRender method, after the scroll values and follower\r\n     * have been processed.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#midPoint\r\n     * @type {Phaser.Math.Vector2}\r\n     * @readonly\r\n     * @since 3.11.0\r\n     */\n\n    this.midPoint = new Vector2(width / 2, height / 2);\n    /**\r\n     * The horizontal origin of rotation for this Camera.\r\n     *\r\n     * By default the camera rotates around the center of the viewport.\r\n     *\r\n     * Changing the origin allows you to adjust the point in the viewport from which rotation happens.\r\n     * A value of 0 would rotate from the top-left of the viewport. A value of 1 from the bottom right.\r\n     *\r\n     * See `setOrigin` to set both origins in a single, chainable call.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#originX\r\n     * @type {number}\r\n     * @default 0.5\r\n     * @since 3.11.0\r\n     */\n\n    this.originX = 0.5;\n    /**\r\n     * The vertical origin of rotation for this Camera.\r\n     *\r\n     * By default the camera rotates around the center of the viewport.\r\n     *\r\n     * Changing the origin allows you to adjust the point in the viewport from which rotation happens.\r\n     * A value of 0 would rotate from the top-left of the viewport. A value of 1 from the bottom right.\r\n     *\r\n     * See `setOrigin` to set both origins in a single, chainable call.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#originY\r\n     * @type {number}\r\n     * @default 0.5\r\n     * @since 3.11.0\r\n     */\n\n    this.originY = 0.5;\n    /**\r\n     * Does this Camera have a custom viewport?\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_customViewport\r\n     * @type {boolean}\r\n     * @private\r\n     * @default false\r\n     * @since 3.12.0\r\n     */\n\n    this._customViewport = false;\n  },\n\n  /**\r\n   * Set the Alpha level of this Camera. The alpha controls the opacity of the Camera as it renders.\r\n   * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setAlpha\r\n   * @since 3.11.0\r\n   *\r\n   * @param {number} [value=1] - The Camera alpha value.\r\n   *\r\n   * @return {this} This Camera instance.\r\n   */\n\n  /**\r\n   * Sets the rotation origin of this Camera.\r\n   *\r\n   * The values are given in the range 0 to 1 and are only used when calculating Camera rotation.\r\n   *\r\n   * By default the camera rotates around the center of the viewport.\r\n   *\r\n   * Changing the origin allows you to adjust the point in the viewport from which rotation happens.\r\n   * A value of 0 would rotate from the top-left of the viewport. A value of 1 from the bottom right.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setOrigin\r\n   * @since 3.11.0\r\n   *\r\n   * @param {number} [x=0.5] - The horizontal origin value.\r\n   * @param {number} [y=x] - The vertical origin value. If not defined it will be set to the value of `x`.\r\n   *\r\n   * @return {this} This Camera instance.\r\n   */\n  setOrigin: function setOrigin(x, y) {\n    if (x === undefined) {\n      x = 0.5;\n    }\n\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.originX = x;\n    this.originY = y;\n    return this;\n  },\n\n  /**\r\n   * Calculates what the Camera.scrollX and scrollY values would need to be in order to move\r\n   * the Camera so it is centered on the given x and y coordinates, without actually moving\r\n   * the Camera there. The results are clamped based on the Camera bounds, if set.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#getScroll\r\n   * @since 3.11.0\r\n   *\r\n   * @param {number} x - The horizontal coordinate to center on.\r\n   * @param {number} y - The vertical coordinate to center on.\r\n   * @param {Phaser.Math.Vector2} [out] - A Vec2 to store the values in. If not given a new Vec2 is created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The scroll coordinates stored in the `x` and `y` properties.\r\n   */\n  getScroll: function getScroll(x, y, out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    var originX = this.width * 0.5;\n    var originY = this.height * 0.5;\n    out.x = x - originX;\n    out.y = y - originY;\n\n    if (this.useBounds) {\n      out.x = this.clampX(out.x);\n      out.y = this.clampY(out.y);\n    }\n\n    return out;\n  },\n\n  /**\r\n   * Moves the Camera horizontally so that it is centered on the given x coordinate, bounds allowing.\r\n   * Calling this does not change the scrollY value.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#centerOnX\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} x - The horizontal coordinate to center on.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  centerOnX: function centerOnX(x) {\n    var originX = this.width * 0.5;\n    this.midPoint.x = x;\n    this.scrollX = x - originX;\n\n    if (this.useBounds) {\n      this.scrollX = this.clampX(this.scrollX);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Moves the Camera vertically so that it is centered on the given y coordinate, bounds allowing.\r\n   * Calling this does not change the scrollX value.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#centerOnY\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} y - The vertical coordinate to center on.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  centerOnY: function centerOnY(y) {\n    var originY = this.height * 0.5;\n    this.midPoint.y = y;\n    this.scrollY = y - originY;\n\n    if (this.useBounds) {\n      this.scrollY = this.clampY(this.scrollY);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Moves the Camera so that it is centered on the given coordinates, bounds allowing.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#centerOn\r\n   * @since 3.11.0\r\n   *\r\n   * @param {number} x - The horizontal coordinate to center on.\r\n   * @param {number} y - The vertical coordinate to center on.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  centerOn: function centerOn(x, y) {\n    this.centerOnX(x);\n    this.centerOnY(y);\n    return this;\n  },\n\n  /**\r\n   * Moves the Camera so that it is looking at the center of the Camera Bounds, if enabled.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#centerToBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  centerToBounds: function centerToBounds() {\n    if (this.useBounds) {\n      var bounds = this._bounds;\n      var originX = this.width * 0.5;\n      var originY = this.height * 0.5;\n      this.midPoint.set(bounds.centerX, bounds.centerY);\n      this.scrollX = bounds.centerX - originX;\n      this.scrollY = bounds.centerY - originY;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Moves the Camera so that it is re-centered based on its viewport size.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#centerToSize\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  centerToSize: function centerToSize() {\n    this.scrollX = this.width * 0.5;\n    this.scrollY = this.height * 0.5;\n    return this;\n  },\n\n  /**\r\n   * Takes an array of Game Objects and returns a new array featuring only those objects\r\n   * visible by this camera.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#cull\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.GameObjects.GameObject[]} G - [renderableObjects,$return]\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject[]} renderableObjects - An array of Game Objects to cull.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject[]} An array of Game Objects visible to this Camera.\r\n   */\n  cull: function cull(renderableObjects) {\n    if (this.disableCull) {\n      return renderableObjects;\n    }\n\n    var cameraMatrix = this.matrix.matrix;\n    var mva = cameraMatrix[0];\n    var mvb = cameraMatrix[1];\n    var mvc = cameraMatrix[2];\n    var mvd = cameraMatrix[3];\n    /* First Invert Matrix */\n\n    var determinant = mva * mvd - mvb * mvc;\n\n    if (!determinant) {\n      return renderableObjects;\n    }\n\n    var mve = cameraMatrix[4];\n    var mvf = cameraMatrix[5];\n    var scrollX = this.scrollX;\n    var scrollY = this.scrollY;\n    var cameraW = this.width;\n    var cameraH = this.height;\n    var culledObjects = this.culledObjects;\n    var length = renderableObjects.length;\n    determinant = 1 / determinant;\n    culledObjects.length = 0;\n\n    for (var index = 0; index < length; ++index) {\n      var object = renderableObjects[index];\n\n      if (!object.hasOwnProperty('width') || object.parentContainer) {\n        culledObjects.push(object);\n        continue;\n      }\n\n      var objectW = object.width;\n      var objectH = object.height;\n      var objectX = object.x - scrollX * object.scrollFactorX - objectW * object.originX;\n      var objectY = object.y - scrollY * object.scrollFactorY - objectH * object.originY;\n      var tx = objectX * mva + objectY * mvc + mve;\n      var ty = objectX * mvb + objectY * mvd + mvf;\n      var tw = (objectX + objectW) * mva + (objectY + objectH) * mvc + mve;\n      var th = (objectX + objectW) * mvb + (objectY + objectH) * mvd + mvf;\n      var cullTop = this.y;\n      var cullBottom = cullTop + cameraH;\n      var cullLeft = this.x;\n      var cullRight = cullLeft + cameraW;\n\n      if (tw > cullLeft && tx < cullRight && th > cullTop && ty < cullBottom) {\n        culledObjects.push(object);\n      }\n    }\n\n    return culledObjects;\n  },\n\n  /**\r\n   * Converts the given `x` and `y` coordinates into World space, based on this Cameras transform.\r\n   * You can optionally provide a Vector2, or similar object, to store the results in.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#getWorldPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {number} x - The x position to convert to world space.\r\n   * @param {number} y - The y position to convert to world space.\r\n   * @param {(object|Phaser.Math.Vector2)} [output] - An optional object to store the results in. If not provided a new Vector2 will be created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} An object holding the converted values in its `x` and `y` properties.\r\n   */\n  getWorldPoint: function getWorldPoint(x, y, output) {\n    if (output === undefined) {\n      output = new Vector2();\n    }\n\n    var cameraMatrix = this.matrix.matrix;\n    var mva = cameraMatrix[0];\n    var mvb = cameraMatrix[1];\n    var mvc = cameraMatrix[2];\n    var mvd = cameraMatrix[3];\n    var mve = cameraMatrix[4];\n    var mvf = cameraMatrix[5]; //  Invert Matrix\n\n    var determinant = mva * mvd - mvb * mvc;\n\n    if (!determinant) {\n      output.x = x;\n      output.y = y;\n      return output;\n    }\n\n    determinant = 1 / determinant;\n    var ima = mvd * determinant;\n    var imb = -mvb * determinant;\n    var imc = -mvc * determinant;\n    var imd = mva * determinant;\n    var ime = (mvc * mvf - mvd * mve) * determinant;\n    var imf = (mvb * mve - mva * mvf) * determinant;\n    var c = Math.cos(this.rotation);\n    var s = Math.sin(this.rotation);\n    var zoom = this.zoom;\n    var res = this.resolution;\n    var scrollX = this.scrollX;\n    var scrollY = this.scrollY; //  Works for zoom of 1 with any resolution, but resolution > 1 and zoom !== 1 breaks\n\n    var sx = x + (scrollX * c - scrollY * s) * zoom;\n    var sy = y + (scrollX * s + scrollY * c) * zoom; //  Apply transform to point\n\n    output.x = (sx * ima + sy * imc) * res + ime;\n    output.y = (sx * imb + sy * imd) * res + imf;\n    return output;\n  },\n\n  /**\r\n   * Given a Game Object, or an array of Game Objects, it will update all of their camera filter settings\r\n   * so that they are ignored by this Camera. This means they will not be rendered by this Camera.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#ignore\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group)} entries - The Game Object, or array of Game Objects, to be ignored by this Camera.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  ignore: function ignore(entries) {\n    var id = this.id;\n\n    if (!Array.isArray(entries)) {\n      entries = [entries];\n    }\n\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n\n      if (Array.isArray(entry)) {\n        this.ignore(entry);\n      } else if (entry.isParent) {\n        this.ignore(entry.getChildren());\n      } else {\n        entry.cameraFilter |= id;\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Internal preRender step.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#preRender\r\n   * @protected\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} resolution - The game resolution, as set in the Scale Manager.\r\n   */\n  preRender: function preRender(resolution) {\n    var width = this.width;\n    var height = this.height;\n    var halfWidth = width * 0.5;\n    var halfHeight = height * 0.5;\n    var zoom = this.zoom * resolution;\n    var matrix = this.matrix;\n    var originX = width * this.originX;\n    var originY = height * this.originY;\n    var sx = this.scrollX;\n    var sy = this.scrollY;\n\n    if (this.useBounds) {\n      sx = this.clampX(sx);\n      sy = this.clampY(sy);\n    }\n\n    if (this.roundPixels) {\n      originX = Math.round(originX);\n      originY = Math.round(originY);\n    } //  Values are in pixels and not impacted by zooming the Camera\n\n\n    this.scrollX = sx;\n    this.scrollY = sy;\n    var midX = sx + halfWidth;\n    var midY = sy + halfHeight; //  The center of the camera, in world space, so taking zoom into account\n    //  Basically the pixel value of what it's looking at in the middle of the cam\n\n    this.midPoint.set(midX, midY);\n    var displayWidth = width / zoom;\n    var displayHeight = height / zoom;\n    this.worldView.setTo(midX - displayWidth / 2, midY - displayHeight / 2, displayWidth, displayHeight);\n    matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoom, zoom);\n    matrix.translate(-originX, -originY);\n  },\n\n  /**\r\n   * Takes an x value and checks it's within the range of the Camera bounds, adjusting if required.\r\n   * Do not call this method if you are not using camera bounds.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#clampX\r\n   * @since 3.11.0\r\n   *\r\n   * @param {number} x - The value to horizontally scroll clamp.\r\n   *\r\n   * @return {number} The adjusted value to use as scrollX.\r\n   */\n  clampX: function clampX(x) {\n    var bounds = this._bounds;\n    var dw = this.displayWidth;\n    var bx = bounds.x + (dw - this.width) / 2;\n    var bw = Math.max(bx, bx + bounds.width - dw);\n\n    if (x < bx) {\n      x = bx;\n    } else if (x > bw) {\n      x = bw;\n    }\n\n    return x;\n  },\n\n  /**\r\n   * Takes a y value and checks it's within the range of the Camera bounds, adjusting if required.\r\n   * Do not call this method if you are not using camera bounds.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#clampY\r\n   * @since 3.11.0\r\n   *\r\n   * @param {number} y - The value to vertically scroll clamp.\r\n   *\r\n   * @return {number} The adjusted value to use as scrollY.\r\n   */\n  clampY: function clampY(y) {\n    var bounds = this._bounds;\n    var dh = this.displayHeight;\n    var by = bounds.y + (dh - this.height) / 2;\n    var bh = Math.max(by, by + bounds.height - dh);\n\n    if (y < by) {\n      y = by;\n    } else if (y > bh) {\n      y = bh;\n    }\n\n    return y;\n  },\n\n  /*\r\n      var gap = this._zoomInversed;\r\n      return gap * Math.round((src.x - this.scrollX * src.scrollFactorX) / gap);\r\n  */\n\n  /**\r\n   * If this Camera has previously had movement bounds set on it, this will remove them.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#removeBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  removeBounds: function removeBounds() {\n    this.useBounds = false;\n    this.dirty = true;\n\n    this._bounds.setEmpty();\n\n    return this;\n  },\n\n  /**\r\n   * Set the rotation of this Camera. This causes everything it renders to appear rotated.\r\n   *\r\n   * Rotating a camera does not rotate the viewport itself, it is applied during rendering.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setAngle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [value=0] - The cameras angle of rotation, given in degrees.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setAngle: function setAngle(value) {\n    if (value === undefined) {\n      value = 0;\n    }\n\n    this.rotation = DegToRad(value);\n    return this;\n  },\n\n  /**\r\n   * Sets the background color for this Camera.\r\n   *\r\n   * By default a Camera has a transparent background but it can be given a solid color, with any level\r\n   * of transparency, via this method.\r\n   *\r\n   * The color value can be specified using CSS color notation, hex or numbers.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setBackgroundColor\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|number|InputColorObject)} [color='rgba(0,0,0,0)'] - The color value. In CSS, hex or numeric color notation.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setBackgroundColor: function setBackgroundColor(color) {\n    if (color === undefined) {\n      color = 'rgba(0,0,0,0)';\n    }\n\n    this.backgroundColor = ValueToColor(color);\n    this.transparent = this.backgroundColor.alpha === 0;\n    return this;\n  },\n\n  /**\r\n   * Set the bounds of the Camera. The bounds are an axis-aligned rectangle.\r\n   * \r\n   * The Camera bounds controls where the Camera can scroll to, stopping it from scrolling off the\r\n   * edges and into blank space. It does not limit the placement of Game Objects, or where\r\n   * the Camera viewport can be positioned.\r\n   * \r\n   * Temporarily disable the bounds by changing the boolean `Camera.useBounds`.\r\n   * \r\n   * Clear the bounds entirely by calling `Camera.removeBounds`.\r\n   * \r\n   * If you set bounds that are smaller than the viewport it will stop the Camera from being\r\n   * able to scroll. The bounds can be positioned where-ever you wish. By default they are from\r\n   * 0x0 to the canvas width x height. This means that the coordinate 0x0 is the top left of\r\n   * the Camera bounds. However, you can position them anywhere. So if you wanted a game world\r\n   * that was 2048x2048 in size, with 0x0 being the center of it, you can set the bounds x/y\r\n   * to be -1024, -1024, with a width and height of 2048. Depending on your game you may find\r\n   * it easier for 0x0 to be the top-left of the bounds, or you may wish 0x0 to be the middle.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} x - The top-left x coordinate of the bounds.\r\n   * @param {integer} y - The top-left y coordinate of the bounds.\r\n   * @param {integer} width - The width of the bounds, in pixels.\r\n   * @param {integer} height - The height of the bounds, in pixels.\r\n   * @param {boolean} [centerOn=false] - If `true` the Camera will automatically be centered on the new bounds.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setBounds: function setBounds(x, y, width, height, centerOn) {\n    if (centerOn === undefined) {\n      centerOn = false;\n    }\n\n    this._bounds.setTo(x, y, width, height);\n\n    this.dirty = true;\n    this.useBounds = true;\n\n    if (centerOn) {\n      this.centerToBounds();\n    } else {\n      this.scrollX = this.clampX(this.scrollX);\n      this.scrollY = this.clampY(this.scrollY);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Returns a rectangle containing the bounds of the Camera.\r\n   * \r\n   * If the Camera does not have any bounds the rectangle will be empty.\r\n   * \r\n   * The rectangle is a copy of the bounds, so is safe to modify.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#getBounds\r\n   * @since 3.16.0\r\n   *\r\n   * @param {Phaser.Geom.Rectangle} [out] - An optional Rectangle to store the bounds in. If not given, a new Rectangle will be created.\r\n   *\r\n   * @return {Phaser.Geom.Rectangle} A rectangle containing the bounds of this Camera.\r\n   */\n  getBounds: function getBounds(out) {\n    if (out === undefined) {\n      out = new Rectangle();\n    }\n\n    var source = this._bounds;\n    out.setTo(source.x, source.y, source.width, source.height);\n    return out;\n  },\n\n  /**\r\n   * Sets the name of this Camera.\r\n   * This value is for your own use and isn't used internally.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setName\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [value=''] - The name of the Camera.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setName: function setName(value) {\n    if (value === undefined) {\n      value = '';\n    }\n\n    this.name = value;\n    return this;\n  },\n\n  /**\r\n   * Set the position of the Camera viewport within the game.\r\n   *\r\n   * This does not change where the camera is 'looking'. See `setScroll` to control that.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setPosition\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The top-left x coordinate of the Camera viewport.\r\n   * @param {number} [y=x] - The top-left y coordinate of the Camera viewport.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setPosition: function setPosition(x, y) {\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n\n  /**\r\n   * Set the rotation of this Camera. This causes everything it renders to appear rotated.\r\n   *\r\n   * Rotating a camera does not rotate the viewport itself, it is applied during rendering.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setRotation\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [value=0] - The rotation of the Camera, in radians.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setRotation: function setRotation(value) {\n    if (value === undefined) {\n      value = 0;\n    }\n\n    this.rotation = value;\n    return this;\n  },\n\n  /**\r\n   * Should the Camera round pixel values to whole integers when rendering Game Objects?\r\n   * \r\n   * In some types of game, especially with pixel art, this is required to prevent sub-pixel aliasing.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setRoundPixels\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - `true` to round Camera pixels, `false` to not.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setRoundPixels: function setRoundPixels(value) {\n    this.roundPixels = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Scene the Camera is bound to.\r\n   * \r\n   * Also populates the `resolution` property and updates the internal size values.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setScene\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Scene} scene - The Scene the camera is bound to.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setScene: function setScene(scene) {\n    if (this.scene && this._customViewport) {\n      this.sceneManager.customViewports--;\n    }\n\n    this.scene = scene;\n    this.sceneManager = scene.sys.game.scene;\n    this.scaleManager = scene.sys.scale;\n    var res = this.scaleManager.resolution;\n    this.resolution = res;\n    this._cx = this._x * res;\n    this._cy = this._y * res;\n    this._cw = this._width * res;\n    this._ch = this._height * res;\n    this.updateSystem();\n    return this;\n  },\n\n  /**\r\n   * Set the position of where the Camera is looking within the game.\r\n   * You can also modify the properties `Camera.scrollX` and `Camera.scrollY` directly.\r\n   * Use this method, or the scroll properties, to move your camera around the game world.\r\n   *\r\n   * This does not change where the camera viewport is placed. See `setPosition` to control that.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setScroll\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The x coordinate of the Camera in the game world.\r\n   * @param {number} [y=x] - The y coordinate of the Camera in the game world.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setScroll: function setScroll(x, y) {\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.scrollX = x;\n    this.scrollY = y;\n    return this;\n  },\n\n  /**\r\n   * Set the size of the Camera viewport.\r\n   *\r\n   * By default a Camera is the same size as the game, but can be made smaller via this method,\r\n   * allowing you to create mini-cam style effects by creating and positioning a smaller Camera\r\n   * viewport within your game.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setSize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} width - The width of the Camera viewport.\r\n   * @param {integer} [height=width] - The height of the Camera viewport.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setSize: function setSize(width, height) {\n    if (height === undefined) {\n      height = width;\n    }\n\n    this.width = width;\n    this.height = height;\n    return this;\n  },\n\n  /**\r\n   * This method sets the position and size of the Camera viewport in a single call.\r\n   *\r\n   * If you're trying to change where the Camera is looking at in your game, then see\r\n   * the method `Camera.setScroll` instead. This method is for changing the viewport\r\n   * itself, not what the camera can see.\r\n   *\r\n   * By default a Camera is the same size as the game, but can be made smaller via this method,\r\n   * allowing you to create mini-cam style effects by creating and positioning a smaller Camera\r\n   * viewport within your game.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setViewport\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The top-left x coordinate of the Camera viewport.\r\n   * @param {number} y - The top-left y coordinate of the Camera viewport.\r\n   * @param {integer} width - The width of the Camera viewport.\r\n   * @param {integer} [height=width] - The height of the Camera viewport.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setViewport: function setViewport(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    return this;\n  },\n\n  /**\r\n   * Set the zoom value of the Camera.\r\n   *\r\n   * Changing to a smaller value, such as 0.5, will cause the camera to 'zoom out'.\r\n   * Changing to a larger value, such as 2, will cause the camera to 'zoom in'.\r\n   *\r\n   * A value of 1 means 'no zoom' and is the default.\r\n   *\r\n   * Changing the zoom does not impact the Camera viewport in any way, it is only applied during rendering.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setZoom\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [value=1] - The zoom value of the Camera. The minimum it can be is 0.001.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setZoom: function setZoom(value) {\n    if (value === undefined) {\n      value = 1;\n    }\n\n    if (value === 0) {\n      value = 0.001;\n    }\n\n    this.zoom = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the visibility of this Camera.\r\n   *\r\n   * An invisible Camera will skip rendering and input tests of everything it can see.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setVisible\r\n   * @since 3.10.0\r\n   *\r\n   * @param {boolean} value - The visible state of the Camera.\r\n   *\r\n   * @return {this} This Camera instance.\r\n   */\n\n  /**\r\n   * Returns an Object suitable for JSON storage containing all of the Camera viewport and rendering properties.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#toJSON\r\n   * @since 3.0.0\r\n   *\r\n   * @return {JSONCamera} A well-formed object suitable for conversion to JSON.\r\n   */\n  toJSON: function toJSON() {\n    var output = {\n      name: this.name,\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height,\n      zoom: this.zoom,\n      rotation: this.rotation,\n      roundPixels: this.roundPixels,\n      scrollX: this.scrollX,\n      scrollY: this.scrollY,\n      backgroundColor: this.backgroundColor.rgba\n    };\n\n    if (this.useBounds) {\n      output['bounds'] = {\n        x: this._bounds.x,\n        y: this._bounds.y,\n        width: this._bounds.width,\n        height: this._bounds.height\n      };\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Internal method called automatically by the Camera Manager.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#update\r\n   * @protected\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n   * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n   */\n  update: function update() {//  NOOP\n  },\n\n  /**\r\n   * Internal method called automatically when the viewport changes.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#updateSystem\r\n   * @private\r\n   * @since 3.12.0\r\n   */\n  updateSystem: function updateSystem() {\n    if (!this.scaleManager) {\n      return;\n    }\n\n    var custom = this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height;\n    var sceneManager = this.sceneManager;\n\n    if (custom && !this._customViewport) {\n      //  We need a custom viewport for this Camera\n      sceneManager.customViewports++;\n    } else if (!custom && this._customViewport) {\n      //  We're turning off a custom viewport for this Camera\n      sceneManager.customViewports--;\n    }\n\n    this.dirty = true;\n    this._customViewport = custom;\n  },\n\n  /**\r\n   * Destroys this Camera instance and its internal properties and references.\r\n   * Once destroyed you cannot use this Camera again, even if re-added to a Camera Manager.\r\n   * \r\n   * This method is called automatically by `CameraManager.remove` if that methods `runDestroy` argument is `true`, which is the default.\r\n   * \r\n   * Unless you have a specific reason otherwise, always use `CameraManager.remove` and allow it to handle the camera destruction,\r\n   * rather than calling this method directly.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#destroy\r\n   * @fires Phaser.Cameras.Scene2D.Events#DESTROY\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    this.emit(Events.DESTROY, this);\n    this.removeAllListeners();\n    this.matrix.destroy();\n    this.culledObjects = [];\n\n    if (this._customViewport) {\n      //  We're turning off a custom viewport for this Camera\n      this.sceneManager.customViewports--;\n    }\n\n    this._bounds = null;\n    this.scene = null;\n    this.scaleManager = null;\n    this.sceneManager = null;\n  },\n\n  /**\r\n   * The x position of the Camera viewport, relative to the top-left of the game canvas.\r\n   * The viewport is the area into which the camera renders.\r\n   * To adjust the position the camera is looking at in the game world, see the `scrollX` value.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#x\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  x: {\n    get: function get() {\n      return this._x;\n    },\n    set: function set(value) {\n      this._x = value;\n      this._cx = value * this.resolution;\n      this.updateSystem();\n    }\n  },\n\n  /**\r\n   * The y position of the Camera viewport, relative to the top-left of the game canvas.\r\n   * The viewport is the area into which the camera renders.\r\n   * To adjust the position the camera is looking at in the game world, see the `scrollY` value.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#y\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  y: {\n    get: function get() {\n      return this._y;\n    },\n    set: function set(value) {\n      this._y = value;\n      this._cy = value * this.resolution;\n      this.updateSystem();\n    }\n  },\n\n  /**\r\n   * The width of the Camera viewport, in pixels.\r\n   *\r\n   * The viewport is the area into which the Camera renders. Setting the viewport does\r\n   * not restrict where the Camera can scroll to.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#width\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  width: {\n    get: function get() {\n      return this._width;\n    },\n    set: function set(value) {\n      this._width = value;\n      this._cw = value * this.resolution;\n      this.updateSystem();\n    }\n  },\n\n  /**\r\n   * The height of the Camera viewport, in pixels.\r\n   *\r\n   * The viewport is the area into which the Camera renders. Setting the viewport does\r\n   * not restrict where the Camera can scroll to.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#height\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  height: {\n    get: function get() {\n      return this._height;\n    },\n    set: function set(value) {\n      this._height = value;\n      this._ch = value * this.resolution;\n      this.updateSystem();\n    }\n  },\n\n  /**\r\n   * The horizontal scroll position of this Camera.\r\n   *\r\n   * Change this value to cause the Camera to scroll around your Scene.\r\n   *\r\n   * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,\r\n   * will automatically adjust the Camera scroll values accordingly.\r\n   *\r\n   * You can set the bounds within which the Camera can scroll via the `setBounds` method.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#scrollX\r\n   * @type {number}\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n  scrollX: {\n    get: function get() {\n      return this._scrollX;\n    },\n    set: function set(value) {\n      this._scrollX = value;\n      this.dirty = true;\n    }\n  },\n\n  /**\r\n   * The vertical scroll position of this Camera.\r\n   *\r\n   * Change this value to cause the Camera to scroll around your Scene.\r\n   *\r\n   * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,\r\n   * will automatically adjust the Camera scroll values accordingly.\r\n   *\r\n   * You can set the bounds within which the Camera can scroll via the `setBounds` method.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#scrollY\r\n   * @type {number}\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n  scrollY: {\n    get: function get() {\n      return this._scrollY;\n    },\n    set: function set(value) {\n      this._scrollY = value;\n      this.dirty = true;\n    }\n  },\n\n  /**\r\n   * The Camera zoom value. Change this value to zoom in, or out of, a Scene.\r\n   *\r\n   * A value of 0.5 would zoom the Camera out, so you can now see twice as much\r\n   * of the Scene as before. A value of 2 would zoom the Camera in, so every pixel\r\n   * now takes up 2 pixels when rendered.\r\n   *\r\n   * Set to 1 to return to the default zoom level.\r\n   *\r\n   * Be careful to never set this value to zero.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#zoom\r\n   * @type {number}\r\n   * @default 1\r\n   * @since 3.0.0\r\n   */\n  zoom: {\n    get: function get() {\n      return this._zoom;\n    },\n    set: function set(value) {\n      this._zoom = value;\n      this.dirty = true;\n    }\n  },\n\n  /**\r\n   * The rotation of the Camera in radians.\r\n   *\r\n   * Camera rotation always takes place based on the Camera viewport. By default, rotation happens\r\n   * in the center of the viewport. You can adjust this with the `originX` and `originY` properties.\r\n   *\r\n   * Rotation influences the rendering of _all_ Game Objects visible by this Camera. However, it does not\r\n   * rotate the Camera viewport itself, which always remains an axis-aligned rectangle.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#rotation\r\n   * @type {number}\r\n   * @private\r\n   * @default 0\r\n   * @since 3.11.0\r\n   */\n  rotation: {\n    get: function get() {\n      return this._rotation;\n    },\n    set: function set(value) {\n      this._rotation = value;\n      this.dirty = true;\n    }\n  },\n\n  /**\r\n   * The horizontal position of the center of the Camera's viewport, relative to the left of the game canvas.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#centerX\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  centerX: {\n    get: function get() {\n      return this.x + 0.5 * this.width;\n    }\n  },\n\n  /**\r\n   * The vertical position of the center of the Camera's viewport, relative to the top of the game canvas.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#centerY\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  centerY: {\n    get: function get() {\n      return this.y + 0.5 * this.height;\n    }\n  },\n\n  /**\r\n   * The displayed width of the camera viewport, factoring in the camera zoom level.\r\n   *\r\n   * If a camera has a viewport width of 800 and a zoom of 0.5 then its display width\r\n   * would be 1600, as it's displaying twice as many pixels as zoom level 1.\r\n   *\r\n   * Equally, a camera with a width of 800 and zoom of 2 would have a display width\r\n   * of 400 pixels.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#displayWidth\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.11.0\r\n   */\n  displayWidth: {\n    get: function get() {\n      return this.width / this.zoom;\n    }\n  },\n\n  /**\r\n   * The displayed height of the camera viewport, factoring in the camera zoom level.\r\n   *\r\n   * If a camera has a viewport height of 600 and a zoom of 0.5 then its display height\r\n   * would be 1200, as it's displaying twice as many pixels as zoom level 1.\r\n   *\r\n   * Equally, a camera with a height of 600 and zoom of 2 would have a display height\r\n   * of 300 pixels.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#displayHeight\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.11.0\r\n   */\n  displayHeight: {\n    get: function get() {\n      return this.height / this.zoom;\n    }\n  }\n});\nmodule.exports = BaseCamera;","map":null,"metadata":{},"sourceType":"script"}