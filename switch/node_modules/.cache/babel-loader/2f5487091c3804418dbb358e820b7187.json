{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar Frame = require('./Frame');\n\nvar TextureSource = require('./TextureSource');\n\nvar TEXTURE_MISSING_ERROR = 'Texture.frame missing: ';\n/**\r\n * @classdesc\r\n * A Texture consists of a source, usually an Image from the Cache, and a collection of Frames.\r\n * The Frames represent the different areas of the Texture. For example a texture atlas\r\n * may have many Frames, one for each element within the atlas. Where-as a single image would have\r\n * just one frame, that encompasses the whole image.\r\n *\r\n * Textures are managed by the global TextureManager. This is a singleton class that is\r\n * responsible for creating and delivering Textures and their corresponding Frames to Game Objects.\r\n *\r\n * Sprites and other Game Objects get the texture data they need from the TextureManager.\r\n *\r\n * @class Texture\r\n * @memberof Phaser.Textures\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.TextureManager} manager - A reference to the Texture Manager this Texture belongs to.\r\n * @param {string} key - The unique string-based key of this Texture.\r\n * @param {(HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[])} source - An array of sources that are used to create the texture. Usually Images, but can also be a Canvas.\r\n * @param {number} [width] - The width of the Texture. This is optional and automatically derived from the source images.\r\n * @param {number} [height] - The height of the Texture. This is optional and automatically derived from the source images.\r\n */\n\nvar Texture = new Class({\n  initialize: function Texture(manager, key, source, width, height) {\n    if (!Array.isArray(source)) {\n      source = [source];\n    }\n    /**\r\n     * A reference to the Texture Manager this Texture belongs to.\r\n     *\r\n     * @name Phaser.Textures.Texture#manager\r\n     * @type {Phaser.Textures.TextureManager}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.manager = manager;\n    /**\r\n     * The unique string-based key of this Texture.\r\n     *\r\n     * @name Phaser.Textures.Texture#key\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n\n    this.key = key;\n    /**\r\n     * An array of TextureSource instances.\r\n     * These are unique to this Texture and contain the actual Image (or Canvas) data.\r\n     *\r\n     * @name Phaser.Textures.Texture#source\r\n     * @type {Phaser.Textures.TextureSource[]}\r\n     * @since 3.0.0\r\n     */\n\n    this.source = [];\n    /**\r\n     * An array of TextureSource data instances.\r\n     * Used to store additional data images, such as normal maps or specular maps.\r\n     *\r\n     * @name Phaser.Textures.Texture#dataSource\r\n     * @type {array}\r\n     * @since 3.0.0\r\n     */\n\n    this.dataSource = [];\n    /**\r\n     * A key-value object pair associating the unique Frame keys with the Frames objects.\r\n     *\r\n     * @name Phaser.Textures.Texture#frames\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.frames = {};\n    /**\r\n     * Any additional data that was set in the source JSON (if any),\r\n     * or any extra data you'd like to store relating to this texture\r\n     *\r\n     * @name Phaser.Textures.Texture#customData\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.customData = {};\n    /**\r\n     * The name of the first frame of the Texture.\r\n     *\r\n     * @name Phaser.Textures.Texture#firstFrame\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n\n    this.firstFrame = '__BASE';\n    /**\r\n     * The total number of Frames in this Texture.\r\n     *\r\n     * @name Phaser.Textures.Texture#frameTotal\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.frameTotal = 0; //  Load the Sources\n\n    for (var i = 0; i < source.length; i++) {\n      this.source.push(new TextureSource(this, source[i], width, height));\n    }\n  },\n\n  /**\r\n   * Adds a new Frame to this Texture.\r\n   *\r\n   * A Frame is a rectangular region of a TextureSource with a unique index or string-based key.\r\n   *\r\n   * @method Phaser.Textures.Texture#add\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(integer|string)} name - The name of this Frame. The name is unique within the Texture.\r\n   * @param {integer} sourceIndex - The index of the TextureSource that this Frame is a part of.\r\n   * @param {number} x - The x coordinate of the top-left of this Frame.\r\n   * @param {number} y - The y coordinate of the top-left of this Frame.\r\n   * @param {number} width - The width of this Frame.\r\n   * @param {number} height - The height of this Frame.\r\n   *\r\n   * @return {Phaser.Textures.Frame} The Frame that was added to this Texture.\r\n   */\n  add: function add(name, sourceIndex, x, y, width, height) {\n    var frame = new Frame(this, name, sourceIndex, x, y, width, height);\n    this.frames[name] = frame; //  Set the first frame of the Texture (other than __BASE)\n    //  This is used to ensure we don't spam the display with entire\n    //  atlases of sprite sheets, but instead just the first frame of them\n    //  should the dev incorrectly specify the frame index\n\n    if (this.frameTotal === 1) {\n      this.firstFrame = name;\n    }\n\n    this.frameTotal++;\n    return frame;\n  },\n\n  /**\r\n   * Checks to see if a Frame matching the given key exists within this Texture.\r\n   *\r\n   * @method Phaser.Textures.Texture#has\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} name - The key of the Frame to check for.\r\n   *\r\n   * @return {boolean} True if a Frame with the matching key exists in this Texture.\r\n   */\n  has: function has(name) {\n    return this.frames[name];\n  },\n\n  /**\r\n   * Gets a Frame from this Texture based on either the key or the index of the Frame.\r\n   *\r\n   * In a Texture Atlas Frames are typically referenced by a key.\r\n   * In a Sprite Sheet Frames are referenced by an index.\r\n   * Passing no value for the name returns the base texture.\r\n   *\r\n   * @method Phaser.Textures.Texture#get\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|integer)} [name] - The string-based name, or integer based index, of the Frame to get from this Texture.\r\n   *\r\n   * @return {Phaser.Textures.Frame} The Texture Frame.\r\n   */\n  get: function get(name) {\n    //  null, undefined, empty string, zero\n    if (!name) {\n      name = this.firstFrame;\n    }\n\n    var frame = this.frames[name];\n\n    if (!frame) {\n      console.warn(TEXTURE_MISSING_ERROR + name);\n      frame = this.frames[this.firstFrame];\n    }\n\n    return frame;\n  },\n\n  /**\r\n   * Takes the given TextureSource and returns the index of it within this Texture.\r\n   * If it's not in this Texture, it returns -1.\r\n   * Unless this Texture has multiple TextureSources, such as with a multi-atlas, this\r\n   * method will always return zero or -1.\r\n   *\r\n   * @method Phaser.Textures.Texture#getTextureSourceIndex\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Textures.TextureSource} source - The TextureSource to check.\r\n   *\r\n   * @return {integer} The index of the TextureSource within this Texture, or -1 if not in this Texture.\r\n   */\n  getTextureSourceIndex: function getTextureSourceIndex(source) {\n    for (var i = 0; i < this.source.length; i++) {\n      if (this.source[i] === source) {\n        return i;\n      }\n    }\n\n    return -1;\n  },\n\n  /**\r\n   * Returns an array of all the Frames in the given TextureSource.\r\n   *\r\n   * @method Phaser.Textures.Texture#getFramesFromTextureSource\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} sourceIndex - The index of the TextureSource to get the Frames from.\r\n   * @param {boolean} [includeBase=false] - Include the `__BASE` Frame in the output array?\r\n   *\r\n   * @return {Phaser.Textures.Frame[]} An array of Texture Frames.\r\n   */\n  getFramesFromTextureSource: function getFramesFromTextureSource(sourceIndex, includeBase) {\n    if (includeBase === undefined) {\n      includeBase = false;\n    }\n\n    var out = [];\n\n    for (var frameName in this.frames) {\n      if (frameName === '__BASE' && !includeBase) {\n        continue;\n      }\n\n      var frame = this.frames[frameName];\n\n      if (frame.sourceIndex === sourceIndex) {\n        out.push(frame);\n      }\n    }\n\n    return out;\n  },\n\n  /**\r\n   * Returns an array with all of the names of the Frames in this Texture.\r\n   *\r\n   * Useful if you want to randomly assign a Frame to a Game Object, as you can\r\n   * pick a random element from the returned array.\r\n   *\r\n   * @method Phaser.Textures.Texture#getFrameNames\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [includeBase=false] - Include the `__BASE` Frame in the output array?\r\n   *\r\n   * @return {string[]} An array of all Frame names in this Texture.\r\n   */\n  getFrameNames: function getFrameNames(includeBase) {\n    if (includeBase === undefined) {\n      includeBase = false;\n    }\n\n    var out = Object.keys(this.frames);\n\n    if (!includeBase) {\n      var idx = out.indexOf('__BASE');\n\n      if (idx !== -1) {\n        out.splice(idx, 1);\n      }\n    }\n\n    return out;\n  },\n\n  /**\r\n   * Given a Frame name, return the source image it uses to render with.\r\n   *\r\n   * This will return the actual DOM Image or Canvas element.\r\n   *\r\n   * @method Phaser.Textures.Texture#getSourceImage\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|integer)} [name] - The string-based name, or integer based index, of the Frame to get from this Texture.\r\n   *\r\n   * @return {(HTMLImageElement|HTMLCanvasElement|Phaser.GameObjects.RenderTexture)} The DOM Image, Canvas Element or Render Texture.\r\n   */\n  getSourceImage: function getSourceImage(name) {\n    if (name === undefined || name === null || this.frameTotal === 1) {\n      name = '__BASE';\n    }\n\n    var frame = this.frames[name];\n\n    if (frame) {\n      return frame.source.image;\n    } else {\n      console.warn(TEXTURE_MISSING_ERROR + name);\n      return this.frames['__BASE'].source.image;\n    }\n  },\n\n  /**\r\n   * Given a Frame name, return the data source image it uses to render with.\r\n   * You can use this to get the normal map for an image for example.\r\n   *\r\n   * This will return the actual DOM Image.\r\n   *\r\n   * @method Phaser.Textures.Texture#getDataSourceImage\r\n   * @since 3.7.0\r\n   *\r\n   * @param {(string|integer)} [name] - The string-based name, or integer based index, of the Frame to get from this Texture.\r\n   *\r\n   * @return {(HTMLImageElement|HTMLCanvasElement)} The DOM Image or Canvas Element.\r\n   */\n  getDataSourceImage: function getDataSourceImage(name) {\n    if (name === undefined || name === null || this.frameTotal === 1) {\n      name = '__BASE';\n    }\n\n    var frame = this.frames[name];\n    var idx;\n\n    if (!frame) {\n      console.warn(TEXTURE_MISSING_ERROR + name);\n      idx = this.frames['__BASE'].sourceIndex;\n    } else {\n      idx = frame.sourceIndex;\n    }\n\n    return this.dataSource[idx].image;\n  },\n\n  /**\r\n   * Adds a data source image to this Texture.\r\n   *\r\n   * An example of a data source image would be a normal map, where all of the Frames for this Texture\r\n   * equally apply to the normal map.\r\n   *\r\n   * @method Phaser.Textures.Texture#setDataSource\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[])} data - The source image.\r\n   */\n  setDataSource: function setDataSource(data) {\n    if (!Array.isArray(data)) {\n      data = [data];\n    }\n\n    for (var i = 0; i < data.length; i++) {\n      var source = this.source[i];\n      this.dataSource.push(new TextureSource(this, data[i], source.width, source.height));\n    }\n  },\n\n  /**\r\n   * Sets the Filter Mode for this Texture.\r\n   *\r\n   * The mode can be either Linear, the default, or Nearest.\r\n   *\r\n   * For pixel-art you should use Nearest.\r\n   *\r\n   * The mode applies to the entire Texture, not just a specific Frame of it.\r\n   *\r\n   * @method Phaser.Textures.Texture#setFilter\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Textures.FilterMode} filterMode - The Filter Mode.\r\n   */\n  setFilter: function setFilter(filterMode) {\n    var i;\n\n    for (i = 0; i < this.source.length; i++) {\n      this.source[i].setFilter(filterMode);\n    }\n\n    for (i = 0; i < this.dataSource.length; i++) {\n      this.dataSource[i].setFilter(filterMode);\n    }\n  },\n\n  /**\r\n   * Destroys this Texture and releases references to its sources and frames.\r\n   *\r\n   * @method Phaser.Textures.Texture#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    var i;\n\n    for (i = 0; i < this.source.length; i++) {\n      this.source[i].destroy();\n    }\n\n    for (i = 0; i < this.dataSource.length; i++) {\n      this.dataSource[i].destroy();\n    }\n\n    for (var frameName in this.frames) {\n      var frame = this.frames[frameName];\n      frame.destroy();\n    }\n\n    this.source = [];\n    this.dataSource = [];\n    this.frames = {};\n    this.manager = null;\n  }\n});\nmodule.exports = Texture;","map":null,"metadata":{},"sourceType":"script"}