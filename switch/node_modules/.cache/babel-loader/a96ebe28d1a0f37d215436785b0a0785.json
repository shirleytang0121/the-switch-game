{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Rectangle = require('../../geom/rectangle/Rectangle');\n\nvar RotateAround = require('../../math/RotateAround');\n\nvar Vector2 = require('../../math/Vector2');\n/**\r\n * Provides methods used for obtaining the bounds of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @name Phaser.GameObjects.Components.GetBounds\r\n * @since 3.0.0\r\n */\n\n\nvar GetBounds = {\n  /**\r\n   * Gets the center coordinate of this Game Object, regardless of origin.\r\n   * The returned point is calculated in local space and does not factor in any parent containers\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getCenter\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n   */\n  getCenter: function getCenter(output) {\n    if (output === undefined) {\n      output = new Vector2();\n    }\n\n    output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;\n    output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;\n    return output;\n  },\n\n  /**\r\n   * Gets the top-left corner coordinate of this Game Object, regardless of origin.\r\n   * The returned point is calculated in local space and does not factor in any parent containers\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getTopLeft\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n   * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n   */\n  getTopLeft: function getTopLeft(output, includeParent) {\n    if (!output) {\n      output = new Vector2();\n    }\n\n    if (includeParent === undefined) {\n      includeParent = false;\n    }\n\n    output.x = this.x - this.displayWidth * this.originX;\n    output.y = this.y - this.displayHeight * this.originY;\n\n    if (this.rotation !== 0) {\n      RotateAround(output, this.x, this.y, this.rotation);\n    }\n\n    if (includeParent && this.parentContainer) {\n      var parentMatrix = this.parentContainer.getBoundsTransformMatrix();\n      parentMatrix.transformPoint(output.x, output.y, output);\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Gets the top-right corner coordinate of this Game Object, regardless of origin.\r\n   * The returned point is calculated in local space and does not factor in any parent containers\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getTopRight\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n   * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n   */\n  getTopRight: function getTopRight(output, includeParent) {\n    if (!output) {\n      output = new Vector2();\n    }\n\n    if (includeParent === undefined) {\n      includeParent = false;\n    }\n\n    output.x = this.x - this.displayWidth * this.originX + this.displayWidth;\n    output.y = this.y - this.displayHeight * this.originY;\n\n    if (this.rotation !== 0) {\n      RotateAround(output, this.x, this.y, this.rotation);\n    }\n\n    if (includeParent && this.parentContainer) {\n      var parentMatrix = this.parentContainer.getBoundsTransformMatrix();\n      parentMatrix.transformPoint(output.x, output.y, output);\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.\r\n   * The returned point is calculated in local space and does not factor in any parent containers\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getBottomLeft\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n   * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n   */\n  getBottomLeft: function getBottomLeft(output, includeParent) {\n    if (!output) {\n      output = new Vector2();\n    }\n\n    if (includeParent === undefined) {\n      includeParent = false;\n    }\n\n    output.x = this.x - this.displayWidth * this.originX;\n    output.y = this.y - this.displayHeight * this.originY + this.displayHeight;\n\n    if (this.rotation !== 0) {\n      RotateAround(output, this.x, this.y, this.rotation);\n    }\n\n    if (includeParent && this.parentContainer) {\n      var parentMatrix = this.parentContainer.getBoundsTransformMatrix();\n      parentMatrix.transformPoint(output.x, output.y, output);\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.\r\n   * The returned point is calculated in local space and does not factor in any parent containers\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getBottomRight\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n   * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n   */\n  getBottomRight: function getBottomRight(output, includeParent) {\n    if (!output) {\n      output = new Vector2();\n    }\n\n    if (includeParent === undefined) {\n      includeParent = false;\n    }\n\n    output.x = this.x - this.displayWidth * this.originX + this.displayWidth;\n    output.y = this.y - this.displayHeight * this.originY + this.displayHeight;\n\n    if (this.rotation !== 0) {\n      RotateAround(output, this.x, this.y, this.rotation);\n    }\n\n    if (includeParent && this.parentContainer) {\n      var parentMatrix = this.parentContainer.getBoundsTransformMatrix();\n      parentMatrix.transformPoint(output.x, output.y, output);\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Gets the bounds of this Game Object, regardless of origin.\r\n   * The values are stored and returned in a Rectangle, or Rectangle-like, object.\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Geom.Rectangle} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Geom.Rectangle|object)} [output] - An object to store the values in. If not provided a new Rectangle will be created.\r\n   *\r\n   * @return {(Phaser.Geom.Rectangle|object)} The values stored in the output object.\r\n   */\n  getBounds: function getBounds(output) {\n    if (output === undefined) {\n      output = new Rectangle();\n    } //  We can use the output object to temporarily store the x/y coords in:\n\n\n    var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy; // Instead of doing a check if parent container is \n    // defined per corner we only do it once.\n\n    if (this.parentContainer) {\n      var parentMatrix = this.parentContainer.getBoundsTransformMatrix();\n      this.getTopLeft(output);\n      parentMatrix.transformPoint(output.x, output.y, output);\n      TLx = output.x;\n      TLy = output.y;\n      this.getTopRight(output);\n      parentMatrix.transformPoint(output.x, output.y, output);\n      TRx = output.x;\n      TRy = output.y;\n      this.getBottomLeft(output);\n      parentMatrix.transformPoint(output.x, output.y, output);\n      BLx = output.x;\n      BLy = output.y;\n      this.getBottomRight(output);\n      parentMatrix.transformPoint(output.x, output.y, output);\n      BRx = output.x;\n      BRy = output.y;\n    } else {\n      this.getTopLeft(output);\n      TLx = output.x;\n      TLy = output.y;\n      this.getTopRight(output);\n      TRx = output.x;\n      TRy = output.y;\n      this.getBottomLeft(output);\n      BLx = output.x;\n      BLy = output.y;\n      this.getBottomRight(output);\n      BRx = output.x;\n      BRy = output.y;\n    }\n\n    output.x = Math.min(TLx, TRx, BLx, BRx);\n    output.y = Math.min(TLy, TRy, BLy, BRy);\n    output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;\n    output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;\n    return output;\n  }\n};\nmodule.exports = GetBounds;","map":null,"metadata":{},"sourceType":"script"}