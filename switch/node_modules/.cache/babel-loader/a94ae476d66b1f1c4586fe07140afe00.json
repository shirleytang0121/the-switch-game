{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\n//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\nvar Class = require('../utils/Class');\n\nvar Curve = require('./Curve');\n\nvar FromPoints = require('../geom/rectangle/FromPoints');\n\nvar Rectangle = require('../geom/rectangle/Rectangle');\n\nvar Vector2 = require('../math/Vector2');\n\nvar tmpVec2 = new Vector2();\n/**\r\n * @classdesc\r\n * A LineCurve is a \"curve\" comprising exactly two points (a line segment).\r\n *\r\n * @class Line\r\n * @extends Phaser.Curves.Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Math.Vector2|number[])} p0 - The first endpoint.\r\n * @param {Phaser.Math.Vector2} [p1] - The second endpoint.\r\n */\n\nvar LineCurve = new Class({\n  Extends: Curve,\n  initialize: //  vec2s or array\n  function LineCurve(p0, p1) {\n    Curve.call(this, 'LineCurve');\n\n    if (Array.isArray(p0)) {\n      p1 = new Vector2(p0[2], p0[3]);\n      p0 = new Vector2(p0[0], p0[1]);\n    }\n    /**\r\n     * The first endpoint.\r\n     *\r\n     * @name Phaser.Curves.Line#p0\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.p0 = p0;\n    /**\r\n     * The second endpoint.\r\n     *\r\n     * @name Phaser.Curves.Line#p1\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.p1 = p1;\n  },\n\n  /**\r\n   * Returns a Rectangle where the position and dimensions match the bounds of this Curve.\r\n   *\r\n   * @method Phaser.Curves.Line#getBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n   *\r\n   * @param {Phaser.Geom.Rectangle} [out] - A Rectangle object to store the bounds in. If not given a new Rectangle will be created.\r\n   *\r\n   * @return {Phaser.Geom.Rectangle} A Rectangle object holding the bounds of this curve. If `out` was given it will be this object.\r\n   */\n  getBounds: function getBounds(out) {\n    if (out === undefined) {\n      out = new Rectangle();\n    }\n\n    return FromPoints([this.p0, this.p1], out);\n  },\n\n  /**\r\n   * Gets the starting point on the curve.\r\n   *\r\n   * @method Phaser.Curves.Line#getStartPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n   */\n  getStartPoint: function getStartPoint(out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    return out.copy(this.p0);\n  },\n\n  /**\r\n   * Gets the resolution of the line.\r\n   *\r\n   * @method Phaser.Curves.Line#getResolution\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [divisions=1] - The number of divisions to consider.\r\n   *\r\n   * @return {number} The resolution. Equal to the number of divisions.\r\n   */\n  getResolution: function getResolution(divisions) {\n    if (divisions === undefined) {\n      divisions = 1;\n    }\n\n    return divisions;\n  },\n\n  /**\r\n   * Get point at relative position in curve according to length.\r\n   *\r\n   * @method Phaser.Curves.Line#getPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n   * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n   */\n  getPoint: function getPoint(t, out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    if (t === 1) {\n      return out.copy(this.p1);\n    }\n\n    out.copy(this.p1).subtract(this.p0).scale(t).add(this.p0);\n    return out;\n  },\n  // Line curve is linear, so we can overwrite default getPointAt\n\n  /**\r\n   * Gets a point at a given position on the line.\r\n   *\r\n   * @method Phaser.Curves.Line#getPointAt\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {number} u - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n   * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n   */\n  getPointAt: function getPointAt(u, out) {\n    return this.getPoint(u, out);\n  },\n\n  /**\r\n   * Gets the slope of the line as a unit vector.\r\n   *\r\n   * @method Phaser.Curves.Line#getTangent\r\n   * @since 3.0.0\r\n   * \r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @return {Phaser.Math.Vector2} The tangent vector.\r\n   */\n  getTangent: function getTangent() {\n    var tangent = tmpVec2.copy(this.p1).subtract(this.p0);\n    return tangent.normalize();\n  },\n  //  Override default Curve.draw because this is better than calling getPoints on a line!\n\n  /**\r\n   * Draws this curve on the given Graphics object.\r\n   *\r\n   * The curve is drawn using `Graphics.lineBetween` so will be drawn at whatever the present Graphics line color is.\r\n   * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.\r\n   *\r\n   * @method Phaser.Curves.Line#draw\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]\r\n   *\r\n   * @param {Phaser.GameObjects.Graphics} graphics - The Graphics instance onto which this curve will be drawn.\r\n   *\r\n   * @return {Phaser.GameObjects.Graphics} The Graphics object to which the curve was drawn.\r\n   */\n  draw: function draw(graphics) {\n    graphics.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y); //  So you can chain graphics calls\n\n    return graphics;\n  },\n\n  /**\r\n   * Gets a JSON representation of the line.\r\n   *\r\n   * @method Phaser.Curves.Line#toJSON\r\n   * @since 3.0.0\r\n   *\r\n   * @return {JSONCurve} The JSON object containing this curve data.\r\n   */\n  toJSON: function toJSON() {\n    return {\n      type: this.type,\n      points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y]\n    };\n  }\n});\n/**\r\n * Configures this line from a JSON representation.\r\n *\r\n * @function Phaser.Curves.Line.fromJSON\r\n * @since 3.0.0\r\n *\r\n * @param {JSONCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.Line} A new LineCurve object.\r\n */\n\nLineCurve.fromJSON = function (data) {\n  var points = data.points;\n  var p0 = new Vector2(points[0], points[1]);\n  var p1 = new Vector2(points[2], points[3]);\n  return new LineCurve(p0, p1);\n};\n\nmodule.exports = LineCurve;","map":null,"metadata":{},"sourceType":"script"}