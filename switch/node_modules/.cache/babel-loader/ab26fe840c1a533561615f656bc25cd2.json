{"ast":null,"code":"/**\r\n* The `Matter.Query` module contains methods for performing collision queries.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Query\r\n*/\nvar Query = {};\nmodule.exports = Query;\n\nvar Vector = require('../geometry/Vector');\n\nvar SAT = require('./SAT');\n\nvar Bounds = require('../geometry/Bounds');\n\nvar Bodies = require('../factory/Bodies');\n\nvar Vertices = require('../geometry/Vertices');\n\n(function () {\n  /**\r\n   * Returns a list of collisions between `body` and `bodies`.\r\n   * @method collides\r\n   * @param {body} body\r\n   * @param {body[]} bodies\r\n   * @return {object[]} Collisions\r\n   */\n  Query.collides = function (body, bodies) {\n    var collisions = [];\n\n    for (var i = 0; i < bodies.length; i++) {\n      var bodyA = bodies[i];\n\n      if (Bounds.overlaps(bodyA.bounds, body.bounds)) {\n        for (var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++) {\n          var part = bodyA.parts[j];\n\n          if (Bounds.overlaps(part.bounds, body.bounds)) {\n            var collision = SAT.collides(part, body);\n\n            if (collision.collided) {\n              collisions.push(collision);\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    return collisions;\n  };\n  /**\r\n   * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.\r\n   * @method ray\r\n   * @param {body[]} bodies\r\n   * @param {vector} startPoint\r\n   * @param {vector} endPoint\r\n   * @param {number} [rayWidth]\r\n   * @return {object[]} Collisions\r\n   */\n\n\n  Query.ray = function (bodies, startPoint, endPoint, rayWidth) {\n    rayWidth = rayWidth || 1e-100;\n    var rayAngle = Vector.angle(startPoint, endPoint),\n        rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)),\n        rayX = (endPoint.x + startPoint.x) * 0.5,\n        rayY = (endPoint.y + startPoint.y) * 0.5,\n        ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, {\n      angle: rayAngle\n    }),\n        collisions = Query.collides(ray, bodies);\n\n    for (var i = 0; i < collisions.length; i += 1) {\n      var collision = collisions[i];\n      collision.body = collision.bodyB = collision.bodyA;\n    }\n\n    return collisions;\n  };\n  /**\r\n   * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.\r\n   * @method region\r\n   * @param {body[]} bodies\r\n   * @param {bounds} bounds\r\n   * @param {bool} [outside=false]\r\n   * @return {body[]} The bodies matching the query\r\n   */\n\n\n  Query.region = function (bodies, bounds, outside) {\n    var result = [];\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i],\n          overlaps = Bounds.overlaps(body.bounds, bounds);\n      if (overlaps && !outside || !overlaps && outside) result.push(body);\n    }\n\n    return result;\n  };\n  /**\r\n   * Returns all bodies whose vertices contain the given point, from the given set of bodies.\r\n   * @method point\r\n   * @param {body[]} bodies\r\n   * @param {vector} point\r\n   * @return {body[]} The bodies matching the query\r\n   */\n\n\n  Query.point = function (bodies, point) {\n    var result = [];\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i];\n\n      if (Bounds.contains(body.bounds, point)) {\n        for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {\n          var part = body.parts[j];\n\n          if (Bounds.contains(part.bounds, point) && Vertices.contains(part.vertices, point)) {\n            result.push(body);\n            break;\n          }\n        }\n      }\n    }\n\n    return result;\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}