{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar TweenBuilder = require('./builders/TweenBuilder');\n\nvar TWEEN_CONST = require('./tween/const');\n/**\r\n * @classdesc\r\n * A Timeline combines multiple Tweens into one. Its overall behavior is otherwise similar to a single Tween.\r\n *\r\n * The Timeline updates all of its Tweens simultaneously. Its methods allow you to easily build a sequence of Tweens (each one starting after the previous one) or run multiple Tweens at once during given parts of the Timeline.\r\n *\r\n * @class Timeline\r\n * @memberof Phaser.Tweens\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tweens.TweenManager} manager - The Tween Manager which owns this Timeline.\r\n */\n\n\nvar Timeline = new Class({\n  Extends: EventEmitter,\n  initialize: function Timeline(manager) {\n    EventEmitter.call(this);\n    /**\r\n     * The Tween Manager which owns this Timeline.\r\n     *\r\n     * @name Phaser.Tweens.Timeline#manager\r\n     * @type {Phaser.Tweens.TweenManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.manager = manager;\n    /**\r\n     * A constant value which allows this Timeline to be easily identified as one.\r\n     *\r\n     * @name Phaser.Tweens.Timeline#isTimeline\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.isTimeline = true;\n    /**\r\n     * An array of Tween objects, each containing a unique property and target being tweened.\r\n     *\r\n     * @name Phaser.Tweens.Timeline#data\r\n     * @type {array}\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this.data = [];\n    /**\r\n     * data array doesn't usually change, so we can cache the length\r\n     *\r\n     * @name Phaser.Tweens.Timeline#totalData\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.totalData = 0;\n    /**\r\n     * If true then duration, delay, etc values are all frame totals.\r\n     *\r\n     * @name Phaser.Tweens.Timeline#useFrames\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.useFrames = false;\n    /**\r\n     * Scales the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.\r\n     * Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.\r\n     *\r\n     * @name Phaser.Tweens.Timeline#timeScale\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\n\n    this.timeScale = 1;\n    /**\r\n     * Loop this tween? Can be -1 for an infinite loop, or an integer.\r\n     * When enabled it will play through ALL TweenDatas again (use TweenData.repeat to loop a single TD)\r\n     *\r\n     * @name Phaser.Tweens.Timeline#loop\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.loop = 0;\n    /**\r\n     * Time in ms/frames before the tween loops.\r\n     *\r\n     * @name Phaser.Tweens.Timeline#loopDelay\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.loopDelay = 0;\n    /**\r\n     * How many loops are left to run?\r\n     *\r\n     * @name Phaser.Tweens.Timeline#loopCounter\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.loopCounter = 0;\n    /**\r\n     * Time in ms/frames before the 'onComplete' event fires. This never fires if loop = true (as it never completes)\r\n     *\r\n     * @name Phaser.Tweens.Timeline#completeDelay\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.completeDelay = 0;\n    /**\r\n     * Countdown timer (used by loopDelay and completeDelay)\r\n     *\r\n     * @name Phaser.Tweens.Timeline#countdown\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.countdown = 0;\n    /**\r\n     * The current state of the tween\r\n     *\r\n     * @name Phaser.Tweens.Timeline#state\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.state = TWEEN_CONST.PENDING_ADD;\n    /**\r\n     * The state of the tween when it was paused (used by Resume)\r\n     *\r\n     * @name Phaser.Tweens.Timeline#_pausedState\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._pausedState = TWEEN_CONST.PENDING_ADD;\n    /**\r\n     * Does the Tween start off paused? (if so it needs to be started with Tween.play)\r\n     *\r\n     * @name Phaser.Tweens.Timeline#paused\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.paused = false;\n    /**\r\n     * Elapsed time in ms/frames of this run through the Tween.\r\n     *\r\n     * @name Phaser.Tweens.Timeline#elapsed\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.elapsed = 0;\n    /**\r\n     * Total elapsed time in ms/frames of the entire Tween, including looping.\r\n     *\r\n     * @name Phaser.Tweens.Timeline#totalElapsed\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.totalElapsed = 0;\n    /**\r\n     * Time in ms/frames for the whole Tween to play through once, excluding loop amounts and loop delays.\r\n     *\r\n     * @name Phaser.Tweens.Timeline#duration\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.duration = 0;\n    /**\r\n     * Value between 0 and 1. The amount through the Tween, excluding loops.\r\n     *\r\n     * @name Phaser.Tweens.Timeline#progress\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.progress = 0;\n    /**\r\n     * Time in ms/frames for all Tweens to complete (including looping)\r\n     *\r\n     * @name Phaser.Tweens.Timeline#totalDuration\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.totalDuration = 0;\n    /**\r\n     * Value between 0 and 1. The amount through the entire Tween, including looping.\r\n     *\r\n     * @name Phaser.Tweens.Timeline#totalProgress\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.totalProgress = 0;\n    this.callbacks = {\n      onComplete: null,\n      onLoop: null,\n      onStart: null,\n      onUpdate: null,\n      onYoyo: null\n    };\n    this.callbackScope;\n  },\n\n  /**\r\n   * Sets the value of the time scale applied to this Timeline. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.\r\n   * Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#setTimeScale\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The time scale value to set.\r\n   *\r\n   * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n   */\n  setTimeScale: function setTimeScale(value) {\n    this.timeScale = value;\n    return this;\n  },\n\n  /**\r\n   * Gets the value of the time scale applied to this Timeline. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on. \r\n   *\r\n   * @method Phaser.Tweens.Timeline#getTimeScale\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The value of the time scale applied to this Tween.\r\n   */\n  getTimeScale: function getTimeScale() {\n    return this.timeScale;\n  },\n\n  /**\r\n   * Check whether or not the Timeline is playing.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#isPlaying\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` if this Timeline is active, otherwise `false`.\r\n   */\n  isPlaying: function isPlaying() {\n    return this.state === TWEEN_CONST.ACTIVE;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Tweens.Timeline#add\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} config - [description]\r\n   *\r\n   * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n   */\n  add: function add(config) {\n    return this.queue(TweenBuilder(this, config));\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Tweens.Timeline#queue\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Tweens.Tween} tween - [description]\r\n   *\r\n   * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n   */\n  queue: function queue(tween) {\n    if (!this.isPlaying()) {\n      tween.parent = this;\n      tween.parentIsTimeline = true;\n      this.data.push(tween);\n      this.totalData = this.data.length;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Tweens.Timeline#hasOffset\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Tweens.Tween} tween - [description]\r\n   *\r\n   * @return {boolean} [description]\r\n   */\n  hasOffset: function hasOffset(tween) {\n    return tween.offset !== null;\n  },\n\n  /**\r\n   * Checks whether the offset value is a number or a directive that is relative to previous tweens.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#isOffsetAbsolute\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The offset value to be evaluated\r\n   *\r\n   * @return {boolean} True if the result is a number, false if it is a directive like \" -= 1000\"\r\n   */\n  isOffsetAbsolute: function isOffsetAbsolute(value) {\n    return typeof value === 'number';\n  },\n\n  /**\r\n   * Checks if the offset is a relative value rather than an absolute one. If the value is just a number, this returns false.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#isOffsetRelative\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} value - The offset value to be evaluated\r\n   *\r\n   * @return {boolean} Returns true if the value is relative, i.e \" -= 1000\". If false, the offset is absolute.\r\n   */\n  isOffsetRelative: function isOffsetRelative(value) {\n    var t = typeof value;\n\n    if (t === 'string') {\n      var op = value[0];\n\n      if (op === '-' || op === '+') {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Parses the relative offset value, returning a positive or negative number.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#getRelativeOffset\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} value - The relative offset, in the format of '-=500', for example. The first character determines whether it will be a positive or negative number. Spacing matters here.\r\n   * @param {number} base - The value to use as the offset.\r\n   *\r\n   * @return {number} The returned number value.\r\n   */\n  getRelativeOffset: function getRelativeOffset(value, base) {\n    var op = value[0];\n    var num = parseFloat(value.substr(2));\n    var result = base;\n\n    switch (op) {\n      case '+':\n        result += num;\n        break;\n\n      case '-':\n        result -= num;\n        break;\n    } //  Cannot ever be < 0\n\n\n    return Math.max(0, result);\n  },\n\n  /**\r\n   * Calculates the total duration of the timeline.  Computes all tween's durations and returns the full duration of the timeline. The resulting number is stored in the timeline, not as a return value.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#calcDuration\r\n   * @since 3.0.0\r\n   */\n  calcDuration: function calcDuration() {\n    var prevEnd = 0;\n    var totalDuration = 0;\n    var offsetDuration = 0;\n\n    for (var i = 0; i < this.totalData; i++) {\n      var tween = this.data[i];\n      tween.init();\n\n      if (this.hasOffset(tween)) {\n        if (this.isOffsetAbsolute(tween.offset)) {\n          //  An actual number, so it defines the start point from the beginning of the timeline\n          tween.calculatedOffset = tween.offset;\n\n          if (tween.offset === 0) {\n            offsetDuration = 0;\n          }\n        } else if (this.isOffsetRelative(tween.offset)) {\n          //  A relative offset (i.e. '-=1000', so starts at 'offset' ms relative to the PREVIOUS Tweens ending time)\n          tween.calculatedOffset = this.getRelativeOffset(tween.offset, prevEnd);\n        }\n      } else {\n        //  Sequential\n        tween.calculatedOffset = offsetDuration;\n      }\n\n      prevEnd = tween.totalDuration + tween.calculatedOffset;\n      totalDuration += tween.totalDuration;\n      offsetDuration += tween.totalDuration;\n    } //  Excludes loop values\n\n\n    this.duration = totalDuration;\n    this.loopCounter = this.loop === -1 ? 999999999999 : this.loop;\n\n    if (this.loopCounter > 0) {\n      this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter;\n    } else {\n      this.totalDuration = this.duration + this.completeDelay;\n    }\n  },\n\n  /**\r\n   * Initializes the timeline, which means all Tweens get their init() called, and the total duration will be computed. Returns a boolean indicating whether the timeline is auto-started or not.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#init\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} Returns true if the timeline is started. False if it is paused.\r\n   */\n  init: function init() {\n    this.calcDuration();\n    this.progress = 0;\n    this.totalProgress = 0;\n\n    if (this.paused) {\n      this.state = TWEEN_CONST.PAUSED;\n      return false;\n    } else {\n      return true;\n    }\n  },\n\n  /**\r\n   * Resets all of the timeline's tweens back to their initial states.  The boolean parameter indicates whether tweens that are looping should reset as well, or not.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#resetTweens\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} resetFromLoop - If true, resets all looping tweens to their initial values.\r\n   */\n  resetTweens: function resetTweens(resetFromLoop) {\n    for (var i = 0; i < this.totalData; i++) {\n      var tween = this.data[i];\n      tween.play(resetFromLoop);\n    }\n  },\n\n  /**\r\n   * Sets a callback for the Timeline.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#setCallback\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} type - The internal type of callback to set.\r\n   * @param {function} callback - Timeline allows multiple tweens to be linked together to create a streaming sequence.\r\n   * @param {array} [params] - The parameters to pass to the callback.\r\n   * @param {object} [scope] - The context scope of the callback.\r\n   *\r\n   * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n   */\n  setCallback: function setCallback(type, callback, params, scope) {\n    if (Timeline.TYPES.indexOf(type) !== -1) {\n      this.callbacks[type] = {\n        func: callback,\n        scope: scope,\n        params: params\n      };\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Delegates #makeActive to the Tween manager.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#makeActive\r\n   * @since 3.3.0\r\n   *\r\n   * @param {Phaser.Tweens.Tween} tween - The tween object to make active.\r\n   *\r\n   * @return {Phaser.Tweens.TweenManager} The Timeline's Tween Manager object.\r\n   */\n  makeActive: function makeActive(tween) {\n    return this.manager.makeActive(tween);\n  },\n\n  /**\r\n   * Starts playing the timeline.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#play\r\n   * @fires Phaser.Tweens.Events#TIMELINE_START\r\n   * @since 3.0.0\r\n   */\n  play: function play() {\n    if (this.state === TWEEN_CONST.ACTIVE) {\n      return;\n    }\n\n    if (this.paused) {\n      this.paused = false;\n      this.manager.makeActive(this);\n      return;\n    } else {\n      this.resetTweens(false);\n      this.state = TWEEN_CONST.ACTIVE;\n    }\n\n    var onStart = this.callbacks.onStart;\n\n    if (onStart) {\n      onStart.func.apply(onStart.scope, onStart.params);\n    }\n\n    this.emit(Events.TIMELINE_START, this);\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Tweens.Timeline#nextState\r\n   * @fires Phaser.Tweens.Events#TIMELINE_COMPLETE\r\n   * @fires Phaser.Tweens.Events#TIMELINE_LOOP\r\n   * @since 3.0.0\r\n   */\n  nextState: function nextState() {\n    if (this.loopCounter > 0) {\n      //  Reset the elapsed time\n      //  TODO: Probably ought to be set to the remainder from elapsed - duration\n      //  as the tweens nearly always over-run by a few ms due to rAf\n      this.elapsed = 0;\n      this.progress = 0;\n      this.loopCounter--;\n      var onLoop = this.callbacks.onLoop;\n\n      if (onLoop) {\n        onLoop.func.apply(onLoop.scope, onLoop.params);\n      }\n\n      this.emit(Events.TIMELINE_LOOP, this, this.loopCounter);\n      this.resetTweens(true);\n\n      if (this.loopDelay > 0) {\n        this.countdown = this.loopDelay;\n        this.state = TWEEN_CONST.LOOP_DELAY;\n      } else {\n        this.state = TWEEN_CONST.ACTIVE;\n      }\n    } else if (this.completeDelay > 0) {\n      this.countdown = this.completeDelay;\n      this.state = TWEEN_CONST.COMPLETE_DELAY;\n    } else {\n      this.state = TWEEN_CONST.PENDING_REMOVE;\n      var onComplete = this.callbacks.onComplete;\n\n      if (onComplete) {\n        onComplete.func.apply(onComplete.scope, onComplete.params);\n      }\n\n      this.emit(Events.TIMELINE_COMPLETE, this);\n    }\n  },\n\n  /**\r\n   * Returns 'true' if this Timeline has finished and should be removed from the Tween Manager.\r\n   * Otherwise, returns false.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#update\r\n   * @fires Phaser.Tweens.Events#TIMELINE_COMPLETE\r\n   * @fires Phaser.Tweens.Events#TIMELINE_UPDATE\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} timestamp - [description]\r\n   * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n   *\r\n   * @return {boolean} Returns `true` if this Timeline has finished and should be removed from the Tween Manager.\r\n   */\n  update: function update(timestamp, delta) {\n    if (this.state === TWEEN_CONST.PAUSED) {\n      return;\n    }\n\n    var rawDelta = delta;\n\n    if (this.useFrames) {\n      delta = 1 * this.manager.timeScale;\n    }\n\n    delta *= this.timeScale;\n    this.elapsed += delta;\n    this.progress = Math.min(this.elapsed / this.duration, 1);\n    this.totalElapsed += delta;\n    this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);\n\n    switch (this.state) {\n      case TWEEN_CONST.ACTIVE:\n        var stillRunning = this.totalData;\n\n        for (var i = 0; i < this.totalData; i++) {\n          var tween = this.data[i];\n\n          if (tween.update(timestamp, rawDelta)) {\n            stillRunning--;\n          }\n        }\n\n        var onUpdate = this.callbacks.onUpdate;\n\n        if (onUpdate) {\n          onUpdate.func.apply(onUpdate.scope, onUpdate.params);\n        }\n\n        this.emit(Events.TIMELINE_UPDATE, this); //  Anything still running? If not, we're done\n\n        if (stillRunning === 0) {\n          this.nextState();\n        }\n\n        break;\n\n      case TWEEN_CONST.LOOP_DELAY:\n        this.countdown -= delta;\n\n        if (this.countdown <= 0) {\n          this.state = TWEEN_CONST.ACTIVE;\n        }\n\n        break;\n\n      case TWEEN_CONST.COMPLETE_DELAY:\n        this.countdown -= delta;\n\n        if (this.countdown <= 0) {\n          this.state = TWEEN_CONST.PENDING_REMOVE;\n          var onComplete = this.callbacks.onComplete;\n\n          if (onComplete) {\n            onComplete.func.apply(onComplete.scope, onComplete.params);\n          }\n\n          this.emit(Events.TIMELINE_COMPLETE, this);\n        }\n\n        break;\n    }\n\n    return this.state === TWEEN_CONST.PENDING_REMOVE;\n  },\n\n  /**\r\n   * Stops the Tween immediately, whatever stage of progress it is at and flags it for removal by the TweenManager.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#stop\r\n   * @since 3.0.0\r\n   */\n  stop: function stop() {\n    this.state = TWEEN_CONST.PENDING_REMOVE;\n  },\n\n  /**\r\n   * Pauses the timeline, retaining its internal state.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#pause\r\n   * @fires Phaser.Tweens.Events#TIMELINE_PAUSE\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n   */\n  pause: function pause() {\n    if (this.state === TWEEN_CONST.PAUSED) {\n      return;\n    }\n\n    this.paused = true;\n    this._pausedState = this.state;\n    this.state = TWEEN_CONST.PAUSED;\n    this.emit(Events.TIMELINE_PAUSE, this);\n    return this;\n  },\n\n  /**\r\n   * Resumes the timeline from where it was when it was paused.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#resume\r\n   * @fires Phaser.Tweens.Events#TIMELINE_RESUME\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n   */\n  resume: function resume() {\n    if (this.state === TWEEN_CONST.PAUSED) {\n      this.paused = false;\n      this.state = this._pausedState;\n    }\n\n    this.emit(Events.TIMELINE_RESUME, this);\n    return this;\n  },\n\n  /**\r\n   * Checks if any of the tweens has the target as the object they are operating on. Retuns false if no tweens operate on the target object.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#hasTarget\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} target - The target to check all tweens against.\r\n   *\r\n   * @return {boolean} True if there at least a single tween that operates on the target object. False otherwise.\r\n   */\n  hasTarget: function hasTarget(target) {\n    for (var i = 0; i < this.data.length; i++) {\n      if (this.data[i].hasTarget(target)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Stops all the Tweens in the Timeline immediately, whatever stage of progress they are at and flags them for removal by the TweenManager.\r\n   *\r\n   * @method Phaser.Tweens.Timeline#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    for (var i = 0; i < this.data.length; i++) {\n      this.data[i].stop();\n    }\n  }\n});\nTimeline.TYPES = ['onStart', 'onUpdate', 'onLoop', 'onComplete', 'onYoyo'];\nmodule.exports = Timeline;","map":null,"metadata":{},"sourceType":"script"}