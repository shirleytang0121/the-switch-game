{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar DegToRad = require('../../math/DegToRad');\n\nvar GetBoolean = require('../../tweens/builders/GetBoolean');\n\nvar GetValue = require('../../utils/object/GetValue');\n\nvar Sprite = require('../sprite/Sprite');\n\nvar TWEEN_CONST = require('../../tweens/tween/const');\n\nvar Vector2 = require('../../math/Vector2');\n/**\r\n * Settings for a PathFollower.\r\n *\r\n * @typedef {object} PathConfig\r\n *\r\n * @property {number} duration - The duration of the path follow.\r\n * @property {number} from - The start position of the path follow, between 0 and 1.\r\n * @property {number} to - The end position of the path follow, between 0 and 1.\r\n * @property {boolean} [positionOnPath=false] - Whether to position the PathFollower on the Path using its path offset.\r\n * @property {boolean} [rotateToPath=false] - Should the PathFollower automatically rotate to point in the direction of the Path?\r\n * @property {number} [rotationOffset=0] - If the PathFollower is rotating to match the Path, this value is added to the rotation value. This allows you to rotate objects to a path but control the angle of the rotation as well.\r\n * @property {number} [startAt=0] - Current start position of the path follow, between 0 and 1.\r\n */\n\n/**\r\n * @classdesc\r\n * A PathFollower Game Object.\r\n *\r\n * A PathFollower is a Sprite Game Object with some extra helpers to allow it to follow a Path automatically.\r\n *\r\n * Anything you can do with a standard Sprite can be done with this PathFollower, such as animate it, tint it,\r\n * scale it and so on.\r\n *\r\n * PathFollowers are bound to a single Path at any one time and can traverse the length of the Path, from start\r\n * to finish, forwards or backwards, or from any given point on the Path to its end. They can optionally rotate\r\n * to face the direction of the path, be offset from the path coordinates or rotate independently of the Path.\r\n *\r\n * @class PathFollower\r\n * @extends Phaser.GameObjects.Sprite\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this PathFollower belongs.\r\n * @param {Phaser.Curves.Path} path - The Path this PathFollower is following. It can only follow one Path at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n */\n\n\nvar PathFollower = new Class({\n  Extends: Sprite,\n  initialize: function PathFollower(scene, path, x, y, texture, frame) {\n    Sprite.call(this, scene, x, y, texture, frame);\n    /**\r\n     * The Path this PathFollower is following. It can only follow one Path at a time.\r\n     *\r\n     * @name Phaser.GameObjects.PathFollower#path\r\n     * @type {Phaser.Curves.Path}\r\n     * @since 3.0.0\r\n     */\n\n    this.path = path;\n    /**\r\n     * Should the PathFollower automatically rotate to point in the direction of the Path?\r\n     *\r\n     * @name Phaser.GameObjects.PathFollower#rotateToPath\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.rotateToPath = false;\n    /**\r\n     * If the PathFollower is rotating to match the Path (@see Phaser.GameObjects.PathFollower#rotateToPath)\r\n     * this value is added to the rotation value. This allows you to rotate objects to a path but control\r\n     * the angle of the rotation as well.\r\n     *\r\n     * @name Phaser.GameObjects.PathFollower#pathRotationOffset\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.pathRotationOffset = 0;\n    /**\r\n     * An additional vector to add to the PathFollowers position, allowing you to offset it from the\r\n     * Path coordinates.\r\n     *\r\n     * @name Phaser.GameObjects.PathFollower#pathOffset\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.pathOffset = new Vector2(x, y);\n    /**\r\n     * A Vector2 that stores the current point of the path the follower is on.\r\n     *\r\n     * @name Phaser.GameObjects.PathFollower#pathVector\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.pathVector = new Vector2();\n    /**\r\n     * The Tween used for following the Path.\r\n     *\r\n     * @name Phaser.GameObjects.PathFollower#pathTween\r\n     * @type {Phaser.Tweens.Tween}\r\n     * @since 3.0.0\r\n     */\n\n    this.pathTween;\n    /**\r\n     * Settings for the PathFollower.\r\n     *\r\n     * @name Phaser.GameObjects.PathFollower#pathConfig\r\n     * @type {?PathConfig}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.pathConfig = null;\n    /**\r\n     * Records the direction of the follower so it can change direction.\r\n     *\r\n     * @name Phaser.GameObjects.PathFollower#_prevDirection\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._prevDirection = TWEEN_CONST.PLAYING_FORWARD;\n  },\n\n  /**\r\n   * Set the Path that this PathFollower should follow.\r\n   *\r\n   * Optionally accepts {@link PathConfig} settings.\r\n   *\r\n   * @method Phaser.GameObjects.PathFollower#setPath\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Curves.Path} path - The Path this PathFollower is following. It can only follow one Path at a time.\r\n   * @param {PathConfig} [config] - Settings for the PathFollower.\r\n   *\r\n   * @return {Phaser.GameObjects.PathFollower} This Game Object.\r\n   */\n  setPath: function setPath(path, config) {\n    if (config === undefined) {\n      config = this.pathConfig;\n    }\n\n    var tween = this.pathTween;\n\n    if (tween && tween.isPlaying()) {\n      tween.stop();\n    }\n\n    this.path = path;\n\n    if (config) {\n      this.startFollow(config);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Set whether the PathFollower should automatically rotate to point in the direction of the Path.\r\n   *\r\n   * @method Phaser.GameObjects.PathFollower#setRotateToPath\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - Whether the PathFollower should automatically rotate to point in the direction of the Path.\r\n   * @param {number} [offset=0] - Rotation offset in degrees.\r\n   *\r\n   * @return {Phaser.GameObjects.PathFollower} This Game Object.\r\n   */\n  setRotateToPath: function setRotateToPath(value, offset) {\n    if (offset === undefined) {\n      offset = 0;\n    }\n\n    this.rotateToPath = value;\n    this.pathRotationOffset = offset;\n    return this;\n  },\n\n  /**\r\n   * Is this PathFollower actively following a Path or not?\r\n   *\r\n   * To be considered as `isFollowing` it must be currently moving on a Path, and not paused.\r\n   *\r\n   * @method Phaser.GameObjects.PathFollower#isFollowing\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` is this PathFollower is actively following a Path, otherwise `false`.\r\n   */\n  isFollowing: function isFollowing() {\n    var tween = this.pathTween;\n    return tween && tween.isPlaying();\n  },\n\n  /**\r\n   * Starts this PathFollower following its given Path.\r\n   *\r\n   * @method Phaser.GameObjects.PathFollower#startFollow\r\n   * @since 3.3.0\r\n   *\r\n   * @param {(number|PathConfig)} [config={}] - The duration of the follow, or a PathFollower config object.\r\n   * @param {number} [startAt=0] - Optional start position of the follow, between 0 and 1.\r\n   *\r\n   * @return {Phaser.GameObjects.PathFollower} This Game Object.\r\n   */\n  startFollow: function startFollow(config, startAt) {\n    if (config === undefined) {\n      config = {};\n    }\n\n    if (startAt === undefined) {\n      startAt = 0;\n    }\n\n    var tween = this.pathTween;\n\n    if (tween && tween.isPlaying()) {\n      tween.stop();\n    }\n\n    if (typeof config === 'number') {\n      config = {\n        duration: config\n      };\n    } //  Override in case they've been specified in the config\n\n\n    config.from = 0;\n    config.to = 1; //  Can also read extra values out of the config:\n\n    var positionOnPath = GetBoolean(config, 'positionOnPath', false);\n    this.rotateToPath = GetBoolean(config, 'rotateToPath', false);\n    this.pathRotationOffset = GetValue(config, 'rotationOffset', 0); //  This works, but it's not an ideal way of doing it as the follower jumps position\n\n    var seek = GetValue(config, 'startAt', startAt);\n\n    if (seek) {\n      config.onStart = function (tween) {\n        var tweenData = tween.data[0];\n        tweenData.progress = seek;\n        tweenData.elapsed = tweenData.duration * seek;\n        var v = tweenData.ease(tweenData.progress);\n        tweenData.current = tweenData.start + (tweenData.end - tweenData.start) * v;\n        tweenData.target[tweenData.key] = tweenData.current;\n      };\n    }\n\n    this.pathTween = this.scene.sys.tweens.addCounter(config); //  The starting point of the path, relative to this follower\n\n    this.path.getStartPoint(this.pathOffset);\n\n    if (positionOnPath) {\n      this.x = this.pathOffset.x;\n      this.y = this.pathOffset.y;\n    }\n\n    this.pathOffset.x = this.x - this.pathOffset.x;\n    this.pathOffset.y = this.y - this.pathOffset.y;\n    this._prevDirection = TWEEN_CONST.PLAYING_FORWARD;\n\n    if (this.rotateToPath) {\n      //  Set the rotation now (in case the tween has a delay on it, etc)\n      var nextPoint = this.path.getPoint(0.1);\n      this.rotation = Math.atan2(nextPoint.y - this.y, nextPoint.x - this.x) + DegToRad(this.pathRotationOffset);\n    }\n\n    this.pathConfig = config;\n    return this;\n  },\n\n  /**\r\n   * Pauses this PathFollower. It will still continue to render, but it will remain motionless at the\r\n   * point on the Path at which you paused it.\r\n   *\r\n   * @method Phaser.GameObjects.PathFollower#pauseFollow\r\n   * @since 3.3.0\r\n   *\r\n   * @return {Phaser.GameObjects.PathFollower} This Game Object.\r\n   */\n  pauseFollow: function pauseFollow() {\n    var tween = this.pathTween;\n\n    if (tween && tween.isPlaying()) {\n      tween.pause();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Resumes a previously paused PathFollower.\r\n   *\r\n   * If the PathFollower was not paused this has no effect.\r\n   *\r\n   * @method Phaser.GameObjects.PathFollower#resumeFollow\r\n   * @since 3.3.0\r\n   *\r\n   * @return {Phaser.GameObjects.PathFollower} This Game Object.\r\n   */\n  resumeFollow: function resumeFollow() {\n    var tween = this.pathTween;\n\n    if (tween && tween.isPaused()) {\n      tween.resume();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Stops this PathFollower from following the path any longer.\r\n   *\r\n   * This will invoke any 'stop' conditions that may exist on the Path, or for the follower.\r\n   *\r\n   * @method Phaser.GameObjects.PathFollower#stopFollow\r\n   * @since 3.3.0\r\n   *\r\n   * @return {Phaser.GameObjects.PathFollower} This Game Object.\r\n   */\n  stopFollow: function stopFollow() {\n    var tween = this.pathTween;\n\n    if (tween && tween.isPlaying()) {\n      tween.stop();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Internal update handler that advances this PathFollower along the path.\r\n   *\r\n   * Called automatically by the Scene step, should not typically be called directly.\r\n   *\r\n   * @method Phaser.GameObjects.PathFollower#preUpdate\r\n   * @protected\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n   * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n   */\n  preUpdate: function preUpdate(time, delta) {\n    this.anims.update(time, delta);\n    var tween = this.pathTween;\n\n    if (tween) {\n      var tweenData = tween.data[0];\n\n      if (tweenData.state !== TWEEN_CONST.PLAYING_FORWARD && tweenData.state !== TWEEN_CONST.PLAYING_BACKWARD) {\n        //  If delayed, etc then bail out\n        return;\n      }\n\n      var pathVector = this.pathVector;\n      this.path.getPoint(tween.getValue(), pathVector);\n      pathVector.add(this.pathOffset);\n      var oldX = this.x;\n      var oldY = this.y;\n      this.setPosition(pathVector.x, pathVector.y);\n      var speedX = this.x - oldX;\n      var speedY = this.y - oldY;\n\n      if (speedX === 0 && speedY === 0) {\n        //  Bail out early\n        return;\n      }\n\n      if (tweenData.state !== this._prevDirection) {\n        //  We've changed direction, so don't do a rotate this frame\n        this._prevDirection = tweenData.state;\n        return;\n      }\n\n      if (this.rotateToPath) {\n        this.rotation = Math.atan2(speedY, speedX) + DegToRad(this.pathRotationOffset);\n      }\n    }\n  }\n});\nmodule.exports = PathFollower;","map":null,"metadata":{},"sourceType":"script"}