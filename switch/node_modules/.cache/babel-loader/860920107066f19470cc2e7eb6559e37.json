{"ast":null,"code":"var AWS = require('./core');\n\nvar AcceptorStateMachine = require('./state_machine');\n\nvar inherit = AWS.util.inherit;\nvar domain = AWS.util.domain;\n\nvar jmespath = require('jmespath');\n/**\r\n * @api private\r\n */\n\n\nvar hardErrorStates = {\n  success: 1,\n  error: 1,\n  complete: 1\n};\n\nfunction isTerminalState(machine) {\n  return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);\n}\n\nvar fsm = new AcceptorStateMachine();\n\nfsm.setupStates = function () {\n  var transition = function transition(_, done) {\n    var self = this;\n    self._haltHandlersOnError = false;\n    self.emit(self._asm.currentState, function (err) {\n      if (err) {\n        if (isTerminalState(self)) {\n          if (domain && self.domain instanceof domain.Domain) {\n            err.domainEmitter = self;\n            err.domain = self.domain;\n            err.domainThrown = false;\n            self.domain.emit('error', err);\n          } else {\n            throw err;\n          }\n        } else {\n          self.response.error = err;\n          done(err);\n        }\n      } else {\n        done(self.response.error);\n      }\n    });\n  };\n\n  this.addState('validate', 'build', 'error', transition);\n  this.addState('build', 'afterBuild', 'restart', transition);\n  this.addState('afterBuild', 'sign', 'restart', transition);\n  this.addState('sign', 'send', 'retry', transition);\n  this.addState('retry', 'afterRetry', 'afterRetry', transition);\n  this.addState('afterRetry', 'sign', 'error', transition);\n  this.addState('send', 'validateResponse', 'retry', transition);\n  this.addState('validateResponse', 'extractData', 'extractError', transition);\n  this.addState('extractError', 'extractData', 'retry', transition);\n  this.addState('extractData', 'success', 'retry', transition);\n  this.addState('restart', 'build', 'error', transition);\n  this.addState('success', 'complete', 'complete', transition);\n  this.addState('error', 'complete', 'complete', transition);\n  this.addState('complete', null, null, transition);\n};\n\nfsm.setupStates();\n/**\r\n * ## Asynchronous Requests\r\n *\r\n * All requests made through the SDK are asynchronous and use a\r\n * callback interface. Each service method that kicks off a request\r\n * returns an `AWS.Request` object that you can use to register\r\n * callbacks.\r\n *\r\n * For example, the following service method returns the request\r\n * object as \"request\", which can be used to register callbacks:\r\n *\r\n * ```javascript\r\n * // request is an AWS.Request object\r\n * var request = ec2.describeInstances();\r\n *\r\n * // register callbacks on request to retrieve response data\r\n * request.on('success', function(response) {\r\n *   console.log(response.data);\r\n * });\r\n * ```\r\n *\r\n * When a request is ready to be sent, the {send} method should\r\n * be called:\r\n *\r\n * ```javascript\r\n * request.send();\r\n * ```\r\n *\r\n * Since registered callbacks may or may not be idempotent, requests should only\r\n * be sent once. To perform the same operation multiple times, you will need to\r\n * create multiple request objects, each with its own registered callbacks.\r\n *\r\n * ## Removing Default Listeners for Events\r\n *\r\n * Request objects are built with default listeners for the various events,\r\n * depending on the service type. In some cases, you may want to remove\r\n * some built-in listeners to customize behaviour. Doing this requires\r\n * access to the built-in listener functions, which are exposed through\r\n * the {AWS.EventListeners.Core} namespace. For instance, you may\r\n * want to customize the HTTP handler used when sending a request. In this\r\n * case, you can remove the built-in listener associated with the 'send'\r\n * event, the {AWS.EventListeners.Core.SEND} listener and add your own.\r\n *\r\n * ## Multiple Callbacks and Chaining\r\n *\r\n * You can register multiple callbacks on any request object. The\r\n * callbacks can be registered for different events, or all for the\r\n * same event. In addition, you can chain callback registration, for\r\n * example:\r\n *\r\n * ```javascript\r\n * request.\r\n *   on('success', function(response) {\r\n *     console.log(\"Success!\");\r\n *   }).\r\n *   on('error', function(response) {\r\n *     console.log(\"Error!\");\r\n *   }).\r\n *   on('complete', function(response) {\r\n *     console.log(\"Always!\");\r\n *   }).\r\n *   send();\r\n * ```\r\n *\r\n * The above example will print either \"Success! Always!\", or \"Error! Always!\",\r\n * depending on whether the request succeeded or not.\r\n *\r\n * @!attribute httpRequest\r\n *   @readonly\r\n *   @!group HTTP Properties\r\n *   @return [AWS.HttpRequest] the raw HTTP request object\r\n *     containing request headers and body information\r\n *     sent by the service.\r\n *\r\n * @!attribute startTime\r\n *   @readonly\r\n *   @!group Operation Properties\r\n *   @return [Date] the time that the request started\r\n *\r\n * @!group Request Building Events\r\n *\r\n * @!event validate(request)\r\n *   Triggered when a request is being validated. Listeners\r\n *   should throw an error if the request should not be sent.\r\n *   @param request [Request] the request object being sent\r\n *   @see AWS.EventListeners.Core.VALIDATE_CREDENTIALS\r\n *   @see AWS.EventListeners.Core.VALIDATE_REGION\r\n *   @example Ensuring that a certain parameter is set before sending a request\r\n *     var req = s3.putObject(params);\r\n *     req.on('validate', function() {\r\n *       if (!req.params.Body.match(/^Hello\\s/)) {\r\n *         throw new Error('Body must start with \"Hello \"');\r\n *       }\r\n *     });\r\n *     req.send(function(err, data) { ... });\r\n *\r\n * @!event build(request)\r\n *   Triggered when the request payload is being built. Listeners\r\n *   should fill the necessary information to send the request\r\n *   over HTTP.\r\n *   @param (see AWS.Request~validate)\r\n *   @example Add a custom HTTP header to a request\r\n *     var req = s3.putObject(params);\r\n *     req.on('build', function() {\r\n *       req.httpRequest.headers['Custom-Header'] = 'value';\r\n *     });\r\n *     req.send(function(err, data) { ... });\r\n *\r\n * @!event sign(request)\r\n *   Triggered when the request is being signed. Listeners should\r\n *   add the correct authentication headers and/or adjust the body,\r\n *   depending on the authentication mechanism being used.\r\n *   @param (see AWS.Request~validate)\r\n *\r\n * @!group Request Sending Events\r\n *\r\n * @!event send(response)\r\n *   Triggered when the request is ready to be sent. Listeners\r\n *   should call the underlying transport layer to initiate\r\n *   the sending of the request.\r\n *   @param response [Response] the response object\r\n *   @context [Request] the request object that was sent\r\n *   @see AWS.EventListeners.Core.SEND\r\n *\r\n * @!event retry(response)\r\n *   Triggered when a request failed and might need to be retried or redirected.\r\n *   If the response is retryable, the listener should set the\r\n *   `response.error.retryable` property to `true`, and optionally set\r\n *   `response.error.retryDelay` to the millisecond delay for the next attempt.\r\n *   In the case of a redirect, `response.error.redirect` should be set to\r\n *   `true` with `retryDelay` set to an optional delay on the next request.\r\n *\r\n *   If a listener decides that a request should not be retried,\r\n *   it should set both `retryable` and `redirect` to false.\r\n *\r\n *   Note that a retryable error will be retried at most\r\n *   {AWS.Config.maxRetries} times (based on the service object's config).\r\n *   Similarly, a request that is redirected will only redirect at most\r\n *   {AWS.Config.maxRedirects} times.\r\n *\r\n *   @param (see AWS.Request~send)\r\n *   @context (see AWS.Request~send)\r\n *   @example Adding a custom retry for a 404 response\r\n *     request.on('retry', function(response) {\r\n *       // this resource is not yet available, wait 10 seconds to get it again\r\n *       if (response.httpResponse.statusCode === 404 && response.error) {\r\n *         response.error.retryable = true;   // retry this error\r\n *         response.error.retryDelay = 10000; // wait 10 seconds\r\n *       }\r\n *     });\r\n *\r\n * @!group Data Parsing Events\r\n *\r\n * @!event extractError(response)\r\n *   Triggered on all non-2xx requests so that listeners can extract\r\n *   error details from the response body. Listeners to this event\r\n *   should set the `response.error` property.\r\n *   @param (see AWS.Request~send)\r\n *   @context (see AWS.Request~send)\r\n *\r\n * @!event extractData(response)\r\n *   Triggered in successful requests to allow listeners to\r\n *   de-serialize the response body into `response.data`.\r\n *   @param (see AWS.Request~send)\r\n *   @context (see AWS.Request~send)\r\n *\r\n * @!group Completion Events\r\n *\r\n * @!event success(response)\r\n *   Triggered when the request completed successfully.\r\n *   `response.data` will contain the response data and\r\n *   `response.error` will be null.\r\n *   @param (see AWS.Request~send)\r\n *   @context (see AWS.Request~send)\r\n *\r\n * @!event error(error, response)\r\n *   Triggered when an error occurs at any point during the\r\n *   request. `response.error` will contain details about the error\r\n *   that occurred. `response.data` will be null.\r\n *   @param error [Error] the error object containing details about\r\n *     the error that occurred.\r\n *   @param (see AWS.Request~send)\r\n *   @context (see AWS.Request~send)\r\n *\r\n * @!event complete(response)\r\n *   Triggered whenever a request cycle completes. `response.error`\r\n *   should be checked, since the request may have failed.\r\n *   @param (see AWS.Request~send)\r\n *   @context (see AWS.Request~send)\r\n *\r\n * @!group HTTP Events\r\n *\r\n * @!event httpHeaders(statusCode, headers, response, statusMessage)\r\n *   Triggered when headers are sent by the remote server\r\n *   @param statusCode [Integer] the HTTP response code\r\n *   @param headers [map<String,String>] the response headers\r\n *   @param (see AWS.Request~send)\r\n *   @param statusMessage [String] A status message corresponding to the HTTP\r\n *                                 response code\r\n *   @context (see AWS.Request~send)\r\n *\r\n * @!event httpData(chunk, response)\r\n *   Triggered when data is sent by the remote server\r\n *   @param chunk [Buffer] the buffer data containing the next data chunk\r\n *     from the server\r\n *   @param (see AWS.Request~send)\r\n *   @context (see AWS.Request~send)\r\n *   @see AWS.EventListeners.Core.HTTP_DATA\r\n *\r\n * @!event httpUploadProgress(progress, response)\r\n *   Triggered when the HTTP request has uploaded more data\r\n *   @param progress [map] An object containing the `loaded` and `total` bytes\r\n *     of the request.\r\n *   @param (see AWS.Request~send)\r\n *   @context (see AWS.Request~send)\r\n *   @note This event will not be emitted in Node.js 0.8.x.\r\n *\r\n * @!event httpDownloadProgress(progress, response)\r\n *   Triggered when the HTTP request has downloaded more data\r\n *   @param progress [map] An object containing the `loaded` and `total` bytes\r\n *     of the request.\r\n *   @param (see AWS.Request~send)\r\n *   @context (see AWS.Request~send)\r\n *   @note This event will not be emitted in Node.js 0.8.x.\r\n *\r\n * @!event httpError(error, response)\r\n *   Triggered when the HTTP request failed\r\n *   @param error [Error] the error object that was thrown\r\n *   @param (see AWS.Request~send)\r\n *   @context (see AWS.Request~send)\r\n *\r\n * @!event httpDone(response)\r\n *   Triggered when the server is finished sending data\r\n *   @param (see AWS.Request~send)\r\n *   @context (see AWS.Request~send)\r\n *\r\n * @see AWS.Response\r\n */\n\nAWS.Request = inherit({\n  /**\r\n   * Creates a request for an operation on a given service with\r\n   * a set of input parameters.\r\n   *\r\n   * @param service [AWS.Service] the service to perform the operation on\r\n   * @param operation [String] the operation to perform on the service\r\n   * @param params [Object] parameters to send to the operation.\r\n   *   See the operation's documentation for the format of the\r\n   *   parameters.\r\n   */\n  constructor: function Request(service, operation, params) {\n    var endpoint = service.endpoint;\n    var region = service.config.region;\n    var customUserAgent = service.config.customUserAgent; // global endpoints sign as us-east-1\n\n    if (service.isGlobalEndpoint) region = 'us-east-1';\n    this.domain = domain && domain.active;\n    this.service = service;\n    this.operation = operation;\n    this.params = params || {};\n    this.httpRequest = new AWS.HttpRequest(endpoint, region);\n    this.httpRequest.appendToUserAgent(customUserAgent);\n    this.startTime = service.getSkewCorrectedDate();\n    this.response = new AWS.Response(this);\n    this._asm = new AcceptorStateMachine(fsm.states, 'validate');\n    this._haltHandlersOnError = false;\n    AWS.SequentialExecutor.call(this);\n    this.emit = this.emitEvent;\n  },\n\n  /**\r\n   * @!group Sending a Request\r\n   */\n\n  /**\r\n   * @overload send(callback = null)\r\n   *   Sends the request object.\r\n   *\r\n   *   @callback callback function(err, data)\r\n   *     If a callback is supplied, it is called when a response is returned\r\n   *     from the service.\r\n   *     @context [AWS.Request] the request object being sent.\r\n   *     @param err [Error] the error object returned from the request.\r\n   *       Set to `null` if the request is successful.\r\n   *     @param data [Object] the de-serialized data returned from\r\n   *       the request. Set to `null` if a request error occurs.\r\n   *   @example Sending a request with a callback\r\n   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});\r\n   *     request.send(function(err, data) { console.log(err, data); });\r\n   *   @example Sending a request with no callback (using event handlers)\r\n   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});\r\n   *     request.on('complete', function(response) { ... }); // register a callback\r\n   *     request.send();\r\n   */\n  send: function send(callback) {\n    if (callback) {\n      // append to user agent\n      this.httpRequest.appendToUserAgent('callback');\n      this.on('complete', function (resp) {\n        callback.call(resp, resp.error, resp.data);\n      });\n    }\n\n    this.runTo();\n    return this.response;\n  },\n\n  /**\r\n   * @!method  promise()\r\n   *   Sends the request and returns a 'thenable' promise.\r\n   *\r\n   *   Two callbacks can be provided to the `then` method on the returned promise.\r\n   *   The first callback will be called if the promise is fulfilled, and the second\r\n   *   callback will be called if the promise is rejected.\r\n   *   @callback fulfilledCallback function(data)\r\n   *     Called if the promise is fulfilled.\r\n   *     @param data [Object] the de-serialized data returned from the request.\r\n   *   @callback rejectedCallback function(error)\r\n   *     Called if the promise is rejected.\r\n   *     @param error [Error] the error object returned from the request.\r\n   *   @return [Promise] A promise that represents the state of the request.\r\n   *   @example Sending a request using promises.\r\n   *     var request = s3.putObject({Bucket: 'bucket', Key: 'key'});\r\n   *     var result = request.promise();\r\n   *     result.then(function(data) { ... }, function(error) { ... });\r\n   */\n\n  /**\r\n   * @api private\r\n   */\n  build: function build(callback) {\n    return this.runTo('send', callback);\n  },\n\n  /**\r\n   * @api private\r\n   */\n  runTo: function runTo(state, done) {\n    this._asm.runTo(state, done, this);\n\n    return this;\n  },\n\n  /**\r\n   * Aborts a request, emitting the error and complete events.\r\n   *\r\n   * @!macro nobrowser\r\n   * @example Aborting a request after sending\r\n   *   var params = {\r\n   *     Bucket: 'bucket', Key: 'key',\r\n   *     Body: new Buffer(1024 * 1024 * 5) // 5MB payload\r\n   *   };\r\n   *   var request = s3.putObject(params);\r\n   *   request.send(function (err, data) {\r\n   *     if (err) console.log(\"Error:\", err.code, err.message);\r\n   *     else console.log(data);\r\n   *   });\r\n   *\r\n   *   // abort request in 1 second\r\n   *   setTimeout(request.abort.bind(request), 1000);\r\n   *\r\n   *   // prints \"Error: RequestAbortedError Request aborted by user\"\r\n   * @return [AWS.Request] the same request object, for chaining.\r\n   * @since v1.4.0\r\n   */\n  abort: function abort() {\n    this.removeAllListeners('validateResponse');\n    this.removeAllListeners('extractError');\n    this.on('validateResponse', function addAbortedError(resp) {\n      resp.error = AWS.util.error(new Error('Request aborted by user'), {\n        code: 'RequestAbortedError',\n        retryable: false\n      });\n    });\n\n    if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) {\n      // abort HTTP stream\n      this.httpRequest.stream.abort();\n\n      if (this.httpRequest._abortCallback) {\n        this.httpRequest._abortCallback();\n      } else {\n        this.removeAllListeners('send'); // haven't sent yet, so let's not\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Iterates over each page of results given a pageable request, calling\r\n   * the provided callback with each page of data. After all pages have been\r\n   * retrieved, the callback is called with `null` data.\r\n   *\r\n   * @note This operation can generate multiple requests to a service.\r\n   * @example Iterating over multiple pages of objects in an S3 bucket\r\n   *   var pages = 1;\r\n   *   s3.listObjects().eachPage(function(err, data) {\r\n   *     if (err) return;\r\n   *     console.log(\"Page\", pages++);\r\n   *     console.log(data);\r\n   *   });\r\n   * @example Iterating over multiple pages with an asynchronous callback\r\n   *   s3.listObjects(params).eachPage(function(err, data, done) {\r\n   *     doSomethingAsyncAndOrExpensive(function() {\r\n   *       // The next page of results isn't fetched until done is called\r\n   *       done();\r\n   *     });\r\n   *   });\r\n   * @callback callback function(err, data, [doneCallback])\r\n   *   Called with each page of resulting data from the request. If the\r\n   *   optional `doneCallback` is provided in the function, it must be called\r\n   *   when the callback is complete.\r\n   *\r\n   *   @param err [Error] an error object, if an error occurred.\r\n   *   @param data [Object] a single page of response data. If there is no\r\n   *     more data, this object will be `null`.\r\n   *   @param doneCallback [Function] an optional done callback. If this\r\n   *     argument is defined in the function declaration, it should be called\r\n   *     when the next page is ready to be retrieved. This is useful for\r\n   *     controlling serial pagination across asynchronous operations.\r\n   *   @return [Boolean] if the callback returns `false`, pagination will\r\n   *     stop.\r\n   *\r\n   * @see AWS.Request.eachItem\r\n   * @see AWS.Response.nextPage\r\n   * @since v1.4.0\r\n   */\n  eachPage: function eachPage(callback) {\n    // Make all callbacks async-ish\n    callback = AWS.util.fn.makeAsync(callback, 3);\n\n    function wrappedCallback(response) {\n      callback.call(response, response.error, response.data, function (result) {\n        if (result === false) return;\n\n        if (response.hasNextPage()) {\n          response.nextPage().on('complete', wrappedCallback).send();\n        } else {\n          callback.call(response, null, null, AWS.util.fn.noop);\n        }\n      });\n    }\n\n    this.on('complete', wrappedCallback).send();\n  },\n\n  /**\r\n   * Enumerates over individual items of a request, paging the responses if\r\n   * necessary.\r\n   *\r\n   * @api experimental\r\n   * @since v1.4.0\r\n   */\n  eachItem: function eachItem(callback) {\n    var self = this;\n\n    function wrappedCallback(err, data) {\n      if (err) return callback(err, null);\n      if (data === null) return callback(null, null);\n      var config = self.service.paginationConfig(self.operation);\n      var resultKey = config.resultKey;\n      if (Array.isArray(resultKey)) resultKey = resultKey[0];\n      var items = jmespath.search(data, resultKey);\n      var continueIteration = true;\n      AWS.util.arrayEach(items, function (item) {\n        continueIteration = callback(null, item);\n\n        if (continueIteration === false) {\n          return AWS.util.abort;\n        }\n      });\n      return continueIteration;\n    }\n\n    this.eachPage(wrappedCallback);\n  },\n\n  /**\r\n   * @return [Boolean] whether the operation can return multiple pages of\r\n   *   response data.\r\n   * @see AWS.Response.eachPage\r\n   * @since v1.4.0\r\n   */\n  isPageable: function isPageable() {\n    return this.service.paginationConfig(this.operation) ? true : false;\n  },\n\n  /**\r\n   * Sends the request and converts the request object into a readable stream\r\n   * that can be read from or piped into a writable stream.\r\n   *\r\n   * @note The data read from a readable stream contains only\r\n   *   the raw HTTP body contents.\r\n   * @example Manually reading from a stream\r\n   *   request.createReadStream().on('data', function(data) {\r\n   *     console.log(\"Got data:\", data.toString());\r\n   *   });\r\n   * @example Piping a request body into a file\r\n   *   var out = fs.createWriteStream('/path/to/outfile.jpg');\r\n   *   s3.service.getObject(params).createReadStream().pipe(out);\r\n   * @return [Stream] the readable stream object that can be piped\r\n   *   or read from (by registering 'data' event listeners).\r\n   * @!macro nobrowser\r\n   */\n  createReadStream: function createReadStream() {\n    var streams = AWS.util.stream;\n    var req = this;\n    var stream = null;\n\n    if (AWS.HttpClient.streamsApiVersion === 2) {\n      stream = new streams.PassThrough();\n      process.nextTick(function () {\n        req.send();\n      });\n    } else {\n      stream = new streams.Stream();\n      stream.readable = true;\n      stream.sent = false;\n      stream.on('newListener', function (event) {\n        if (!stream.sent && event === 'data') {\n          stream.sent = true;\n          process.nextTick(function () {\n            req.send();\n          });\n        }\n      });\n    }\n\n    this.on('error', function (err) {\n      stream.emit('error', err);\n    });\n    this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {\n      if (statusCode < 300) {\n        req.removeListener('httpData', AWS.EventListeners.Core.HTTP_DATA);\n        req.removeListener('httpError', AWS.EventListeners.Core.HTTP_ERROR);\n        req.on('httpError', function streamHttpError(error) {\n          resp.error = error;\n          resp.error.retryable = false;\n        });\n        var shouldCheckContentLength = false;\n        var expectedLen;\n\n        if (req.httpRequest.method !== 'HEAD') {\n          expectedLen = parseInt(headers['content-length'], 10);\n        }\n\n        if (expectedLen !== undefined && !isNaN(expectedLen) && expectedLen >= 0) {\n          shouldCheckContentLength = true;\n          var receivedLen = 0;\n        }\n\n        var checkContentLengthAndEmit = function checkContentLengthAndEmit() {\n          if (shouldCheckContentLength && receivedLen !== expectedLen) {\n            stream.emit('error', AWS.util.error(new Error('Stream content length mismatch. Received ' + receivedLen + ' of ' + expectedLen + ' bytes.'), {\n              code: 'StreamContentLengthMismatch'\n            }));\n          } else if (AWS.HttpClient.streamsApiVersion === 2) {\n            stream.end();\n          } else {\n            stream.emit('end');\n          }\n        };\n\n        var httpStream = resp.httpResponse.createUnbufferedStream();\n\n        if (AWS.HttpClient.streamsApiVersion === 2) {\n          if (shouldCheckContentLength) {\n            var lengthAccumulator = new streams.PassThrough();\n\n            lengthAccumulator._write = function (chunk) {\n              if (chunk && chunk.length) {\n                receivedLen += chunk.length;\n              }\n\n              return streams.PassThrough.prototype._write.apply(this, arguments);\n            };\n\n            lengthAccumulator.on('end', checkContentLengthAndEmit);\n            stream.on('error', function (err) {\n              shouldCheckContentLength = false;\n              httpStream.unpipe(lengthAccumulator);\n              lengthAccumulator.emit('end');\n              lengthAccumulator.end();\n            });\n            httpStream.pipe(lengthAccumulator).pipe(stream, {\n              end: false\n            });\n          } else {\n            httpStream.pipe(stream);\n          }\n        } else {\n          if (shouldCheckContentLength) {\n            httpStream.on('data', function (arg) {\n              if (arg && arg.length) {\n                receivedLen += arg.length;\n              }\n            });\n          }\n\n          httpStream.on('data', function (arg) {\n            stream.emit('data', arg);\n          });\n          httpStream.on('end', checkContentLengthAndEmit);\n        }\n\n        httpStream.on('error', function (err) {\n          shouldCheckContentLength = false;\n          stream.emit('error', err);\n        });\n      }\n    });\n    return stream;\n  },\n\n  /**\r\n   * @param [Array,Response] args This should be the response object,\r\n   *   or an array of args to send to the event.\r\n   * @api private\r\n   */\n  emitEvent: function emit(eventName, args, done) {\n    if (typeof args === 'function') {\n      done = args;\n      args = null;\n    }\n\n    if (!done) done = function done() {};\n    if (!args) args = this.eventParameters(eventName, this.response);\n    var origEmit = AWS.SequentialExecutor.prototype.emit;\n    origEmit.call(this, eventName, args, function (err) {\n      if (err) this.response.error = err;\n      done.call(this, err);\n    });\n  },\n\n  /**\r\n   * @api private\r\n   */\n  eventParameters: function eventParameters(eventName) {\n    switch (eventName) {\n      case 'restart':\n      case 'validate':\n      case 'sign':\n      case 'build':\n      case 'afterValidate':\n      case 'afterBuild':\n        return [this];\n\n      case 'error':\n        return [this.response.error, this.response];\n\n      default:\n        return [this.response];\n    }\n  },\n\n  /**\r\n   * @api private\r\n   */\n  presign: function presign(expires, callback) {\n    if (!callback && typeof expires === 'function') {\n      callback = expires;\n      expires = null;\n    }\n\n    return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);\n  },\n\n  /**\r\n   * @api private\r\n   */\n  isPresigned: function isPresigned() {\n    return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');\n  },\n\n  /**\r\n   * @api private\r\n   */\n  toUnauthenticated: function toUnauthenticated() {\n    this._unAuthenticated = true;\n    this.removeListener('validate', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);\n    this.removeListener('sign', AWS.EventListeners.Core.SIGN);\n    return this;\n  },\n\n  /**\r\n   * @api private\r\n   */\n  toGet: function toGet() {\n    if (this.service.api.protocol === 'query' || this.service.api.protocol === 'ec2') {\n      this.removeListener('build', this.buildAsGet);\n      this.addListener('build', this.buildAsGet);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * @api private\r\n   */\n  buildAsGet: function buildAsGet(request) {\n    request.httpRequest.method = 'GET';\n    request.httpRequest.path = request.service.endpoint.path + '?' + request.httpRequest.body;\n    request.httpRequest.body = ''; // don't need these headers on a GET request\n\n    delete request.httpRequest.headers['Content-Length'];\n    delete request.httpRequest.headers['Content-Type'];\n  },\n\n  /**\r\n   * @api private\r\n   */\n  haltHandlersOnError: function haltHandlersOnError() {\n    this._haltHandlersOnError = true;\n  }\n});\n/**\r\n * @api private\r\n */\n\nAWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.promise = function promise() {\n    var self = this; // append to user agent\n\n    this.httpRequest.appendToUserAgent('promise');\n    return new PromiseDependency(function (resolve, reject) {\n      self.on('complete', function (resp) {\n        if (resp.error) {\n          reject(resp.error);\n        } else {\n          // define $response property so that it is not enumberable\n          // this prevents circular reference errors when stringifying the JSON object\n          resolve(Object.defineProperty(resp.data || {}, '$response', {\n            value: resp\n          }));\n        }\n      });\n      self.runTo();\n    });\n  };\n};\n/**\r\n * @api private\r\n */\n\n\nAWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.promise;\n};\n\nAWS.util.addPromises(AWS.Request);\nAWS.util.mixin(AWS.Request, AWS.SequentialExecutor);","map":null,"metadata":{},"sourceType":"script"}