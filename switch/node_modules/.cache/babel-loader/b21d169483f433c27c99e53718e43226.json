{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Body = require('./Body');\n\nvar Clamp = require('../../math/Clamp');\n\nvar Class = require('../../utils/Class');\n\nvar Collider = require('./Collider');\n\nvar CONST = require('./const');\n\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar FuzzyEqual = require('../../math/fuzzy/Equal');\n\nvar FuzzyGreaterThan = require('../../math/fuzzy/GreaterThan');\n\nvar FuzzyLessThan = require('../../math/fuzzy/LessThan');\n\nvar GetOverlapX = require('./GetOverlapX');\n\nvar GetOverlapY = require('./GetOverlapY');\n\nvar GetValue = require('../../utils/object/GetValue');\n\nvar ProcessQueue = require('../../structs/ProcessQueue');\n\nvar ProcessTileCallbacks = require('./tilemap/ProcessTileCallbacks');\n\nvar Rectangle = require('../../geom/rectangle/Rectangle');\n\nvar RTree = require('../../structs/RTree');\n\nvar SeparateTile = require('./tilemap/SeparateTile');\n\nvar SeparateX = require('./SeparateX');\n\nvar SeparateY = require('./SeparateY');\n\nvar Set = require('../../structs/Set');\n\nvar StaticBody = require('./StaticBody');\n\nvar TileIntersectsBody = require('./tilemap/TileIntersectsBody');\n\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\n\nvar Vector2 = require('../../math/Vector2');\n\nvar Wrap = require('../../math/Wrap');\n/**\r\n * @typedef {object} ArcadeWorldConfig\r\n *\r\n * @property {number} [fps=60] - Sets {@link Phaser.Physics.Arcade.World#fps}.\r\n * @property {number} [timeScale=1] - Sets {@link Phaser.Physics.Arcade.World#timeScale}.\r\n * @property {object} [gravity] - Sets {@link Phaser.Physics.Arcade.World#gravity}.\r\n * @property {number} [gravity.x=0] - The horizontal world gravity value.\r\n * @property {number} [gravity.y=0] - The vertical world gravity value.\r\n * @property {number} [x=0] - Sets {@link Phaser.Physics.Arcade.World#bounds bounds.x}.\r\n * @property {number} [y=0] - Sets {@link Phaser.Physics.Arcade.World#bounds bounds.y}.\r\n * @property {number} [width=0] - Sets {@link Phaser.Physics.Arcade.World#bounds bounds.width}.\r\n * @property {number} [height=0] - Sets {@link Phaser.Physics.Arcade.World#bounds bounds.height}.\r\n * @property {object} [checkCollision] - Sets {@link Phaser.Physics.Arcade.World#checkCollision}.\r\n * @property {boolean} [checkCollision.up=true] - Should bodies collide with the top of the world bounds?\r\n * @property {boolean} [checkCollision.down=true] - Should bodies collide with the bottom of the world bounds?\r\n * @property {boolean} [checkCollision.left=true] - Should bodies collide with the left of the world bounds?\r\n * @property {boolean} [checkCollision.right=true] - Should bodies collide with the right of the world bounds?\r\n * @property {number} [overlapBias=4] - Sets {@link Phaser.Physics.Arcade.World#OVERLAP_BIAS}.\r\n * @property {number} [tileBias=16] - Sets {@link Phaser.Physics.Arcade.World#TILE_BIAS}.\r\n * @property {boolean} [forceX=false] - Sets {@link Phaser.Physics.Arcade.World#forceX}.\r\n * @property {boolean} [isPaused=false] - Sets {@link Phaser.Physics.Arcade.World#isPaused}.\r\n * @property {boolean} [debug=false] - Sets {@link Phaser.Physics.Arcade.World#debug}.\r\n * @property {boolean} [debugShowBody=true] - Sets {@link Phaser.Physics.Arcade.World#defaults debugShowBody}.\r\n * @property {boolean} [debugShowStaticBody=true] - Sets {@link Phaser.Physics.Arcade.World#defaults debugShowStaticBody}.\r\n * @property {boolean} [debugShowVelocity=true] - Sets {@link Phaser.Physics.Arcade.World#defaults debugShowStaticBody}.\r\n * @property {number} [debugBodyColor=0xff00ff] - Sets {@link Phaser.Physics.Arcade.World#defaults debugBodyColor}.\r\n * @property {number} [debugStaticBodyColor=0x0000ff] - Sets {@link Phaser.Physics.Arcade.World#defaults debugStaticBodyColor}.\r\n * @property {number} [debugVelocityColor=0x00ff00] - Sets {@link Phaser.Physics.Arcade.World#defaults debugVelocityColor}.\r\n * @property {number} [maxEntries=16] - Sets {@link Phaser.Physics.Arcade.World#maxEntries}.\r\n * @property {boolean} [useTree=true] - Sets {@link Phaser.Physics.Arcade.World#useTree}.\r\n */\n\n/**\r\n * @typedef {object} CheckCollisionObject\r\n *\r\n * @property {boolean} up - Will bodies collide with the top side of the world bounds?\r\n * @property {boolean} down - Will bodies collide with the bottom side of the world bounds?\r\n * @property {boolean} left - Will bodies collide with the left side of the world bounds?\r\n * @property {boolean} right - Will bodies collide with the right side of the world bounds?\r\n */\n\n/**\r\n * @typedef {object} ArcadeWorldDefaults\r\n *\r\n * @property {boolean} debugShowBody - Set to `true` to render dynamic body outlines to the debug display.\r\n * @property {boolean} debugShowStaticBody - Set to `true` to render static body outlines to the debug display.\r\n * @property {boolean} debugShowVelocity - Set to `true` to render body velocity markers to the debug display.\r\n * @property {number} bodyDebugColor - The color of dynamic body outlines when rendered to the debug display.\r\n * @property {number} staticBodyDebugColor - The color of static body outlines when rendered to the debug display.\r\n * @property {number} velocityDebugColor - The color of the velocity markers when rendered to the debug display.\r\n */\n\n/**\r\n * @typedef {object} ArcadeWorldTreeMinMax\r\n *\r\n * @property {number} minX - The minimum x value used in RTree searches.\r\n * @property {number} minY - The minimum y value used in RTree searches.\r\n * @property {number} maxX - The maximum x value used in RTree searches.\r\n * @property {number} maxY - The maximum y value used in RTree searches.\r\n */\n\n/**\r\n * An Arcade Physics Collider Type.\r\n *\r\n * @typedef {(\r\n * Phaser.GameObjects.GameObject|\r\n * Phaser.GameObjects.Group|\r\n * Phaser.Physics.Arcade.Sprite|\r\n * Phaser.Physics.Arcade.Image|\r\n * Phaser.Physics.Arcade.StaticGroup|\r\n * Phaser.Physics.Arcade.Group|\r\n * Phaser.Tilemaps.DynamicTilemapLayer|\r\n * Phaser.Tilemaps.StaticTilemapLayer|\r\n * Phaser.GameObjects.GameObject[]|\r\n * Phaser.Physics.Arcade.Sprite[]|\r\n * Phaser.Physics.Arcade.Image[]|\r\n * Phaser.Physics.Arcade.StaticGroup[]|\r\n * Phaser.Physics.Arcade.Group[]|\r\n * Phaser.Tilemaps.DynamicTilemapLayer[]|\r\n * Phaser.Tilemaps.StaticTilemapLayer[]\r\n * )} ArcadeColliderType\r\n */\n\n/**\r\n * @classdesc\r\n * The Arcade Physics World.\r\n *\r\n * The World is responsible for creating, managing, colliding and updating all of the bodies within it.\r\n *\r\n * An instance of the World belongs to a Phaser.Scene and is accessed via the property `physics.world`.\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this World instance belongs.\r\n * @param {ArcadeWorldConfig} config - An Arcade Physics Configuration object.\r\n */\n\n\nvar World = new Class({\n  Extends: EventEmitter,\n  initialize: function World(scene, config) {\n    EventEmitter.call(this);\n    /**\r\n     * The Scene this simulation belongs to.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n\n    this.scene = scene;\n    /**\r\n     * Dynamic Bodies in this simulation.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#bodies\r\n     * @type {Phaser.Structs.Set.<Phaser.Physics.Arcade.Body>}\r\n     * @since 3.0.0\r\n     */\n\n    this.bodies = new Set();\n    /**\r\n     * Static Bodies in this simulation.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#staticBodies\r\n     * @type {Phaser.Structs.Set.<Phaser.Physics.Arcade.StaticBody>}\r\n     * @since 3.0.0\r\n     */\n\n    this.staticBodies = new Set();\n    /**\r\n     * Static Bodies marked for deletion.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#pendingDestroy\r\n     * @type {Phaser.Structs.Set.<(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)>}\r\n     * @since 3.1.0\r\n     */\n\n    this.pendingDestroy = new Set();\n    /**\r\n     * Dynamic Bodies that need a second `update` call to resynchronize their Game Objects.\r\n     * This set is filled only when the `_late` flag is on, and is processed and cleared during `postUpdate`.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#late\r\n     * @type {Phaser.Structs.Set.<Phaser.Physics.Arcade.Body>}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this.late = new Set();\n    /**\r\n     * A flag allowing the `late` set to be filled, as appropriate.\r\n     * This is on (true) only between `update` and `postUpdate` and false at other times.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#_late\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this._late = false;\n    /**\r\n     * This simulation's collision processors.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#colliders\r\n     * @type {Phaser.Structs.ProcessQueue.<Phaser.Physics.Arcade.Collider>}\r\n     * @since 3.0.0\r\n     */\n\n    this.colliders = new ProcessQueue();\n    /**\r\n     * Acceleration of Bodies due to gravity, in pixels per second.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#gravity\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.gravity = new Vector2(GetValue(config, 'gravity.x', 0), GetValue(config, 'gravity.y', 0));\n    /**\r\n     * A boundary constraining Bodies.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#bounds\r\n     * @type {Phaser.Geom.Rectangle}\r\n     * @since 3.0.0\r\n     */\n\n    this.bounds = new Rectangle(GetValue(config, 'x', 0), GetValue(config, 'y', 0), GetValue(config, 'width', scene.sys.scale.width), GetValue(config, 'height', scene.sys.scale.height));\n    /**\r\n     * The boundary edges that Bodies can collide with.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#checkCollision\r\n     * @type {CheckCollisionObject}\r\n     * @since 3.0.0\r\n     */\n\n    this.checkCollision = {\n      up: GetValue(config, 'checkCollision.up', true),\n      down: GetValue(config, 'checkCollision.down', true),\n      left: GetValue(config, 'checkCollision.left', true),\n      right: GetValue(config, 'checkCollision.right', true)\n    };\n    /**\r\n     * The number of physics steps to be taken per second.\r\n     *\r\n     * This property is read-only. Use the `setFPS` method to modify it at run-time.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#fps\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 60\r\n     * @since 3.10.0\r\n     */\n\n    this.fps = GetValue(config, 'fps', 60);\n    /**\r\n     * The amount of elapsed ms since the last frame.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#_elapsed\r\n     * @private\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\n\n    this._elapsed = 0;\n    /**\r\n     * Internal frame time value.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#_frameTime\r\n     * @private\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\n\n    this._frameTime = 1 / this.fps;\n    /**\r\n     * Internal frame time ms value.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#_frameTimeMS\r\n     * @private\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\n\n    this._frameTimeMS = 1000 * this._frameTime;\n    /**\r\n     * The number of steps that took place in the last frame.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#stepsLastFrame\r\n     * @readonly\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\n\n    this.stepsLastFrame = 0;\n    /**\r\n     * Scaling factor applied to the frame rate.\r\n     *\r\n     * - 1.0 = normal speed\r\n     * - 2.0 = half speed\r\n     * - 0.5 = double speed\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#timeScale\r\n     * @property {number}\r\n     * @default 1\r\n     * @since 3.10.0\r\n     */\n\n    this.timeScale = GetValue(config, 'timeScale', 1);\n    /**\r\n     * The maximum absolute difference of a Body's per-step velocity and its overlap with another Body that will result in separation on *each axis*.\r\n     * Larger values favor separation.\r\n     * Smaller values favor no separation.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#OVERLAP_BIAS\r\n     * @type {number}\r\n     * @default 4\r\n     * @since 3.0.0\r\n     */\n\n    this.OVERLAP_BIAS = GetValue(config, 'overlapBias', 4);\n    /**\r\n     * The maximum absolute value of a Body's overlap with a tile that will result in separation on *each axis*.\r\n     * Larger values favor separation.\r\n     * Smaller values favor no separation.\r\n     * The optimum value may be similar to the tile size.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#TILE_BIAS\r\n     * @type {number}\r\n     * @default 16\r\n     * @since 3.0.0\r\n     */\n\n    this.TILE_BIAS = GetValue(config, 'tileBias', 16);\n    /**\r\n     * Always separate overlapping Bodies horizontally before vertically.\r\n     * False (the default) means Bodies are first separated on the axis of greater gravity, or the vertical axis if neither is greater.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#forceX\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.forceX = GetValue(config, 'forceX', false);\n    /**\r\n     * Whether the simulation advances with the game loop.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#isPaused\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.isPaused = GetValue(config, 'isPaused', false);\n    /**\r\n     * Temporary total of colliding Bodies.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#_total\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this._total = 0;\n    /**\r\n     * Enables the debug display.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#drawDebug\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.drawDebug = GetValue(config, 'debug', false);\n    /**\r\n     * The graphics object drawing the debug display.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#debugGraphic\r\n     * @type {Phaser.GameObjects.Graphics}\r\n     * @since 3.0.0\r\n     */\n\n    this.debugGraphic;\n    /**\r\n     * Default debug display settings for new Bodies.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#defaults\r\n     * @type {ArcadeWorldDefaults}\r\n     * @since 3.0.0\r\n     */\n\n    this.defaults = {\n      debugShowBody: GetValue(config, 'debugShowBody', true),\n      debugShowStaticBody: GetValue(config, 'debugShowStaticBody', true),\n      debugShowVelocity: GetValue(config, 'debugShowVelocity', true),\n      bodyDebugColor: GetValue(config, 'debugBodyColor', 0xff00ff),\n      staticBodyDebugColor: GetValue(config, 'debugStaticBodyColor', 0x0000ff),\n      velocityDebugColor: GetValue(config, 'debugVelocityColor', 0x00ff00)\n    };\n    /**\r\n     * The maximum number of items per node on the RTree.\r\n     *\r\n     * This is ignored if `useTree` is `false`. If you have a large number of bodies in\r\n     * your world then you may find search performance improves by increasing this value,\r\n     * to allow more items per node and less node division.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#maxEntries\r\n     * @type {integer}\r\n     * @default 16\r\n     * @since 3.0.0\r\n     */\n\n    this.maxEntries = GetValue(config, 'maxEntries', 16);\n    /**\r\n     * Should this Arcade Physics World use an RTree for Dynamic Physics bodies or not?\r\n     *\r\n     * An RTree is a fast way of spatially sorting of all the moving bodies in the world.\r\n     * However, at certain limits, the cost of clearing and inserting the bodies into the\r\n     * tree every frame becomes more expensive than the search speed gains it provides.\r\n     *\r\n     * If you have a large number of dynamic bodies in your world then it may be best to\r\n     * disable the use of the RTree by setting this property to `true`.\r\n     * The number it can cope with depends on browser and device, but a conservative estimate\r\n     * of around 5,000 bodies should be considered the max before disabling it.\r\n     *\r\n     * Note this only applies to dynamic bodies. Static bodies are always kept in an RTree,\r\n     * because they don't have to be cleared every frame, so you benefit from the\r\n     * massive search speeds all the time.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#useTree\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.10.0\r\n     */\n\n    this.useTree = GetValue(config, 'useTree', true);\n    /**\r\n     * The spatial index of Dynamic Bodies.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#tree\r\n     * @type {Phaser.Structs.RTree}\r\n     * @since 3.0.0\r\n     */\n\n    this.tree = new RTree(this.maxEntries);\n    /**\r\n     * The spatial index of Static Bodies.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#staticTree\r\n     * @type {Phaser.Structs.RTree}\r\n     * @since 3.0.0\r\n     */\n\n    this.staticTree = new RTree(this.maxEntries);\n    /**\r\n     * Recycled input for tree searches.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#treeMinMax\r\n     * @type {ArcadeWorldTreeMinMax}\r\n     * @since 3.0.0\r\n     */\n\n    this.treeMinMax = {\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0\n    };\n    /**\r\n     * A temporary Transform Matrix used by bodies for calculations without them needing their own local copy.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#_tempMatrix\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix used by bodies for calculations without them needing their own local copy.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#_tempMatrix2\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix2 = new TransformMatrix();\n\n    if (this.drawDebug) {\n      this.createDebugGraphic();\n    }\n  },\n\n  /**\r\n   * Adds an Arcade Physics Body to a Game Object, an array of Game Objects, or the children of a Group.\r\n   *\r\n   * The difference between this and the `enableBody` method is that you can pass arrays or Groups\r\n   * to this method.\r\n   *\r\n   * You can specify if the bodies are to be Dynamic or Static. A dynamic body can move via velocity and\r\n   * acceleration. A static body remains fixed in place and as such is able to use an optimized search\r\n   * tree, making it ideal for static elements such as level objects. You can still collide and overlap\r\n   * with static bodies.\r\n   *\r\n   * Normally, rather than calling this method directly, you'd use the helper methods available in the\r\n   * Arcade Physics Factory, such as:\r\n   *\r\n   * ```javascript\r\n   * this.physics.add.image(x, y, textureKey);\r\n   * this.physics.add.sprite(x, y, textureKey);\r\n   * ```\r\n   *\r\n   * Calling factory methods encapsulates the creation of a Game Object and the creation of its\r\n   * body at the same time. If you are creating custom classes then you can pass them to this\r\n   * method to have their bodies created.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#enable\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object - The object, or objects, on which to create the bodies.\r\n   * @param {integer} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.\r\n   */\n  enable: function enable(object, bodyType) {\n    if (bodyType === undefined) {\n      bodyType = CONST.DYNAMIC_BODY;\n    }\n\n    if (!Array.isArray(object)) {\n      object = [object];\n    }\n\n    for (var i = 0; i < object.length; i++) {\n      var entry = object[i];\n\n      if (entry.isParent) {\n        var children = entry.getChildren();\n\n        for (var c = 0; c < children.length; c++) {\n          var child = children[c];\n\n          if (child.isParent) {\n            //  Handle Groups nested inside of Groups\n            this.enable(child, bodyType);\n          } else {\n            this.enableBody(child, bodyType);\n          }\n        }\n      } else {\n        this.enableBody(entry, bodyType);\n      }\n    }\n  },\n\n  /**\r\n   * Creates an Arcade Physics Body on a single Game Object.\r\n   *\r\n   * If the Game Object already has a body, this method will simply add it back into the simulation.\r\n   *\r\n   * You can specify if the body is Dynamic or Static. A dynamic body can move via velocity and\r\n   * acceleration. A static body remains fixed in place and as such is able to use an optimized search\r\n   * tree, making it ideal for static elements such as level objects. You can still collide and overlap\r\n   * with static bodies.\r\n   *\r\n   * Normally, rather than calling this method directly, you'd use the helper methods available in the\r\n   * Arcade Physics Factory, such as:\r\n   *\r\n   * ```javascript\r\n   * this.physics.add.image(x, y, textureKey);\r\n   * this.physics.add.sprite(x, y, textureKey);\r\n   * ```\r\n   *\r\n   * Calling factory methods encapsulates the creation of a Game Object and the creation of its\r\n   * body at the same time. If you are creating custom classes then you can pass them to this\r\n   * method to have their bodies created.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#enableBody\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} object - The Game Object on which to create the body.\r\n   * @param {integer} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject} The Game Object on which the body was created.\r\n   */\n  enableBody: function enableBody(object, bodyType) {\n    if (bodyType === undefined) {\n      bodyType = CONST.DYNAMIC_BODY;\n    }\n\n    if (!object.body) {\n      if (bodyType === CONST.DYNAMIC_BODY) {\n        object.body = new Body(this, object);\n      } else if (bodyType === CONST.STATIC_BODY) {\n        object.body = new StaticBody(this, object);\n      }\n    }\n\n    this.add(object.body);\n    return object;\n  },\n\n  /**\r\n   * Adds an existing Arcade Physics Body or StaticBody to the simulation.\r\n   *\r\n   * The body is enabled and added to the local search trees.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#add\r\n   * @since 3.10.0\r\n   *\r\n   * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The Body to be added to the simulation.\r\n   *\r\n   * @return {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} The Body that was added to the simulation.\r\n   */\n  add: function add(body) {\n    if (body.physicsType === CONST.DYNAMIC_BODY) {\n      this.bodies.set(body);\n    } else if (body.physicsType === CONST.STATIC_BODY) {\n      this.staticBodies.set(body);\n      this.staticTree.insert(body);\n    }\n\n    body.enable = true;\n    return body;\n  },\n\n  /**\r\n   * Disables the Arcade Physics Body of a Game Object, an array of Game Objects, or the children of a Group.\r\n   *\r\n   * The difference between this and the `disableBody` method is that you can pass arrays or Groups\r\n   * to this method.\r\n   *\r\n   * The body itself is not deleted, it just has its `enable` property set to false, which\r\n   * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#disable\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object - The object, or objects, on which to disable the bodies.\r\n   */\n  disable: function disable(object) {\n    if (!Array.isArray(object)) {\n      object = [object];\n    }\n\n    for (var i = 0; i < object.length; i++) {\n      var entry = object[i];\n\n      if (entry.isParent) {\n        var children = entry.getChildren();\n\n        for (var c = 0; c < children.length; c++) {\n          var child = children[c];\n\n          if (child.isParent) {\n            //  Handle Groups nested inside of Groups\n            this.disable(child);\n          } else {\n            this.disableBody(child.body);\n          }\n        }\n      } else {\n        this.disableBody(entry.body);\n      }\n    }\n  },\n\n  /**\r\n   * Disables an existing Arcade Physics Body or StaticBody and removes it from the simulation.\r\n   *\r\n   * The body is disabled and removed from the local search trees.\r\n   *\r\n   * The body itself is not deleted, it just has its `enable` property set to false, which\r\n   * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#disableBody\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The Body to be disabled.\r\n   */\n  disableBody: function disableBody(body) {\n    this.remove(body);\n    body.enable = false;\n  },\n\n  /**\r\n   * Removes an existing Arcade Physics Body or StaticBody from the simulation.\r\n   *\r\n   * The body is disabled and removed from the local search trees.\r\n   *\r\n   * The body itself is not deleted, it just has its `enabled` property set to false, which\r\n   * means you can re-enable it again at any point by passing it to enable `enable` or `add`.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#remove\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The body to be removed from the simulation.\r\n   */\n  remove: function remove(body) {\n    if (body.physicsType === CONST.DYNAMIC_BODY) {\n      this.tree.remove(body);\n      this.bodies.delete(body);\n      this.late.delete(body);\n    } else if (body.physicsType === CONST.STATIC_BODY) {\n      this.staticBodies.delete(body);\n      this.staticTree.remove(body);\n    }\n  },\n\n  /**\r\n   * Creates a Graphics Game Object that the world will use to render the debug display to.\r\n   *\r\n   * This is called automatically when the World is instantiated if the `debug` config property\r\n   * was set to `true`. However, you can call it at any point should you need to display the\r\n   * debug Graphic from a fixed point.\r\n   *\r\n   * You can control which objects are drawn to the Graphics object, and the colors they use,\r\n   * by setting the debug properties in the physics config.\r\n   *\r\n   * You should not typically use this in a production game. Use it to aid during debugging.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#createDebugGraphic\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.GameObjects.Graphics} The Graphics object that was created for use by the World.\r\n   */\n  createDebugGraphic: function createDebugGraphic() {\n    var graphic = this.scene.sys.add.graphics({\n      x: 0,\n      y: 0\n    });\n    graphic.setDepth(Number.MAX_VALUE);\n    this.debugGraphic = graphic;\n    this.drawDebug = true;\n    return graphic;\n  },\n\n  /**\r\n   * Sets the position, size and properties of the World boundary.\r\n   *\r\n   * The World boundary is an invisible rectangle that defines the edges of the World.\r\n   * If a Body is set to collide with the world bounds then it will automatically stop\r\n   * when it reaches any of the edges. You can optionally set which edges of the boundary\r\n   * should be checked against.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#setBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The top-left x coordinate of the boundary.\r\n   * @param {number} y - The top-left y coordinate of the boundary.\r\n   * @param {number} width - The width of the boundary.\r\n   * @param {number} height - The height of the boundary.\r\n   * @param {boolean} [checkLeft] - Should bodies check against the left edge of the boundary?\r\n   * @param {boolean} [checkRight] - Should bodies check against the right edge of the boundary?\r\n   * @param {boolean} [checkUp] - Should bodies check against the top edge of the boundary?\r\n   * @param {boolean} [checkDown] - Should bodies check against the bottom edge of the boundary?\r\n   *\r\n   * @return {Phaser.Physics.Arcade.World} This World object.\r\n   */\n  setBounds: function setBounds(x, y, width, height, checkLeft, checkRight, checkUp, checkDown) {\n    this.bounds.setTo(x, y, width, height);\n\n    if (checkLeft !== undefined) {\n      this.setBoundsCollision(checkLeft, checkRight, checkUp, checkDown);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Enables or disables collisions on each edge of the World boundary.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#setBoundsCollision\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [left=true] - Should bodies check against the left edge of the boundary?\r\n   * @param {boolean} [right=true] - Should bodies check against the right edge of the boundary?\r\n   * @param {boolean} [up=true] - Should bodies check against the top edge of the boundary?\r\n   * @param {boolean} [down=true] - Should bodies check against the bottom edge of the boundary?\r\n   *\r\n   * @return {Phaser.Physics.Arcade.World} This World object.\r\n   */\n  setBoundsCollision: function setBoundsCollision(left, right, up, down) {\n    if (left === undefined) {\n      left = true;\n    }\n\n    if (right === undefined) {\n      right = true;\n    }\n\n    if (up === undefined) {\n      up = true;\n    }\n\n    if (down === undefined) {\n      down = true;\n    }\n\n    this.checkCollision.left = left;\n    this.checkCollision.right = right;\n    this.checkCollision.up = up;\n    this.checkCollision.down = down;\n    return this;\n  },\n\n  /**\r\n   * Pauses the simulation.\r\n   *\r\n   * A paused simulation does not update any existing bodies, or run any Colliders.\r\n   *\r\n   * However, you can still enable and disable bodies within it, or manually run collide or overlap\r\n   * checks.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#pause\r\n   * @fires Phaser.Physics.Arcade.Events#PAUSE\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Arcade.World} This World object.\r\n   */\n  pause: function pause() {\n    this.isPaused = true;\n    this.emit(Events.PAUSE);\n    return this;\n  },\n\n  /**\r\n   * Resumes the simulation, if paused.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#resume\r\n   * @fires Phaser.Physics.Arcade.Events#RESUME\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Arcade.World} This World object.\r\n   */\n  resume: function resume() {\n    this.isPaused = false;\n    this.emit(Events.RESUME);\n    return this;\n  },\n\n  /**\r\n   * Creates a new Collider object and adds it to the simulation.\r\n   *\r\n   * A Collider is a way to automatically perform collision checks between two objects,\r\n   * calling the collide and process callbacks if they occur.\r\n   *\r\n   * Colliders are run as part of the World update, after all of the Bodies have updated.\r\n   *\r\n   * By creating a Collider you don't need then call `World.collide` in your `update` loop,\r\n   * as it will be handled for you automatically.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#addCollider\r\n   * @since 3.0.0\r\n   * @see Phaser.Physics.Arcade.World#collide\r\n   *\r\n   * @param {ArcadeColliderType} object1 - The first object to check for collision.\r\n   * @param {ArcadeColliderType} object2 - The second object to check for collision.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.\r\n   * @param {*} [callbackContext] - The scope in which to call the callbacks.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n   */\n  addCollider: function addCollider(object1, object2, collideCallback, processCallback, callbackContext) {\n    if (collideCallback === undefined) {\n      collideCallback = null;\n    }\n\n    if (processCallback === undefined) {\n      processCallback = null;\n    }\n\n    if (callbackContext === undefined) {\n      callbackContext = collideCallback;\n    }\n\n    var collider = new Collider(this, false, object1, object2, collideCallback, processCallback, callbackContext);\n    this.colliders.add(collider);\n    return collider;\n  },\n\n  /**\r\n   * Creates a new Overlap Collider object and adds it to the simulation.\r\n   *\r\n   * A Collider is a way to automatically perform overlap checks between two objects,\r\n   * calling the collide and process callbacks if they occur.\r\n   *\r\n   * Colliders are run as part of the World update, after all of the Bodies have updated.\r\n   *\r\n   * By creating a Collider you don't need then call `World.overlap` in your `update` loop,\r\n   * as it will be handled for you automatically.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#addOverlap\r\n   * @since 3.0.0\r\n   *\r\n   * @param {ArcadeColliderType} object1 - The first object to check for overlap.\r\n   * @param {ArcadeColliderType} object2 - The second object to check for overlap.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects overlap.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects overlap. Must return a boolean.\r\n   * @param {*} [callbackContext] - The scope in which to call the callbacks.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n   */\n  addOverlap: function addOverlap(object1, object2, collideCallback, processCallback, callbackContext) {\n    if (collideCallback === undefined) {\n      collideCallback = null;\n    }\n\n    if (processCallback === undefined) {\n      processCallback = null;\n    }\n\n    if (callbackContext === undefined) {\n      callbackContext = collideCallback;\n    }\n\n    var collider = new Collider(this, true, object1, object2, collideCallback, processCallback, callbackContext);\n    this.colliders.add(collider);\n    return collider;\n  },\n\n  /**\r\n   * Removes a Collider from the simulation so it is no longer processed.\r\n   *\r\n   * This method does not destroy the Collider. If you wish to add it back at a later stage you can call\r\n   * `World.colliders.add(Collider)`.\r\n   *\r\n   * If you no longer need the Collider you can call the `Collider.destroy` method instead, which will\r\n   * automatically clear all of its references and then remove it from the World. If you call destroy on\r\n   * a Collider you _don't_ need to pass it to this method too.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#removeCollider\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Collider} collider - The Collider to remove from the simulation.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.World} This World object.\r\n   */\n  removeCollider: function removeCollider(collider) {\n    this.colliders.remove(collider);\n    return this;\n  },\n\n  /**\r\n   * Sets the frame rate to run the simulation at.\r\n   *\r\n   * The frame rate value is used to simulate a fixed update time step. This fixed\r\n   * time step allows for a straightforward implementation of a deterministic game state.\r\n   *\r\n   * This frame rate is independent of the frequency at which the game is rendering. The\r\n   * higher you set the fps, the more physics simulation steps will occur per game step.\r\n   * Conversely, the lower you set it, the less will take place.\r\n   *\r\n   * You can optionally advance the simulation directly yourself by calling the `step` method.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#setFPS\r\n   * @since 3.10.0\r\n   *\r\n   * @param {integer} framerate - The frame rate to advance the simulation at.\r\n   *\r\n   * @return {this} This World object.\r\n   */\n  setFPS: function setFPS(framerate) {\n    this.fps = framerate;\n    this._frameTime = 1 / this.fps;\n    this._frameTimeMS = 1000 * this._frameTime;\n    return this;\n  },\n\n  /**\r\n   * Advances the simulation based on the elapsed time and fps rate.\r\n   *\r\n   * This is called automatically by your Scene and does not need to be invoked directly.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#update\r\n   * @protected\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n   * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n   */\n  update: function update(time, delta) {\n    if (this.isPaused || this.bodies.size === 0) {\n      return;\n    }\n\n    var stepsThisFrame = 0;\n    var fixedDelta = this._frameTime;\n    var msPerFrame = this._frameTimeMS * this.timeScale;\n    this._elapsed += delta;\n    this._late = false;\n\n    while (this._elapsed >= msPerFrame) {\n      this._elapsed -= msPerFrame;\n      stepsThisFrame++;\n      this.step(fixedDelta);\n    }\n\n    this.stepsLastFrame = stepsThisFrame;\n    this._late = true;\n  },\n\n  /**\r\n   * Advances the simulation by a time increment.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#step\r\n   * @since 3.10.0\r\n   *\r\n   * @param {number} delta - The delta time amount, in seconds, by which to advance the simulation.\r\n   */\n  step: function step(delta) {\n    //  Update all active bodies\n    var i;\n    var body;\n    var bodies = this.bodies.entries;\n    var len = bodies.length;\n\n    for (i = 0; i < len; i++) {\n      body = bodies[i];\n\n      if (body.enable) {\n        body.update(delta);\n      }\n    } //  Optionally populate our dynamic collision tree\n\n\n    if (this.useTree) {\n      this.tree.clear();\n      this.tree.load(bodies);\n    } //  Process any colliders\n\n\n    var colliders = this.colliders.update();\n\n    for (i = 0; i < colliders.length; i++) {\n      var collider = colliders[i];\n\n      if (collider.active) {\n        collider.update();\n      }\n    }\n\n    len = bodies.length;\n\n    for (i = 0; i < len; i++) {\n      body = bodies[i];\n\n      if (body.enable) {\n        body.postUpdate();\n      }\n    }\n  },\n\n  /**\r\n   * Updates bodies, draws the debug display, and handles pending queue operations.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#postUpdate\r\n   * @since 3.0.0\r\n   */\n  postUpdate: function postUpdate() {\n    var i;\n    var bodies;\n    var body;\n    var len;\n    var dynamic = this.bodies;\n    var staticBodies = this.staticBodies;\n    var pending = this.pendingDestroy;\n    var late = this.late;\n\n    if (late.size > 0) {\n      bodies = late.entries;\n      len = bodies.length;\n\n      for (i = 0; i < len; i++) {\n        body = bodies[i];\n\n        if (body.enable) {\n          body.postUpdate();\n        }\n      }\n\n      late.clear();\n    }\n\n    this._late = false;\n    bodies = dynamic.entries;\n    len = bodies.length;\n\n    if (this.drawDebug) {\n      var graphics = this.debugGraphic;\n      graphics.clear();\n\n      for (i = 0; i < len; i++) {\n        body = bodies[i];\n\n        if (body.willDrawDebug()) {\n          body.drawDebug(graphics);\n        }\n      }\n\n      bodies = staticBodies.entries;\n      len = bodies.length;\n\n      for (i = 0; i < len; i++) {\n        body = bodies[i];\n\n        if (body.willDrawDebug()) {\n          body.drawDebug(graphics);\n        }\n      }\n    }\n\n    if (pending.size > 0) {\n      var dynamicTree = this.tree;\n      var staticTree = this.staticTree;\n      bodies = pending.entries;\n      len = bodies.length;\n\n      for (i = 0; i < len; i++) {\n        body = bodies[i];\n\n        if (body.physicsType === CONST.DYNAMIC_BODY) {\n          dynamicTree.remove(body);\n          dynamic.delete(body);\n          late.delete(body);\n        } else if (body.physicsType === CONST.STATIC_BODY) {\n          staticTree.remove(body);\n          staticBodies.delete(body);\n        }\n\n        body.world = undefined;\n        body.gameObject = undefined;\n      }\n\n      pending.clear();\n    }\n  },\n\n  /**\r\n   * Calculates a Body's velocity and updates its position.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#updateMotion\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Body} body - The Body to be updated.\r\n   * @param {number} delta - The delta value to be used in the motion calculations, in seconds.\r\n   */\n  updateMotion: function updateMotion(body, delta) {\n    if (body.allowRotation) {\n      this.computeAngularVelocity(body, delta);\n    }\n\n    this.computeVelocity(body, delta);\n  },\n\n  /**\r\n   * Calculates a Body's angular velocity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#computeAngularVelocity\r\n   * @since 3.10.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Body} body - The Body to compute the velocity for.\r\n   * @param {number} delta - The delta value to be used in the calculation, in seconds.\r\n   */\n  computeAngularVelocity: function computeAngularVelocity(body, delta) {\n    var velocity = body.angularVelocity;\n    var acceleration = body.angularAcceleration;\n    var drag = body.angularDrag;\n    var max = body.maxAngular;\n\n    if (acceleration) {\n      velocity += acceleration * delta;\n    } else if (body.allowDrag && drag) {\n      drag *= delta;\n\n      if (FuzzyGreaterThan(velocity - drag, 0, 0.1)) {\n        velocity -= drag;\n      } else if (FuzzyLessThan(velocity + drag, 0, 0.1)) {\n        velocity += drag;\n      } else {\n        velocity = 0;\n      }\n    }\n\n    velocity = Clamp(velocity, -max, max);\n    var velocityDelta = velocity - body.angularVelocity;\n    body.angularVelocity += velocityDelta;\n    body.rotation += body.angularVelocity * delta;\n  },\n\n  /**\r\n   * Calculates a Body's per-axis velocity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#computeVelocity\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Body} body - The Body to compute the velocity for.\r\n   * @param {number} delta - The delta value to be used in the calculation, in seconds.\r\n   */\n  computeVelocity: function computeVelocity(body, delta) {\n    var velocityX = body.velocity.x;\n    var accelerationX = body.acceleration.x;\n    var dragX = body.drag.x;\n    var maxX = body.maxVelocity.x;\n    var velocityY = body.velocity.y;\n    var accelerationY = body.acceleration.y;\n    var dragY = body.drag.y;\n    var maxY = body.maxVelocity.y;\n    var speed = body.speed;\n    var maxSpeed = body.maxSpeed;\n    var allowDrag = body.allowDrag;\n    var useDamping = body.useDamping;\n\n    if (body.allowGravity) {\n      velocityX += (this.gravity.x + body.gravity.x) * delta;\n      velocityY += (this.gravity.y + body.gravity.y) * delta;\n    }\n\n    if (accelerationX) {\n      velocityX += accelerationX * delta;\n    } else if (allowDrag && dragX) {\n      if (useDamping) {\n        //  Damping based deceleration\n        velocityX *= dragX;\n\n        if (FuzzyEqual(speed, 0, 0.001)) {\n          velocityX = 0;\n        }\n      } else {\n        //  Linear deceleration\n        dragX *= delta;\n\n        if (FuzzyGreaterThan(velocityX - dragX, 0, 0.01)) {\n          velocityX -= dragX;\n        } else if (FuzzyLessThan(velocityX + dragX, 0, 0.01)) {\n          velocityX += dragX;\n        } else {\n          velocityX = 0;\n        }\n      }\n    }\n\n    if (accelerationY) {\n      velocityY += accelerationY * delta;\n    } else if (allowDrag && dragY) {\n      if (useDamping) {\n        //  Damping based deceleration\n        velocityY *= dragY;\n\n        if (FuzzyEqual(speed, 0, 0.001)) {\n          velocityY = 0;\n        }\n      } else {\n        //  Linear deceleration\n        dragY *= delta;\n\n        if (FuzzyGreaterThan(velocityY - dragY, 0, 0.01)) {\n          velocityY -= dragY;\n        } else if (FuzzyLessThan(velocityY + dragY, 0, 0.01)) {\n          velocityY += dragY;\n        } else {\n          velocityY = 0;\n        }\n      }\n    }\n\n    velocityX = Clamp(velocityX, -maxX, maxX);\n    velocityY = Clamp(velocityY, -maxY, maxY);\n    body.velocity.set(velocityX, velocityY);\n\n    if (maxSpeed > -1 && body.velocity.length() > maxSpeed) {\n      body.velocity.normalize().scale(maxSpeed);\n    }\n  },\n\n  /**\r\n   * Separates two Bodies.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#separate\r\n   * @fires Phaser.Physics.Arcade.Events#COLLIDE\r\n   * @fires Phaser.Physics.Arcade.Events#OVERLAP\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to be separated.\r\n   * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to be separated.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - The process callback.\r\n   * @param {*} [callbackContext] - The context in which to invoke the callback.\r\n   * @param {boolean} [overlapOnly] - If this a collide or overlap check?\r\n   *\r\n   * @return {boolean} True if separation occurred, otherwise false.\r\n   */\n  separate: function separate(body1, body2, processCallback, callbackContext, overlapOnly) {\n    if (!body1.enable || !body2.enable || body1.checkCollision.none || body2.checkCollision.none || !this.intersects(body1, body2)) {\n      return false;\n    } //  They overlap. Is there a custom process callback? If it returns true then we can carry on, otherwise we should abort.\n\n\n    if (processCallback && processCallback.call(callbackContext, body1.gameObject, body2.gameObject) === false) {\n      return false;\n    } //  Circle vs. Circle quick bail out\n\n\n    if (body1.isCircle && body2.isCircle) {\n      return this.separateCircle(body1, body2, overlapOnly);\n    } // We define the behavior of bodies in a collision circle and rectangle\n    // If a collision occurs in the corner points of the rectangle, the body behave like circles\n    //  Either body1 or body2 is a circle\n\n\n    if (body1.isCircle !== body2.isCircle) {\n      var bodyRect = body1.isCircle ? body2 : body1;\n      var bodyCircle = body1.isCircle ? body1 : body2;\n      var rect = {\n        x: bodyRect.x,\n        y: bodyRect.y,\n        right: bodyRect.right,\n        bottom: bodyRect.bottom\n      };\n      var circle = bodyCircle.center;\n\n      if (circle.y < rect.y || circle.y > rect.bottom) {\n        if (circle.x < rect.x || circle.x > rect.right) {\n          return this.separateCircle(body1, body2, overlapOnly);\n        }\n      }\n    }\n\n    var resultX = false;\n    var resultY = false; //  Do we separate on x or y first?\n\n    if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x)) {\n      resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS); //  Are they still intersecting? Let's do the other axis then\n\n      if (this.intersects(body1, body2)) {\n        resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);\n      }\n    } else {\n      resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS); //  Are they still intersecting? Let's do the other axis then\n\n      if (this.intersects(body1, body2)) {\n        resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);\n      }\n    }\n\n    var result = resultX || resultY;\n\n    if (result) {\n      if (overlapOnly) {\n        if (body1.onOverlap || body2.onOverlap) {\n          this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);\n        }\n      } else {\n        if (this._late) {\n          this.late.set(body1);\n          this.late.set(body2);\n        }\n\n        if (body1.onCollide || body2.onCollide) {\n          this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);\n        }\n      }\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Separates two Bodies, when both are circular.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#separateCircle\r\n   * @fires Phaser.Physics.Arcade.Events#COLLIDE\r\n   * @fires Phaser.Physics.Arcade.Events#OVERLAP\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to be separated.\r\n   * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to be separated.\r\n   * @param {boolean} [overlapOnly] - If this a collide or overlap check?\r\n   * @param {number} [bias] - A small value added to the calculations.\r\n   *\r\n   * @return {boolean} True if separation occurred, otherwise false.\r\n   */\n  separateCircle: function separateCircle(body1, body2, overlapOnly, bias) {\n    //  Set the bounding box overlap values into the bodies themselves (hence we don't use the return values here)\n    GetOverlapX(body1, body2, false, bias);\n    GetOverlapY(body1, body2, false, bias);\n    var dx = body2.center.x - body1.center.x;\n    var dy = body2.center.y - body1.center.y;\n    var angleCollision = Math.atan2(dy, dx);\n    var overlap = 0;\n\n    if (body1.isCircle !== body2.isCircle) {\n      var rect = {\n        x: body2.isCircle ? body1.position.x : body2.position.x,\n        y: body2.isCircle ? body1.position.y : body2.position.y,\n        right: body2.isCircle ? body1.right : body2.right,\n        bottom: body2.isCircle ? body1.bottom : body2.bottom\n      };\n      var circle = {\n        x: body1.isCircle ? body1.center.x : body2.center.x,\n        y: body1.isCircle ? body1.center.y : body2.center.y,\n        radius: body1.isCircle ? body1.halfWidth : body2.halfWidth\n      };\n\n      if (circle.y < rect.y) {\n        if (circle.x < rect.x) {\n          overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.y) - circle.radius;\n        } else if (circle.x > rect.right) {\n          overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.y) - circle.radius;\n        }\n      } else if (circle.y > rect.bottom) {\n        if (circle.x < rect.x) {\n          overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.bottom) - circle.radius;\n        } else if (circle.x > rect.right) {\n          overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.bottom) - circle.radius;\n        }\n      }\n\n      overlap *= -1;\n    } else {\n      overlap = body1.halfWidth + body2.halfWidth - DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y);\n    } //  Can't separate two immovable bodies, or a body with its own custom separation logic\n\n\n    if (overlapOnly || overlap === 0 || body1.immovable && body2.immovable || body1.customSeparateX || body2.customSeparateX) {\n      if (overlap !== 0 && (body1.onOverlap || body2.onOverlap)) {\n        this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);\n      } //  return true if there was some overlap, otherwise false\n\n\n      return overlap !== 0;\n    } // Transform the velocity vector to the coordinate system oriented along the direction of impact.\n    // This is done to eliminate the vertical component of the velocity\n\n\n    var b1vx = body1.velocity.x;\n    var b1vy = body1.velocity.y;\n    var b1mass = body1.mass;\n    var b2vx = body2.velocity.x;\n    var b2vy = body2.velocity.y;\n    var b2mass = body2.mass;\n    var v1 = {\n      x: b1vx * Math.cos(angleCollision) + b1vy * Math.sin(angleCollision),\n      y: b1vx * Math.sin(angleCollision) - b1vy * Math.cos(angleCollision)\n    };\n    var v2 = {\n      x: b2vx * Math.cos(angleCollision) + b2vy * Math.sin(angleCollision),\n      y: b2vx * Math.sin(angleCollision) - b2vy * Math.cos(angleCollision)\n    }; // We expect the new velocity after impact\n\n    var tempVel1 = ((b1mass - b2mass) * v1.x + 2 * b2mass * v2.x) / (b1mass + b2mass);\n    var tempVel2 = (2 * b1mass * v1.x + (b2mass - b1mass) * v2.x) / (b1mass + b2mass); // We convert the vector to the original coordinate system and multiplied by factor of rebound\n\n    if (!body1.immovable) {\n      body1.velocity.x = (tempVel1 * Math.cos(angleCollision) - v1.y * Math.sin(angleCollision)) * body1.bounce.x;\n      body1.velocity.y = (v1.y * Math.cos(angleCollision) + tempVel1 * Math.sin(angleCollision)) * body1.bounce.y; //  Reset local var\n\n      b1vx = body1.velocity.x;\n      b1vy = body1.velocity.y;\n    }\n\n    if (!body2.immovable) {\n      body2.velocity.x = (tempVel2 * Math.cos(angleCollision) - v2.y * Math.sin(angleCollision)) * body2.bounce.x;\n      body2.velocity.y = (v2.y * Math.cos(angleCollision) + tempVel2 * Math.sin(angleCollision)) * body2.bounce.y; //  Reset local var\n\n      b2vx = body2.velocity.x;\n      b2vy = body2.velocity.y;\n    } // When the collision angle is almost perpendicular to the total initial velocity vector\n    // (collision on a tangent) vector direction can be determined incorrectly.\n    // This code fixes the problem\n\n\n    if (Math.abs(angleCollision) < Math.PI / 2) {\n      if (b1vx > 0 && !body1.immovable && b2vx > b1vx) {\n        body1.velocity.x *= -1;\n      } else if (b2vx < 0 && !body2.immovable && b1vx < b2vx) {\n        body2.velocity.x *= -1;\n      } else if (b1vy > 0 && !body1.immovable && b2vy > b1vy) {\n        body1.velocity.y *= -1;\n      } else if (b2vy < 0 && !body2.immovable && b1vy < b2vy) {\n        body2.velocity.y *= -1;\n      }\n    } else if (Math.abs(angleCollision) > Math.PI / 2) {\n      if (b1vx < 0 && !body1.immovable && b2vx < b1vx) {\n        body1.velocity.x *= -1;\n      } else if (b2vx > 0 && !body2.immovable && b1vx > b2vx) {\n        body2.velocity.x *= -1;\n      } else if (b1vy < 0 && !body1.immovable && b2vy < b1vy) {\n        body1.velocity.y *= -1;\n      } else if (b2vy > 0 && !body2.immovable && b1vx > b2vy) {\n        body2.velocity.y *= -1;\n      }\n    }\n\n    var delta = this._frameTime;\n\n    if (!body1.immovable) {\n      body1.x += body1.velocity.x * delta - overlap * Math.cos(angleCollision);\n      body1.y += body1.velocity.y * delta - overlap * Math.sin(angleCollision);\n    }\n\n    if (!body2.immovable) {\n      body2.x += body2.velocity.x * delta + overlap * Math.cos(angleCollision);\n      body2.y += body2.velocity.y * delta + overlap * Math.sin(angleCollision);\n    }\n\n    if (body1.onCollide || body2.onCollide) {\n      this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);\n    } //  sync changes back to the bodies\n\n\n    body1.postUpdate();\n    body2.postUpdate();\n    return true;\n  },\n\n  /**\r\n   * Checks to see if two Bodies intersect at all.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#intersects\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Body} body1 - The first body to check.\r\n   * @param {Phaser.Physics.Arcade.Body} body2 - The second body to check.\r\n   *\r\n   * @return {boolean} True if the two bodies intersect, otherwise false.\r\n   */\n  intersects: function intersects(body1, body2) {\n    if (body1 === body2) {\n      return false;\n    }\n\n    if (!body1.isCircle && !body2.isCircle) {\n      //  Rect vs. Rect\n      return !(body1.right <= body2.position.x || body1.bottom <= body2.position.y || body1.position.x >= body2.right || body1.position.y >= body2.bottom);\n    } else if (body1.isCircle) {\n      if (body2.isCircle) {\n        //  Circle vs. Circle\n        return DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y) <= body1.halfWidth + body2.halfWidth;\n      } else {\n        //  Circle vs. Rect\n        return this.circleBodyIntersects(body1, body2);\n      }\n    } else {\n      //  Rect vs. Circle\n      return this.circleBodyIntersects(body2, body1);\n    }\n  },\n\n  /**\r\n   * Tests if a circular Body intersects with another Body.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#circleBodyIntersects\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Body} circle - The circular body to test.\r\n   * @param {Phaser.Physics.Arcade.Body} body - The rectangular body to test.\r\n   *\r\n   * @return {boolean} True if the two bodies intersect, otherwise false.\r\n   */\n  circleBodyIntersects: function circleBodyIntersects(circle, body) {\n    var x = Clamp(circle.center.x, body.left, body.right);\n    var y = Clamp(circle.center.y, body.top, body.bottom);\n    var dx = (circle.center.x - x) * (circle.center.x - x);\n    var dy = (circle.center.y - y) * (circle.center.y - y);\n    return dx + dy <= circle.halfWidth * circle.halfWidth;\n  },\n\n  /**\r\n   * Tests if Game Objects overlap.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#overlap\r\n   * @since 3.0.0\r\n   *\r\n   * @param {ArcadeColliderType} object1 - The first object or array of objects to check.\r\n   * @param {ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n   * @param {ArcadePhysicsCallback} [overlapCallback] - An optional callback function that is called if the objects overlap.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `overlapCallback` will only be called if this callback returns `true`.\r\n   * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n   *\r\n   * @return {boolean} True if at least one Game Object overlaps another.\r\n   */\n  overlap: function overlap(object1, object2, overlapCallback, processCallback, callbackContext) {\n    if (overlapCallback === undefined) {\n      overlapCallback = null;\n    }\n\n    if (processCallback === undefined) {\n      processCallback = null;\n    }\n\n    if (callbackContext === undefined) {\n      callbackContext = overlapCallback;\n    }\n\n    return this.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);\n  },\n\n  /**\r\n   * Performs a collision check and separation between the two physics enabled objects given, which can be single\r\n   * Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups.\r\n   *\r\n   * If you don't require separation then use {@link #overlap} instead.\r\n   *\r\n   * If two Groups or arrays are passed, each member of one will be tested against each member of the other.\r\n   *\r\n   * If one Group **only** is passed (as `object1`), each member of the Group will be collided against the other members.\r\n   *\r\n   * Two callbacks can be provided. The `collideCallback` is invoked if a collision occurs and the two colliding\r\n   * objects are passed to it.\r\n   *\r\n   * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\r\n   * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\r\n   * The separation that stops two objects penetrating may create a new penetration against a different object. If you\r\n   * require a high level of stability please consider using an alternative physics system, such as Matter.js.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collide\r\n   * @since 3.0.0\r\n   *\r\n   * @param {ArcadeColliderType} object1 - The first object or array of objects to check.\r\n   * @param {ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n   *\r\n   * @return {boolean} `true` if any overlapping Game Objects were separated, otherwise `false`.\r\n   */\n  collide: function collide(object1, object2, collideCallback, processCallback, callbackContext) {\n    if (collideCallback === undefined) {\n      collideCallback = null;\n    }\n\n    if (processCallback === undefined) {\n      processCallback = null;\n    }\n\n    if (callbackContext === undefined) {\n      callbackContext = collideCallback;\n    }\n\n    return this.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);\n  },\n\n  /**\r\n   * Internal helper function. Please use Phaser.Physics.Arcade.World#collide instead.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideObjects\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {ArcadeColliderType} object1 - The first object to check for collision.\r\n   * @param {ArcadeColliderType} object2 - The second object to check for collision.\r\n   * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.\r\n   * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.\r\n   * @param {any} callbackContext - The scope in which to call the callbacks.\r\n   * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  collideObjects: function collideObjects(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {\n    var i;\n\n    if (object1.isParent && object1.physicsType === undefined) {\n      object1 = object1.children.entries;\n    }\n\n    if (object2 && object2.isParent && object2.physicsType === undefined) {\n      object2 = object2.children.entries;\n    }\n\n    var object1isArray = Array.isArray(object1);\n    var object2isArray = Array.isArray(object2);\n    this._total = 0;\n\n    if (!object1isArray && !object2isArray) {\n      //  Neither of them are arrays - do this first as it's the most common use-case\n      this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n    } else if (!object1isArray && object2isArray) {\n      //  Object 2 is an Array\n      for (i = 0; i < object2.length; i++) {\n        this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, overlapOnly);\n      }\n    } else if (object1isArray && !object2isArray) {\n      //  Object 1 is an Array\n      for (i = 0; i < object1.length; i++) {\n        this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, overlapOnly);\n      }\n    } else {\n      //  They're both arrays\n      for (i = 0; i < object1.length; i++) {\n        for (var j = 0; j < object2.length; j++) {\n          this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, overlapOnly);\n        }\n      }\n    }\n\n    return this._total > 0;\n  },\n\n  /**\r\n   * Internal helper function. Please use Phaser.Physics.Arcade.World#collide and Phaser.Physics.Arcade.World#overlap instead.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideHandler\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {ArcadeColliderType} object1 - The first object or array of objects to check.\r\n   * @param {ArcadeColliderType} object2 - The second object or array of objects to check, or `undefined`.\r\n   * @param {ArcadePhysicsCallback} collideCallback - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} processCallback - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} callbackContext - The context in which to run the callbacks.\r\n   * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  collideHandler: function collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {\n    //  Collide Group with Self\n    //  Only collide valid objects\n    if (object2 === undefined && object1.isParent) {\n      return this.collideGroupVsGroup(object1, object1, collideCallback, processCallback, callbackContext, overlapOnly);\n    } //  If neither of the objects are set then bail out\n\n\n    if (!object1 || !object2) {\n      return false;\n    } //  A Body\n\n\n    if (object1.body) {\n      if (object2.body) {\n        return this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n      } else if (object2.isParent) {\n        return this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n      } else if (object2.isTilemap) {\n        return this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n      }\n    } //  GROUPS\n    else if (object1.isParent) {\n        if (object2.body) {\n          return this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\n        } else if (object2.isParent) {\n          return this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n        } else if (object2.isTilemap) {\n          return this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n        }\n      } //  TILEMAP LAYERS\n      else if (object1.isTilemap) {\n          if (object2.body) {\n            return this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\n          } else if (object2.isParent) {\n            return this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\n          }\n        }\n  },\n\n  /**\r\n   * Internal handler for Sprite vs. Sprite collisions.\r\n   * Please use Phaser.Physics.Arcade.World#collide instead.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideSpriteVsSprite\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} sprite1 - The first object to check for collision.\r\n   * @param {Phaser.GameObjects.GameObject} sprite2 - The second object to check for collision.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n   * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  collideSpriteVsSprite: function collideSpriteVsSprite(sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {\n    if (!sprite1.body || !sprite2.body) {\n      return false;\n    }\n\n    if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly)) {\n      if (collideCallback) {\n        collideCallback.call(callbackContext, sprite1, sprite2);\n      }\n\n      this._total++;\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Internal handler for Sprite vs. Group collisions.\r\n   * Please use Phaser.Physics.Arcade.World#collide instead.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideSpriteVsGroup\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n   * @param {Phaser.GameObjects.Group} group - The second object to check for collision.\r\n   * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.\r\n   * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.\r\n   * @param {any} callbackContext - The scope in which to call the callbacks.\r\n   * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n   *\r\n   * @return {boolean} `true` if the Sprite collided with the given Group, otherwise `false`.\r\n   */\n  collideSpriteVsGroup: function collideSpriteVsGroup(sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {\n    var bodyA = sprite.body;\n\n    if (group.length === 0 || !bodyA || !bodyA.enable) {\n      return;\n    } //  Does sprite collide with anything?\n\n\n    var i;\n    var len;\n    var bodyB;\n\n    if (this.useTree) {\n      var minMax = this.treeMinMax;\n      minMax.minX = bodyA.left;\n      minMax.minY = bodyA.top;\n      minMax.maxX = bodyA.right;\n      minMax.maxY = bodyA.bottom;\n      var results = group.physicsType === CONST.DYNAMIC_BODY ? this.tree.search(minMax) : this.staticTree.search(minMax);\n      len = results.length;\n\n      for (i = 0; i < len; i++) {\n        bodyB = results[i];\n\n        if (bodyA === bodyB || !group.contains(bodyB.gameObject)) {\n          //  Skip if comparing against itself, or if bodyB isn't actually part of the Group\n          continue;\n        }\n\n        if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly)) {\n          if (collideCallback) {\n            collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);\n          }\n\n          this._total++;\n        }\n      }\n    } else {\n      var children = group.getChildren();\n      var skipIndex = group.children.entries.indexOf(sprite);\n      len = children.length;\n\n      for (i = 0; i < len; i++) {\n        bodyB = children[i].body;\n\n        if (!bodyB || i === skipIndex || !bodyB.enable) {\n          continue;\n        }\n\n        if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly)) {\n          if (collideCallback) {\n            collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);\n          }\n\n          this._total++;\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Internal handler for Group vs. Tilemap collisions.\r\n   * Please use Phaser.Physics.Arcade.World#collide instead.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideGroupVsTilemapLayer\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Group} group - The first object to check for collision.\r\n   * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The second object to check for collision.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n   * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  collideGroupVsTilemapLayer: function collideGroupVsTilemapLayer(group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {\n    var children = group.getChildren();\n\n    if (children.length === 0) {\n      return false;\n    }\n\n    var didCollide = false;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].body) {\n        if (this.collideSpriteVsTilemapLayer(children[i], tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)) {\n          didCollide = true;\n        }\n      }\n    }\n\n    return didCollide;\n  },\n\n  /**\r\n   * Internal handler for Sprite vs. Tilemap collisions.\r\n   * Please use Phaser.Physics.Arcade.World#collide instead.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideSpriteVsTilemapLayer\r\n   * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\r\n   * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n   * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The second object to check for collision.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n   * @param {boolean} [overlapOnly] - Whether this is a collision or overlap check.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  collideSpriteVsTilemapLayer: function collideSpriteVsTilemapLayer(sprite, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {\n    var body = sprite.body;\n\n    if (!body.enable) {\n      return false;\n    }\n\n    var x = body.position.x;\n    var y = body.position.y;\n    var w = body.width;\n    var h = body.height; // TODO: this logic should be encapsulated within the Tilemap API at some point.\n    // If the maps base tile size differs from the layer's tile size, we need to adjust the\n    // selection area by the difference between the two.\n\n    var layerData = tilemapLayer.layer;\n\n    if (layerData.tileWidth > layerData.baseTileWidth) {\n      // The x origin of a tile is the left side, so x and width need to be adjusted.\n      var xDiff = (layerData.tileWidth - layerData.baseTileWidth) * tilemapLayer.scaleX;\n      x -= xDiff;\n      w += xDiff;\n    }\n\n    if (layerData.tileHeight > layerData.baseTileHeight) {\n      // The y origin of a tile is the bottom side, so just the height needs to be adjusted.\n      var yDiff = (layerData.tileHeight - layerData.baseTileHeight) * tilemapLayer.scaleY;\n      h += yDiff;\n    }\n\n    var mapData = tilemapLayer.getTilesWithinWorldXY(x, y, w, h);\n\n    if (mapData.length === 0) {\n      return false;\n    }\n\n    var tile;\n    var tileWorldRect = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n\n    for (var i = 0; i < mapData.length; i++) {\n      tile = mapData[i];\n      tileWorldRect.left = tilemapLayer.tileToWorldX(tile.x);\n      tileWorldRect.top = tilemapLayer.tileToWorldY(tile.y); // If the map's base tile size differs from the layer's tile size, only the top of the rect\n      // needs to be adjusted since its origin is (0, 1).\n\n      if (tile.baseHeight !== tile.height) {\n        tileWorldRect.top -= (tile.height - tile.baseHeight) * tilemapLayer.scaleY;\n      }\n\n      tileWorldRect.right = tileWorldRect.left + tile.width * tilemapLayer.scaleX;\n      tileWorldRect.bottom = tileWorldRect.top + tile.height * tilemapLayer.scaleY;\n\n      if (TileIntersectsBody(tileWorldRect, body) && (!processCallback || processCallback.call(callbackContext, sprite, tile)) && ProcessTileCallbacks(tile, sprite) && (overlapOnly || SeparateTile(i, body, tile, tileWorldRect, tilemapLayer, this.TILE_BIAS))) {\n        this._total++;\n\n        if (collideCallback) {\n          collideCallback.call(callbackContext, sprite, tile);\n        }\n\n        if (overlapOnly && body.onOverlap) {\n          this.emit(Events.TILE_OVERLAP, body.gameObject, tile, body);\n        } else if (body.onCollide) {\n          this.emit(Events.TILE_COLLIDE, body.gameObject, tile, body);\n        } //  sync changes back to the body\n\n\n        body.postUpdate();\n      }\n    }\n  },\n\n  /**\r\n   * Internal helper for Group vs. Group collisions.\r\n   * Please use Phaser.Physics.Arcade.World#collide instead.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideGroupVsGroup\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Group} group1 - The first object to check for collision.\r\n   * @param {Phaser.GameObjects.Group} group2 - The second object to check for collision.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n   * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  collideGroupVsGroup: function collideGroupVsGroup(group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {\n    if (group1.length === 0 || group2.length === 0) {\n      return;\n    }\n\n    var children = group1.getChildren();\n\n    for (var i = 0; i < children.length; i++) {\n      this.collideSpriteVsGroup(children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);\n    }\n  },\n\n  /**\r\n   * Wrap an object's coordinates (or several objects' coordinates) within {@link Phaser.Physics.Arcade.World#bounds}.\r\n   *\r\n   * If the object is outside any boundary edge (left, top, right, bottom), it will be moved to the same offset from the opposite edge (the interior).\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#wrap\r\n   * @since 3.3.0\r\n   *\r\n   * @param {*} object - A Game Object, a Group, an object with `x` and `y` coordinates, or an array of such objects.\r\n   * @param {number} [padding=0] - An amount added to each boundary edge during the operation.\r\n   */\n  wrap: function wrap(object, padding) {\n    if (object.body) {\n      this.wrapObject(object, padding);\n    } else if (object.getChildren) {\n      this.wrapArray(object.getChildren(), padding);\n    } else if (Array.isArray(object)) {\n      this.wrapArray(object, padding);\n    } else {\n      this.wrapObject(object, padding);\n    }\n  },\n\n  /**\r\n   * Wrap each object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#wrapArray\r\n   * @since 3.3.0\r\n   *\r\n   * @param {Array.<*>} objects - An array of objects to be wrapped.\r\n   * @param {number} [padding=0] - An amount added to the boundary.\r\n   */\n  wrapArray: function wrapArray(objects, padding) {\n    for (var i = 0; i < objects.length; i++) {\n      this.wrapObject(objects[i], padding);\n    }\n  },\n\n  /**\r\n   * Wrap an object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#wrapObject\r\n   * @since 3.3.0\r\n   *\r\n   * @param {*} object - A Game Object, a Physics Body, or any object with `x` and `y` coordinates\r\n   * @param {number} [padding=0] - An amount added to the boundary.\r\n   */\n  wrapObject: function wrapObject(object, padding) {\n    if (padding === undefined) {\n      padding = 0;\n    }\n\n    object.x = Wrap(object.x, this.bounds.left - padding, this.bounds.right + padding);\n    object.y = Wrap(object.y, this.bounds.top - padding, this.bounds.bottom + padding);\n  },\n\n  /**\r\n   * Shuts down the simulation, clearing physics data and removing listeners.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#shutdown\r\n   * @since 3.0.0\r\n   */\n  shutdown: function shutdown() {\n    this.tree.clear();\n    this.staticTree.clear();\n    this.bodies.clear();\n    this.staticBodies.clear();\n    this.late.clear();\n    this.colliders.destroy();\n    this.removeAllListeners();\n  },\n\n  /**\r\n   * Shuts down the simulation and disconnects it from the current scene.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    this.shutdown();\n    this.scene = null;\n  }\n});\nmodule.exports = World;","map":null,"metadata":{},"sourceType":"script"}