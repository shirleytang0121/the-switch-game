{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\n//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\nfunction hasGetterOrSetter(def) {\n  return !!def.get && typeof def.get === 'function' || !!def.set && typeof def.set === 'function';\n}\n\nfunction getProperty(definition, k, isClassDescriptor) {\n  //  This may be a lightweight object, OR it might be a property that was defined previously.\n  //  For simple class descriptors we can just assume its NOT previously defined.\n  var def = isClassDescriptor ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\n\n  if (!isClassDescriptor && def.value && typeof def.value === 'object') {\n    def = def.value;\n  } //  This might be a regular property, or it may be a getter/setter the user defined in a class.\n\n\n  if (def && hasGetterOrSetter(def)) {\n    if (typeof def.enumerable === 'undefined') {\n      def.enumerable = true;\n    }\n\n    if (typeof def.configurable === 'undefined') {\n      def.configurable = true;\n    }\n\n    return def;\n  } else {\n    return false;\n  }\n}\n\nfunction hasNonConfigurable(obj, k) {\n  var prop = Object.getOwnPropertyDescriptor(obj, k);\n\n  if (!prop) {\n    return false;\n  }\n\n  if (prop.value && typeof prop.value === 'object') {\n    prop = prop.value;\n  }\n\n  if (prop.configurable === false) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction extend(ctor, definition, isClassDescriptor, extend) {\n  for (var k in definition) {\n    if (!definition.hasOwnProperty(k)) {\n      continue;\n    }\n\n    var def = getProperty(definition, k, isClassDescriptor);\n\n    if (def !== false) {\n      //  If Extends is used, we will check its prototype to see if the final variable exists.\n      var parent = extend || ctor;\n\n      if (hasNonConfigurable(parent.prototype, k)) {\n        //  Just skip the final property\n        if (Class.ignoreFinals) {\n          continue;\n        } //  We cannot re-define a property that is configurable=false.\n        //  So we will consider them final and throw an error. This is by\n        //  default so it is clear to the developer what is happening.\n        //  You can set ignoreFinals to true if you need to extend a class\n        //  which has configurable=false; it will simply not re-define final properties.\n\n\n        throw new Error('cannot override final property \\'' + k + '\\', set Class.ignoreFinals = true to skip');\n      }\n\n      Object.defineProperty(ctor.prototype, k, def);\n    } else {\n      ctor.prototype[k] = definition[k];\n    }\n  }\n}\n\nfunction mixin(myClass, mixins) {\n  if (!mixins) {\n    return;\n  }\n\n  if (!Array.isArray(mixins)) {\n    mixins = [mixins];\n  }\n\n  for (var i = 0; i < mixins.length; i++) {\n    extend(myClass, mixins[i].prototype || mixins[i]);\n  }\n}\n/**\r\n * Creates a new class with the given descriptor.\r\n * The constructor, defined by the name `initialize`,\r\n * is an optional function. If unspecified, an anonymous\r\n * function will be used which calls the parent class (if\r\n * one exists).\r\n *\r\n * You can also use `Extends` and `Mixins` to provide subclassing\r\n * and inheritance.\r\n *\r\n * @class  Class\r\n * @constructor\r\n * @param {Object} definition a dictionary of functions for the class\r\n * @example\r\n *\r\n *      var MyClass = new Phaser.Class({\r\n *\r\n *          initialize: function() {\r\n *              this.foo = 2.0;\r\n *          },\r\n *\r\n *          bar: function() {\r\n *              return this.foo + 5;\r\n *          }\r\n *      });\r\n */\n\n\nfunction Class(definition) {\n  if (!definition) {\n    definition = {};\n  } //  The variable name here dictates what we see in Chrome debugger\n\n\n  var initialize;\n  var Extends;\n\n  if (definition.initialize) {\n    if (typeof definition.initialize !== 'function') {\n      throw new Error('initialize must be a function');\n    }\n\n    initialize = definition.initialize; //  Usually we should avoid 'delete' in V8 at all costs.\n    //  However, its unlikely to make any performance difference\n    //  here since we only call this on class creation (i.e. not object creation).\n\n    delete definition.initialize;\n  } else if (definition.Extends) {\n    var base = definition.Extends;\n\n    initialize = function initialize() {\n      base.apply(this, arguments);\n    };\n  } else {\n    initialize = function initialize() {};\n  }\n\n  if (definition.Extends) {\n    initialize.prototype = Object.create(definition.Extends.prototype);\n    initialize.prototype.constructor = initialize; //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\n\n    Extends = definition.Extends;\n    delete definition.Extends;\n  } else {\n    initialize.prototype.constructor = initialize;\n  } //  Grab the mixins, if they are specified...\n\n\n  var mixins = null;\n\n  if (definition.Mixins) {\n    mixins = definition.Mixins;\n    delete definition.Mixins;\n  } //  First, mixin if we can.\n\n\n  mixin(initialize, mixins); //  Now we grab the actual definition which defines the overrides.\n\n  extend(initialize, definition, true, Extends);\n  return initialize;\n}\n\nClass.extend = extend;\nClass.mixin = mixin;\nClass.ignoreFinals = false;\nmodule.exports = Class;","map":null,"metadata":{},"sourceType":"script"}