{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar DefaultDefs = require('./DefaultDefs');\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class CollisionMap\r\n * @memberof Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [tilesize=32] - [description]\r\n * @param {array} [data] - [description]\r\n */\n\n\nvar CollisionMap = new Class({\n  initialize: function CollisionMap(tilesize, data) {\n    if (tilesize === undefined) {\n      tilesize = 32;\n    }\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.CollisionMap#tilesize\r\n     * @type {integer}\r\n     * @default 32\r\n     * @since 3.0.0\r\n     */\n\n\n    this.tilesize = tilesize;\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.CollisionMap#data\r\n     * @type {array}\r\n     * @since 3.0.0\r\n     */\n\n    this.data = Array.isArray(data) ? data : [];\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.CollisionMap#width\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.width = Array.isArray(data) ? data[0].length : 0;\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.CollisionMap#height\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.height = Array.isArray(data) ? data.length : 0;\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.CollisionMap#lastSlope\r\n     * @type {integer}\r\n     * @default 55\r\n     * @since 3.0.0\r\n     */\n\n    this.lastSlope = 55;\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.CollisionMap#tiledef\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.tiledef = DefaultDefs;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.CollisionMap#trace\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   * @param {number} vx - [description]\r\n   * @param {number} vy - [description]\r\n   * @param {number} objectWidth - [description]\r\n   * @param {number} objectHeight - [description]\r\n   *\r\n   * @return {boolean} [description]\r\n   */\n  trace: function trace(x, y, vx, vy, objectWidth, objectHeight) {\n    // Set up the trace-result\n    var res = {\n      collision: {\n        x: false,\n        y: false,\n        slope: false\n      },\n      pos: {\n        x: x + vx,\n        y: y + vy\n      },\n      tile: {\n        x: 0,\n        y: 0\n      }\n    };\n\n    if (!this.data) {\n      return res;\n    }\n\n    var steps = Math.ceil(Math.max(Math.abs(vx), Math.abs(vy)) / this.tilesize);\n\n    if (steps > 1) {\n      var sx = vx / steps;\n      var sy = vy / steps;\n\n      for (var i = 0; i < steps && (sx || sy); i++) {\n        this.step(res, x, y, sx, sy, objectWidth, objectHeight, vx, vy, i);\n        x = res.pos.x;\n        y = res.pos.y;\n\n        if (res.collision.x) {\n          sx = 0;\n          vx = 0;\n        }\n\n        if (res.collision.y) {\n          sy = 0;\n          vy = 0;\n        }\n\n        if (res.collision.slope) {\n          break;\n        }\n      }\n    } else {\n      this.step(res, x, y, vx, vy, objectWidth, objectHeight, vx, vy, 0);\n    }\n\n    return res;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.CollisionMap#step\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} res - [description]\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   * @param {number} vx - [description]\r\n   * @param {number} vy - [description]\r\n   * @param {number} width - [description]\r\n   * @param {number} height - [description]\r\n   * @param {number} rvx - [description]\r\n   * @param {number} rvy - [description]\r\n   * @param {number} step - [description]\r\n   */\n  step: function step(res, x, y, vx, vy, width, height, rvx, rvy, _step) {\n    var t = 0;\n    var tileX;\n    var tileY;\n    var tilesize = this.tilesize;\n    var mapWidth = this.width;\n    var mapHeight = this.height; //  Horizontal\n\n    if (vx) {\n      var pxOffsetX = vx > 0 ? width : 0;\n      var tileOffsetX = vx < 0 ? tilesize : 0;\n      var firstTileY = Math.max(Math.floor(y / tilesize), 0);\n      var lastTileY = Math.min(Math.ceil((y + height) / tilesize), mapHeight);\n      tileX = Math.floor((res.pos.x + pxOffsetX) / tilesize);\n      var prevTileX = Math.floor((x + pxOffsetX) / tilesize);\n\n      if (_step > 0 || tileX === prevTileX || prevTileX < 0 || prevTileX >= mapWidth) {\n        prevTileX = -1;\n      }\n\n      if (tileX >= 0 && tileX < mapWidth) {\n        for (tileY = firstTileY; tileY < lastTileY; tileY++) {\n          if (prevTileX !== -1) {\n            t = this.data[tileY][prevTileX];\n\n            if (t > 1 && t <= this.lastSlope && this.checkDef(res, t, x, y, rvx, rvy, width, height, prevTileX, tileY)) {\n              break;\n            }\n          }\n\n          t = this.data[tileY][tileX];\n\n          if (t === 1 || t > this.lastSlope || t > 1 && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, tileY)) {\n            if (t > 1 && t <= this.lastSlope && res.collision.slope) {\n              break;\n            }\n\n            res.collision.x = true;\n            res.tile.x = t;\n            res.pos.x = tileX * tilesize - pxOffsetX + tileOffsetX;\n            x = res.pos.x;\n            rvx = 0;\n            break;\n          }\n        }\n      }\n    } //  Vertical\n\n\n    if (vy) {\n      var pxOffsetY = vy > 0 ? height : 0;\n      var tileOffsetY = vy < 0 ? tilesize : 0;\n      var firstTileX = Math.max(Math.floor(res.pos.x / tilesize), 0);\n      var lastTileX = Math.min(Math.ceil((res.pos.x + width) / tilesize), mapWidth);\n      tileY = Math.floor((res.pos.y + pxOffsetY) / tilesize);\n      var prevTileY = Math.floor((y + pxOffsetY) / tilesize);\n\n      if (_step > 0 || tileY === prevTileY || prevTileY < 0 || prevTileY >= mapHeight) {\n        prevTileY = -1;\n      }\n\n      if (tileY >= 0 && tileY < mapHeight) {\n        for (tileX = firstTileX; tileX < lastTileX; tileX++) {\n          if (prevTileY !== -1) {\n            t = this.data[prevTileY][tileX];\n\n            if (t > 1 && t <= this.lastSlope && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, prevTileY)) {\n              break;\n            }\n          }\n\n          t = this.data[tileY][tileX];\n\n          if (t === 1 || t > this.lastSlope || t > 1 && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, tileY)) {\n            if (t > 1 && t <= this.lastSlope && res.collision.slope) {\n              break;\n            }\n\n            res.collision.y = true;\n            res.tile.y = t;\n            res.pos.y = tileY * tilesize - pxOffsetY + tileOffsetY;\n            break;\n          }\n        }\n      }\n    }\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.CollisionMap#checkDef\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} res - [description]\r\n   * @param {number} t - [description]\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   * @param {number} vx - [description]\r\n   * @param {number} vy - [description]\r\n   * @param {number} width - [description]\r\n   * @param {number} height - [description]\r\n   * @param {number} tileX - [description]\r\n   * @param {number} tileY - [description]\r\n   *\r\n   * @return {boolean} [description]\r\n   */\n  checkDef: function checkDef(res, t, x, y, vx, vy, width, height, tileX, tileY) {\n    var def = this.tiledef[t];\n\n    if (!def) {\n      return false;\n    }\n\n    var tilesize = this.tilesize;\n    var lx = (tileX + def[0]) * tilesize;\n    var ly = (tileY + def[1]) * tilesize;\n    var lvx = (def[2] - def[0]) * tilesize;\n    var lvy = (def[3] - def[1]) * tilesize;\n    var solid = def[4];\n    var tx = x + vx + (lvy < 0 ? width : 0) - lx;\n    var ty = y + vy + (lvx > 0 ? height : 0) - ly;\n\n    if (lvx * ty - lvy * tx > 0) {\n      if (vx * -lvy + vy * lvx < 0) {\n        return solid;\n      }\n\n      var length = Math.sqrt(lvx * lvx + lvy * lvy);\n      var nx = lvy / length;\n      var ny = -lvx / length;\n      var proj = tx * nx + ty * ny;\n      var px = nx * proj;\n      var py = ny * proj;\n\n      if (px * px + py * py >= vx * vx + vy * vy) {\n        return solid || lvx * (ty - vy) - lvy * (tx - vx) < 0.5;\n      }\n\n      res.pos.x = x + vx - px;\n      res.pos.y = y + vy - py;\n      res.collision.slope = {\n        x: lvx,\n        y: lvy,\n        nx: nx,\n        ny: ny\n      };\n      return true;\n    }\n\n    return false;\n  }\n});\nmodule.exports = CollisionMap;","map":null,"metadata":{},"sourceType":"script"}