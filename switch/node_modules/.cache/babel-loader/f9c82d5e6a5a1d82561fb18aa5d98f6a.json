{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar BlendModes = require('../../renderer/BlendModes');\n\nvar Camera = require('../../cameras/2d/BaseCamera');\n\nvar CanvasPool = require('../../display/canvas/CanvasPool');\n\nvar Class = require('../../utils/Class');\n\nvar Components = require('../components');\n\nvar CONST = require('../../const');\n\nvar Frame = require('../../textures/Frame');\n\nvar GameObject = require('../GameObject');\n\nvar Render = require('./RenderTextureRender');\n\nvar Utils = require('../../renderer/webgl/Utils');\n\nvar UUID = require('../../utils/string/UUID');\n/**\r\n * @classdesc\r\n * A Render Texture.\r\n * \r\n * A Render Texture is a special texture that allows any number of Game Objects to be drawn to it. You can take many complex objects and\r\n * draw them all to this one texture, which can they be used as the texture for other Game Object's. It's a way to generate dynamic\r\n * textures at run-time that are WebGL friendly and don't invoke expensive GPU uploads.\r\n * \r\n * Note that under WebGL a FrameBuffer, which is what the Render Texture uses internally, cannot be anti-aliased. This means\r\n * that when drawing objects such as Shapes to a Render Texture they will appear to be drawn with no aliasing, however this\r\n * is a technical limitation of WebGL. To get around it, create your shape as a texture in an art package, then draw that\r\n * to the Render Texture.\r\n *\r\n * @class RenderTexture\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.2.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {integer} [width=32] - The width of the Render Texture.\r\n * @param {integer} [height=32] - The height of the Render Texture.\r\n */\n\n\nvar RenderTexture = new Class({\n  Extends: GameObject,\n  Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Crop, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScaleMode, Components.ScrollFactor, Components.Tint, Components.Transform, Components.Visible, Render],\n  initialize: function RenderTexture(scene, x, y, width, height) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = 32;\n    }\n\n    if (height === undefined) {\n      height = 32;\n    }\n\n    GameObject.call(this, scene, 'RenderTexture');\n    /**\r\n     * A reference to either the Canvas or WebGL Renderer that the Game instance is using.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#renderer\r\n     * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n     * @since 3.2.0\r\n     */\n\n    this.renderer = scene.sys.game.renderer;\n    /**\r\n     * A reference to the Texture Manager.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#textureManager\r\n     * @type {Phaser.Textures.TextureManager}\r\n     * @since 3.12.0\r\n     */\n\n    this.textureManager = scene.sys.textures;\n    /**\r\n     * The tint of the Render Texture when rendered.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#globalTint\r\n     * @type {number}\r\n     * @default 0xffffff\r\n     * @since 3.2.0\r\n     */\n\n    this.globalTint = 0xffffff;\n    /**\r\n     * The alpha of the Render Texture when rendered.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#globalAlpha\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.2.0\r\n     */\n\n    this.globalAlpha = 1;\n    /**\r\n     * The HTML Canvas Element that the Render Texture is drawing to when using the Canvas Renderer.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#canvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.2.0\r\n     */\n\n    this.canvas = CanvasPool.create2D(this, width, height);\n    /**\r\n     * A reference to the Rendering Context belonging to the Canvas Element this Render Texture is drawing to.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#context\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.2.0\r\n     */\n\n    this.context = this.canvas.getContext('2d');\n    /**\r\n     * A reference to the GL Frame Buffer this Render Texture is drawing to.\r\n     * This is only set if Phaser is running with the WebGL Renderer.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#framebuffer\r\n     * @type {?WebGLFramebuffer}\r\n     * @since 3.2.0\r\n     */\n\n    this.framebuffer = null;\n    /**\r\n     * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#_crop\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._crop = this.resetCropObject();\n    /**\r\n     * The Texture corresponding to this Render Texture.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#texture\r\n     * @type {Phaser.Textures.Texture}\r\n     * @since 3.12.0\r\n     */\n\n    this.texture = scene.sys.textures.addCanvas(UUID(), this.canvas);\n    /**\r\n     * The Frame corresponding to this Render Texture.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#frame\r\n     * @type {Phaser.Textures.Frame}\r\n     * @since 3.12.0\r\n     */\n\n    this.frame = this.texture.get();\n    /**\r\n     * Internal saved texture flag.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#_saved\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._saved = false;\n    /**\r\n     * Internal erase mode flag.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#_eraseMode\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this._eraseMode = false;\n    /**\r\n     * An internal Camera that can be used to move around the Render Texture.\r\n     * Control it just like you would any Scene Camera. The difference is that it only impacts the placement of what\r\n     * is drawn to the Render Texture. You can scroll, zoom and rotate this Camera.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#camera\r\n     * @type {Phaser.Cameras.Scene2D.BaseCamera}\r\n     * @since 3.12.0\r\n     */\n\n    this.camera = new Camera(0, 0, width, height);\n    /**\r\n     * Is this Render Texture dirty or not? If not it won't spend time clearing or filling itself.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#dirty\r\n     * @type {boolean}\r\n     * @since 3.12.0\r\n     */\n\n    this.dirty = false;\n    /**\r\n     * A reference to the WebGL Rendering Context.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#gl\r\n     * @type {WebGLRenderingContext}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.gl = null;\n    var renderer = this.renderer;\n\n    if (renderer.type === CONST.WEBGL) {\n      var gl = renderer.gl;\n      this.gl = gl;\n      this.drawGameObject = this.batchGameObjectWebGL;\n      this.framebuffer = renderer.createFramebuffer(width, height, this.frame.source.glTexture, false);\n    } else if (renderer.type === CONST.CANVAS) {\n      this.drawGameObject = this.batchGameObjectCanvas;\n    }\n\n    this.camera.setScene(scene);\n    this.setPosition(x, y);\n    this.setSize(width, height);\n    this.setOrigin(0, 0);\n    this.initPipeline();\n  },\n\n  /**\r\n   * Sets the size of this Game Object.\r\n   * \r\n   * @method Phaser.GameObjects.RenderTexture#setSize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} width - The width of this Game Object.\r\n   * @param {number} height - The height of this Game Object.\r\n   * \r\n   * @return {this} This Game Object instance.\r\n   */\n  setSize: function setSize(width, height) {\n    return this.resize(width, height);\n  },\n\n  /**\r\n   * Resizes the Render Texture to the new dimensions given.\r\n   *\r\n   * In WebGL it will destroy and then re-create the frame buffer being used by the Render Texture.\r\n   * In Canvas it will resize the underlying canvas element.\r\n   * Both approaches will erase everything currently drawn to the Render Texture.\r\n   *\r\n   * If the dimensions given are the same as those already being used, calling this method will do nothing.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#resize\r\n   * @since 3.10.0\r\n   *\r\n   * @param {number} width - The new width of the Render Texture.\r\n   * @param {number} [height] - The new height of the Render Texture. If not specified, will be set the same as the `width`.\r\n   *\r\n   * @return {this} This Render Texture.\r\n   */\n  resize: function resize(width, height) {\n    if (height === undefined) {\n      height = width;\n    }\n\n    if (width !== this.width || height !== this.height) {\n      this.canvas.width = width;\n      this.canvas.height = height;\n\n      if (this.gl) {\n        var gl = this.gl;\n        this.renderer.deleteTexture(this.frame.source.glTexture);\n        this.renderer.deleteFramebuffer(this.framebuffer);\n        this.frame.source.glTexture = this.renderer.createTexture2D(0, gl.NEAREST, gl.NEAREST, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.RGBA, null, width, height, false);\n        this.framebuffer = this.renderer.createFramebuffer(width, height, this.frame.source.glTexture, false);\n        this.frame.glTexture = this.frame.source.glTexture;\n      }\n\n      this.frame.source.width = width;\n      this.frame.source.height = height;\n      this.camera.setSize(width, height);\n      this.frame.setSize(width, height);\n      this.width = width;\n      this.height = height;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Set the tint to use when rendering this Render Texture.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#setGlobalTint\r\n   * @since 3.2.0\r\n   *\r\n   * @param {integer} tint - The tint value.\r\n   *\r\n   * @return {this} This Render Texture.\r\n   */\n  setGlobalTint: function setGlobalTint(tint) {\n    this.globalTint = tint;\n    return this;\n  },\n\n  /**\r\n   * Set the alpha to use when rendering this Render Texture.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#setGlobalAlpha\r\n   * @since 3.2.0\r\n   *\r\n   * @param {number} alpha - The alpha value.\r\n   *\r\n   * @return {this} This Render Texture.\r\n   */\n  setGlobalAlpha: function setGlobalAlpha(alpha) {\n    this.globalAlpha = alpha;\n    return this;\n  },\n\n  /**\r\n   * Stores a copy of this Render Texture in the Texture Manager using the given key.\r\n   * \r\n   * After doing this, any texture based Game Object, such as a Sprite, can use the contents of this\r\n   * Render Texture by using the texture key:\r\n   * \r\n   * ```javascript\r\n   * var rt = this.add.renderTexture(0, 0, 128, 128);\r\n   * \r\n   * // Draw something to the Render Texture\r\n   * \r\n   * rt.saveTexture('doodle');\r\n   * \r\n   * this.add.image(400, 300, 'doodle');\r\n   * ```\r\n   * \r\n   * Updating the contents of this Render Texture will automatically update _any_ Game Object\r\n   * that is using it as a texture. Calling `saveTexture` again will not save another copy\r\n   * of the same texture, it will just rename the key of the existing copy.\r\n   * \r\n   * By default it will create a single base texture. You can add frames to the texture\r\n   * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n   * to use a specific frame from a Render Texture.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#saveTexture\r\n   * @since 3.12.0\r\n   *\r\n   * @param {string} key - The unique key to store the texture as within the global Texture Manager.\r\n   *\r\n   * @return {Phaser.Textures.Texture} The Texture that was saved.\r\n   */\n  saveTexture: function saveTexture(key) {\n    this.textureManager.renameTexture(this.texture.key, key);\n    this._saved = true;\n    return this.texture;\n  },\n\n  /**\r\n   * Fills the Render Texture with the given color.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#fill\r\n   * @since 3.2.0\r\n   *\r\n   * @param {number} rgb - The color to fill the Render Texture with.\r\n   * @param {number} [alpha=1] - The alpha value used by the fill.\r\n   *\r\n   * @return {this} This Render Texture instance.\r\n   */\n  fill: function fill(rgb, alpha) {\n    if (alpha === undefined) {\n      alpha = 1;\n    }\n\n    var r = (rgb >> 16 | 0) & 0xff;\n    var g = (rgb >> 8 | 0) & 0xff;\n    var b = (rgb | 0) & 0xff;\n    var gl = this.gl;\n\n    if (gl) {\n      var renderer = this.renderer;\n      var bounds = this.getBounds();\n      renderer.setFramebuffer(this.framebuffer, true);\n      this.pipeline.drawFillRect(bounds.x, bounds.y, bounds.right, bounds.bottom, Utils.getTintFromFloats(r / 255, g / 255, b / 255, 1), alpha);\n      renderer.setFramebuffer(null, true);\n    } else {\n      this.context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';\n      this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Clears the Render Texture.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#clear\r\n   * @since 3.2.0\r\n   *\r\n   * @return {this} This Render Texture instance.\r\n   */\n  clear: function clear() {\n    if (this.dirty) {\n      var gl = this.gl;\n\n      if (gl) {\n        var renderer = this.renderer;\n        renderer.setFramebuffer(this.framebuffer, true);\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        renderer.setFramebuffer(null, true);\n      } else {\n        var ctx = this.context;\n        ctx.save();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        ctx.restore();\n      }\n\n      this.dirty = false;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Draws the given object, or an array of objects, to this Render Texture using a blend mode of ERASE.\r\n   * This has the effect of erasing any filled pixels in the objects from this Render Texture.\r\n   * \r\n   * It can accept any of the following:\r\n   * \r\n   * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.\r\n   * * Dynamic and Static Tilemap Layers.\r\n   * * A Group. The contents of which will be iterated and drawn in turn.\r\n   * * A Container. The contents of which will be iterated fully, and drawn in turn.\r\n   * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.\r\n   * * Another Render Texture.\r\n   * * A Texture Frame instance.\r\n   * * A string. This is used to look-up a texture from the Texture Manager.\r\n   * \r\n   * Note: You cannot erase a Render Texture from itself.\r\n   * \r\n   * If passing in a Group or Container it will only draw children that return `true`\r\n   * when their `willRender()` method is called. I.e. a Container with 10 children,\r\n   * 5 of which have `visible=false` will only draw the 5 visible ones.\r\n   * \r\n   * If passing in an array of Game Objects it will draw them all, regardless if\r\n   * they pass a `willRender` check or not.\r\n   * \r\n   * You can pass in a string in which case it will look for a texture in the Texture\r\n   * Manager matching that string, and draw the base frame.\r\n   * \r\n   * You can pass in the `x` and `y` coordinates to draw the objects at. The use of\r\n   * the coordinates differ based on what objects are being drawn. If the object is\r\n   * a Group, Container or Display List, the coordinates are _added_ to the positions\r\n   * of the children. For all other types of object, the coordinates are exact.\r\n   * \r\n   * Calling this method causes the WebGL batch to flush, so it can write the texture\r\n   * data to the framebuffer being used internally. The batch is flushed at the end,\r\n   * after the entries have been iterated. So if you've a bunch of objects to draw,\r\n   * try and pass them in an array in one single call, rather than making lots of\r\n   * separate calls.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#erase\r\n   * @since 3.16.0\r\n   *\r\n   * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.\r\n   * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.\r\n   * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.\r\n   *\r\n   * @return {this} This Render Texture instance.\r\n   */\n  erase: function erase(entries, x, y) {\n    this._eraseMode = true;\n    var blendMode = this.renderer.currentBlendMode;\n    this.renderer.setBlendMode(BlendModes.ERASE);\n    this.draw(entries, x, y, 1, 16777215);\n    this.renderer.setBlendMode(blendMode);\n    this._eraseMode = false;\n    return this;\n  },\n\n  /**\r\n   * Draws the given object, or an array of objects, to this Render Texture.\r\n   * \r\n   * It can accept any of the following:\r\n   * \r\n   * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.\r\n   * * Dynamic and Static Tilemap Layers.\r\n   * * A Group. The contents of which will be iterated and drawn in turn.\r\n   * * A Container. The contents of which will be iterated fully, and drawn in turn.\r\n   * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.\r\n   * * Another Render Texture.\r\n   * * A Texture Frame instance.\r\n   * * A string. This is used to look-up a texture from the Texture Manager.\r\n   * \r\n   * Note: You cannot draw a Render Texture to itself.\r\n   * \r\n   * If passing in a Group or Container it will only draw children that return `true`\r\n   * when their `willRender()` method is called. I.e. a Container with 10 children,\r\n   * 5 of which have `visible=false` will only draw the 5 visible ones.\r\n   * \r\n   * If passing in an array of Game Objects it will draw them all, regardless if\r\n   * they pass a `willRender` check or not.\r\n   * \r\n   * You can pass in a string in which case it will look for a texture in the Texture\r\n   * Manager matching that string, and draw the base frame. If you need to specify\r\n   * exactly which frame to draw then use the method `drawFrame` instead.\r\n   * \r\n   * You can pass in the `x` and `y` coordinates to draw the objects at. The use of\r\n   * the coordinates differ based on what objects are being drawn. If the object is\r\n   * a Group, Container or Display List, the coordinates are _added_ to the positions\r\n   * of the children. For all other types of object, the coordinates are exact.\r\n   * \r\n   * The `alpha` and `tint` values are only used by Texture Frames.\r\n   * Game Objects use their own alpha and tint values when being drawn.\r\n   * \r\n   * Calling this method causes the WebGL batch to flush, so it can write the texture\r\n   * data to the framebuffer being used internally. The batch is flushed at the end,\r\n   * after the entries have been iterated. So if you've a bunch of objects to draw,\r\n   * try and pass them in an array in one single call, rather than making lots of\r\n   * separate calls.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#draw\r\n   * @since 3.2.0\r\n   *\r\n   * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.\r\n   * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.\r\n   * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.\r\n   * @param {number} [alpha] -  The alpha value. Only used for Texture Frames and if not specified defaults to the `globalAlpha` property. Game Objects use their own current alpha value.\r\n   * @param {number} [tint] -  WebGL only. The tint color value. Only used for Texture Frames and if not specified defaults to the `globalTint` property. Game Objects use their own current tint value.\r\n   *\r\n   * @return {this} This Render Texture instance.\r\n   */\n  draw: function draw(entries, x, y, alpha, tint) {\n    if (alpha === undefined) {\n      alpha = this.globalAlpha;\n    }\n\n    if (tint === undefined) {\n      tint = (this.globalTint >> 16) + (this.globalTint & 0xff00) + ((this.globalTint & 0xff) << 16);\n    } else {\n      tint = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16);\n    }\n\n    if (!Array.isArray(entries)) {\n      entries = [entries];\n    }\n\n    var gl = this.gl;\n    this.camera.preRender(1, 1);\n\n    if (gl) {\n      var cx = this.camera._cx;\n      var cy = this.camera._cy;\n      var cw = this.camera._cw;\n      var ch = this.camera._ch;\n      this.renderer.setFramebuffer(this.framebuffer, false);\n      this.renderer.pushScissor(cx, cy, cw, ch, ch);\n      var pipeline = this.pipeline;\n      pipeline.projOrtho(0, this.width, 0, this.height, -1000.0, 1000.0);\n      this.batchList(entries, x, y, alpha, tint);\n      pipeline.flush();\n      this.renderer.setFramebuffer(null, false);\n      this.renderer.popScissor();\n      pipeline.projOrtho(0, pipeline.width, pipeline.height, 0, -1000.0, 1000.0);\n    } else {\n      this.renderer.setContext(this.context);\n      this.batchList(entries, x, y, alpha, tint);\n      this.renderer.setContext();\n    }\n\n    this.dirty = true;\n    return this;\n  },\n\n  /**\r\n   * Draws the Texture Frame to the Render Texture at the given position.\r\n   * \r\n   * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n   * \r\n   * ```javascript\r\n   * var rt = this.add.renderTexture(0, 0, 800, 600);\r\n   * rt.drawFrame(key, frame);\r\n   * ```\r\n   * \r\n   * You can optionally provide a position, alpha and tint value to apply to the frame\r\n   * before it is drawn.\r\n   * \r\n   * Calling this method will cause a batch flush, so if you've got a stack of things to draw\r\n   * in a tight loop, try using the `draw` method instead.\r\n   * \r\n   * If you need to draw a Sprite to this Render Texture, use the `draw` method instead.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#drawFrame\r\n   * @since 3.12.0\r\n   *\r\n   * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n   * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.\r\n   * @param {number} [x=0] - The x position to draw the frame at.\r\n   * @param {number} [y=0] - The y position to draw the frame at.\r\n   * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n   * @param {number} [tint] - WebGL only. The tint color to use. If not specified it uses the `globalTint` property.\r\n   *\r\n   * @return {this} This Render Texture instance.\r\n   */\n  drawFrame: function drawFrame(key, frame, x, y, alpha, tint) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (alpha === undefined) {\n      alpha = this.globalAlpha;\n    }\n\n    if (tint === undefined) {\n      tint = (this.globalTint >> 16) + (this.globalTint & 0xff00) + ((this.globalTint & 0xff) << 16);\n    } else {\n      tint = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16);\n    }\n\n    var gl = this.gl;\n    var textureFrame = this.textureManager.getFrame(key, frame);\n\n    if (textureFrame) {\n      this.camera.preRender(1, 1);\n\n      if (gl) {\n        var cx = this.camera._cx;\n        var cy = this.camera._cy;\n        var cw = this.camera._cw;\n        var ch = this.camera._ch;\n        this.renderer.setFramebuffer(this.framebuffer, false);\n        this.renderer.pushScissor(cx, cy, cw, ch, ch);\n        var pipeline = this.pipeline;\n        pipeline.projOrtho(0, this.width, 0, this.height, -1000.0, 1000.0);\n        pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);\n        pipeline.flush();\n        this.renderer.setFramebuffer(null, false);\n        this.renderer.popScissor();\n        pipeline.projOrtho(0, pipeline.width, pipeline.height, 0, -1000.0, 1000.0);\n      } else {\n        this.batchTextureFrame(textureFrame, x, y, alpha, tint);\n      }\n\n      this.dirty = true;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Internal method that handles the drawing of an array of children.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#batchList\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {array} children - The array of Game Objects to draw.\r\n   * @param {number} x - The x position to offset the Game Object by.\r\n   * @param {number} y - The y position to offset the Game Object by.\r\n   * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n   * @param {number} [tint] - The tint color to use. If not specified it uses the `globalTint` property.\r\n   */\n  batchList: function batchList(children, x, y, alpha, tint) {\n    for (var i = 0; i < children.length; i++) {\n      var entry = children[i];\n\n      if (!entry || entry === this) {\n        continue;\n      }\n\n      if (entry.renderWebGL || entry.renderCanvas) {\n        //  Game Objects\n        this.drawGameObject(entry, x, y);\n      } else if (entry.isParent || entry.list) {\n        //  Groups / Display Lists\n        this.batchGroup(entry.getChildren(), x, y);\n      } else if (typeof entry === 'string') {\n        //  Texture key\n        this.batchTextureFrameKey(entry, null, x, y, alpha, tint);\n      } else if (entry instanceof Frame) {\n        //  Texture Frame instance\n        this.batchTextureFrame(entry, x, y, alpha, tint);\n      } else if (Array.isArray(entry)) {\n        //  Another Array\n        this.batchList(entry, x, y, alpha, tint);\n      }\n    }\n  },\n\n  /**\r\n   * Internal method that handles the drawing a Phaser Group contents.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#batchGroup\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {array} children - The array of Game Objects to draw.\r\n   * @param {number} x - The x position to offset the Game Object by.\r\n   * @param {number} y - The y position to offset the Game Object by.\r\n   */\n  batchGroup: function batchGroup(children, x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    for (var i = 0; i < children.length; i++) {\n      var entry = children[i];\n\n      if (entry.willRender()) {\n        var tx = entry.x + x;\n        var ty = entry.y + y;\n        this.drawGameObject(entry, tx, ty);\n      }\n    }\n  },\n\n  /**\r\n   * Internal method that handles drawing a single Phaser Game Object to this Render Texture using WebGL.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#batchGameObjectWebGL\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to draw.\r\n   * @param {number} x - The x position to draw the Game Object at.\r\n   * @param {number} y - The y position to draw the Game Object at.\r\n   */\n  batchGameObjectWebGL: function batchGameObjectWebGL(gameObject, x, y) {\n    if (x === undefined) {\n      x = gameObject.x;\n    }\n\n    if (y === undefined) {\n      y = gameObject.y;\n    }\n\n    var prevX = gameObject.x;\n    var prevY = gameObject.y;\n\n    if (!this._eraseMode) {\n      this.renderer.setBlendMode(gameObject.blendMode);\n    }\n\n    gameObject.setPosition(x, y);\n    gameObject.renderWebGL(this.renderer, gameObject, 0, this.camera, null);\n    gameObject.setPosition(prevX, prevY);\n  },\n\n  /**\r\n   * Internal method that handles drawing a single Phaser Game Object to this Render Texture using Canvas.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#batchGameObjectCanvas\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to draw.\r\n   * @param {number} x - The x position to draw the Game Object at.\r\n   * @param {number} y - The y position to draw the Game Object at.\r\n   */\n  batchGameObjectCanvas: function batchGameObjectCanvas(gameObject, x, y) {\n    if (x === undefined) {\n      x = gameObject.x;\n    }\n\n    if (y === undefined) {\n      y = gameObject.y;\n    }\n\n    var prevX = gameObject.x;\n    var prevY = gameObject.y;\n\n    if (this._eraseMode) {\n      var blendMode = gameObject.blendMode;\n      gameObject.blendMode = BlendModes.ERASE;\n    }\n\n    gameObject.setPosition(x, y);\n    gameObject.renderCanvas(this.renderer, gameObject, 0, this.camera, null);\n    gameObject.setPosition(prevX, prevY);\n\n    if (this._eraseMode) {\n      gameObject.blendMode = blendMode;\n    }\n  },\n\n  /**\r\n   * Internal method that handles the drawing of an array of children.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#batchTextureFrameKey\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n   * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.\r\n   * @param {number} x - The x position to offset the Game Object by.\r\n   * @param {number} y - The y position to offset the Game Object by.\r\n   * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n   * @param {number} [tint] - The tint color to use. If not specified it uses the `globalTint` property.\r\n   * \r\n   * @return {boolean} `true` if the frame was found and drawn, otherwise `false`.\r\n   */\n  batchTextureFrameKey: function batchTextureFrameKey(key, frame, x, y, alpha, tint) {\n    var textureFrame = this.textureManager.getFrame(key, frame);\n\n    if (textureFrame) {\n      this.batchTextureFrame(textureFrame, x, y, alpha, tint);\n    }\n  },\n\n  /**\r\n   * Internal method that handles the drawing of a Texture Frame to this Render Texture.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#batchTextureFrame\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {Phaser.Textures.Frame} textureFrame - The Texture Frame to draw.\r\n   * @param {number} x - The x position to draw the Frame at.\r\n   * @param {number} y - The y position to draw the Frame at.\r\n   * @param {number} [tint] - A tint color to be applied to the frame drawn to the Render Texture.\r\n   */\n  batchTextureFrame: function batchTextureFrame(textureFrame, x, y, alpha, tint) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (this.gl) {\n      this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);\n    } else {\n      var ctx = this.context;\n      var cd = textureFrame.canvasData;\n      var source = textureFrame.source.image;\n      var matrix = this.camera.matrix;\n      ctx.globalAlpha = this.globalAlpha;\n      ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n      ctx.drawImage(source, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);\n    }\n  },\n\n  /**\r\n   * Internal destroy handler, called as part of the destroy process.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#preDestroy\r\n   * @protected\r\n   * @since 3.9.0\r\n   */\n  preDestroy: function preDestroy() {\n    if (!this._saved) {\n      CanvasPool.remove(this.canvas);\n\n      if (this.gl) {\n        this.renderer.deleteFramebuffer(this.framebuffer);\n      }\n\n      this.texture.destroy();\n      this.camera.destroy();\n      this.canvas = null;\n      this.context = null;\n      this.framebuffer = null;\n      this.texture = null;\n    }\n  }\n});\nmodule.exports = RenderTexture;","map":null,"metadata":{},"sourceType":"script"}