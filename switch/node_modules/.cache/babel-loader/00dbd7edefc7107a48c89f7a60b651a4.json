{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar FromPoints = require('../geom/rectangle/FromPoints');\n\nvar Rectangle = require('../geom/rectangle/Rectangle');\n\nvar Vector2 = require('../math/Vector2');\n/**\r\n * @classdesc\r\n * A Base Curve class, which all other curve types extend.\r\n *\r\n * Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\r\n *\r\n * @class Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} type - [description]\r\n */\n\n\nvar Curve = new Class({\n  initialize: function Curve(type) {\n    /**\r\n     * String based identifier for the type of curve.\r\n     *\r\n     * @name Phaser.Curves.Curve#type\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n    this.type = type;\n    /**\r\n     * The default number of divisions within the curve.\r\n     *\r\n     * @name Phaser.Curves.Curve#defaultDivisions\r\n     * @type {integer}\r\n     * @default 5\r\n     * @since 3.0.0\r\n     */\n\n    this.defaultDivisions = 5;\n    /**\r\n     * The quantity of arc length divisions within the curve.\r\n     *\r\n     * @name Phaser.Curves.Curve#arcLengthDivisions\r\n     * @type {integer}\r\n     * @default 100\r\n     * @since 3.0.0\r\n     */\n\n    this.arcLengthDivisions = 100;\n    /**\r\n     * An array of cached arc length values.\r\n     *\r\n     * @name Phaser.Curves.Curve#cacheArcLengths\r\n     * @type {number[]}\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this.cacheArcLengths = [];\n    /**\r\n     * Does the data of this curve need updating?\r\n     *\r\n     * @name Phaser.Curves.Curve#needsUpdate\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.needsUpdate = true;\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Curves.Curve#active\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.active = true;\n    /**\r\n     * A temporary calculation Vector.\r\n     *\r\n     * @name Phaser.Curves.Curve#_tmpVec2A\r\n     * @type {Phaser.Math.Vector2}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._tmpVec2A = new Vector2();\n    /**\r\n     * A temporary calculation Vector.\r\n     *\r\n     * @name Phaser.Curves.Curve#_tmpVec2B\r\n     * @type {Phaser.Math.Vector2}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._tmpVec2B = new Vector2();\n  },\n\n  /**\r\n   * Draws this curve on the given Graphics object.\r\n   *\r\n   * The curve is drawn using `Graphics.strokePoints` so will be drawn at whatever the present Graphics stroke color is.\r\n   * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.\r\n   *\r\n   * @method Phaser.Curves.Curve#draw\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]\r\n   *\r\n   * @param {Phaser.GameObjects.Graphics} graphics - The Graphics instance onto which this curve will be drawn.\r\n   * @param {integer} [pointsTotal=32] - The resolution of the curve. The higher the value the smoother it will render, at the cost of rendering performance.\r\n   *\r\n   * @return {Phaser.GameObjects.Graphics} The Graphics object to which the curve was drawn.\r\n   */\n  draw: function draw(graphics, pointsTotal) {\n    if (pointsTotal === undefined) {\n      pointsTotal = 32;\n    } //  So you can chain graphics calls\n\n\n    return graphics.strokePoints(this.getPoints(pointsTotal));\n  },\n\n  /**\r\n   * Returns a Rectangle where the position and dimensions match the bounds of this Curve.\r\n   *\r\n   * You can control the accuracy of the bounds. The value given is used to work out how many points\r\n   * to plot across the curve. Higher values are more accurate at the cost of calculation speed.\r\n   *\r\n   * @method Phaser.Curves.Curve#getBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Geom.Rectangle} [out] - The Rectangle to store the bounds in. If falsey a new object will be created.\r\n   * @param {integer} [accuracy=16] - The accuracy of the bounds calculations.\r\n   *\r\n   * @return {Phaser.Geom.Rectangle} A Rectangle object holding the bounds of this curve. If `out` was given it will be this object.\r\n   */\n  getBounds: function getBounds(out, accuracy) {\n    if (!out) {\n      out = new Rectangle();\n    }\n\n    if (accuracy === undefined) {\n      accuracy = 16;\n    }\n\n    var len = this.getLength();\n\n    if (accuracy > len) {\n      accuracy = len / 2;\n    } //  The length of the curve in pixels\n    //  So we'll have 1 spaced point per 'accuracy' pixels\n\n\n    var spaced = Math.max(1, Math.round(len / accuracy));\n    return FromPoints(this.getSpacedPoints(spaced), out);\n  },\n\n  /**\r\n   * Returns an array of points, spaced out X distance pixels apart.\r\n   * The smaller the distance, the larger the array will be.\r\n   *\r\n   * @method Phaser.Curves.Curve#getDistancePoints\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} distance - The distance, in pixels, between each point along the curve.\r\n   *\r\n   * @return {Phaser.Geom.Point[]} An Array of Point objects.\r\n   */\n  getDistancePoints: function getDistancePoints(distance) {\n    var len = this.getLength();\n    var spaced = Math.max(1, len / distance);\n    return this.getSpacedPoints(spaced);\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Curve#getEndPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} [out] - Optional Vector object to store the result in.\r\n   *\r\n   * @return {Phaser.Math.Vector2} Vector2 containing the coordinates of the curves end point.\r\n   */\n  getEndPoint: function getEndPoint(out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    return this.getPointAt(1, out);\n  },\n  // Get total curve arc length\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Curve#getLength\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} [description]\r\n   */\n  getLength: function getLength() {\n    var lengths = this.getLengths();\n    return lengths[lengths.length - 1];\n  },\n  // Get list of cumulative segment lengths\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Curve#getLengths\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} [divisions] - [description]\r\n   *\r\n   * @return {number[]} [description]\r\n   */\n  getLengths: function getLengths(divisions) {\n    if (divisions === undefined) {\n      divisions = this.arcLengthDivisions;\n    }\n\n    if (this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n      return this.cacheArcLengths;\n    }\n\n    this.needsUpdate = false;\n    var cache = [];\n    var current;\n    var last = this.getPoint(0, this._tmpVec2A);\n    var sum = 0;\n    cache.push(0);\n\n    for (var p = 1; p <= divisions; p++) {\n      current = this.getPoint(p / divisions, this._tmpVec2B);\n      sum += current.distance(last);\n      cache.push(sum);\n      last.copy(current);\n    }\n\n    this.cacheArcLengths = cache;\n    return cache; // { sums: cache, sum:sum }; Sum is in the last element.\n  },\n  // Get point at relative position in curve according to arc length\n  // - u [0 .. 1]\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Curve#getPointAt\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {number} u - [description]\r\n   * @param {Phaser.Math.Vector2} [out] - [description]\r\n   *\r\n   * @return {Phaser.Math.Vector2} [description]\r\n   */\n  getPointAt: function getPointAt(u, out) {\n    var t = this.getUtoTmapping(u);\n    return this.getPoint(t, out);\n  },\n  // Get sequence of points using getPoint( t )\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Curve#getPoints\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} [divisions] - [description]\r\n   *\r\n   * @return {Phaser.Math.Vector2[]} [description]\r\n   */\n  getPoints: function getPoints(divisions) {\n    if (divisions === undefined) {\n      divisions = this.defaultDivisions;\n    }\n\n    var points = [];\n\n    for (var d = 0; d <= divisions; d++) {\n      points.push(this.getPoint(d / divisions));\n    }\n\n    return points;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Curve#getRandomPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {Phaser.Math.Vector2} [out] - [description]\r\n   *\r\n   * @return {Phaser.Math.Vector2} [description]\r\n   */\n  getRandomPoint: function getRandomPoint(out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    return this.getPoint(Math.random(), out);\n  },\n  // Get sequence of points using getPointAt( u )\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Curve#getSpacedPoints\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} [divisions] - [description]\r\n   *\r\n   * @return {Phaser.Math.Vector2[]} [description]\r\n   */\n  getSpacedPoints: function getSpacedPoints(divisions) {\n    if (divisions === undefined) {\n      divisions = this.defaultDivisions;\n    }\n\n    var points = [];\n\n    for (var d = 0; d <= divisions; d++) {\n      var t = this.getUtoTmapping(d / divisions, null, divisions);\n      points.push(this.getPoint(t));\n    }\n\n    return points;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Curve#getStartPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {Phaser.Math.Vector2} [out] - [description]\r\n   *\r\n   * @return {Phaser.Math.Vector2} [description]\r\n   */\n  getStartPoint: function getStartPoint(out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    return this.getPointAt(0, out);\n  },\n  // Returns a unit vector tangent at t\n  // In case any sub curve does not implement its tangent derivation,\n  // 2 points a small delta apart will be used to find its gradient\n  // which seems to give a reasonable approximation\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Curve#getTangent\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {number} t - [description]\r\n   * @param {Phaser.Math.Vector2} [out] - [description]\r\n   *\r\n   * @return {Phaser.Math.Vector2} Vector approximating the tangent line at the point t (delta +/- 0.0001)\r\n   */\n  getTangent: function getTangent(t, out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    var delta = 0.0001;\n    var t1 = t - delta;\n    var t2 = t + delta; // Capping in case of danger\n\n    if (t1 < 0) {\n      t1 = 0;\n    }\n\n    if (t2 > 1) {\n      t2 = 1;\n    }\n\n    this.getPoint(t1, this._tmpVec2A);\n    this.getPoint(t2, out);\n    return out.subtract(this._tmpVec2A).normalize();\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Curve#getTangentAt\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {number} u - [description]\r\n   * @param {Phaser.Math.Vector2} [out] - [description]\r\n   *\r\n   * @return {Phaser.Math.Vector2} [description]\r\n   */\n  getTangentAt: function getTangentAt(u, out) {\n    var t = this.getUtoTmapping(u);\n    return this.getTangent(t, out);\n  },\n  //  Given a distance in pixels, get a t to find p.\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Curve#getTFromDistance\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} distance - [description]\r\n   * @param {integer} [divisions] - [description]\r\n   *\r\n   * @return {number} [description]\r\n   */\n  getTFromDistance: function getTFromDistance(distance, divisions) {\n    if (distance <= 0) {\n      return 0;\n    }\n\n    return this.getUtoTmapping(0, distance, divisions);\n  },\n  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Curve#getUtoTmapping\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} u - [description]\r\n   * @param {integer} distance - [description]\r\n   * @param {integer} [divisions] - [description]\r\n   *\r\n   * @return {number} [description]\r\n   */\n  getUtoTmapping: function getUtoTmapping(u, distance, divisions) {\n    var arcLengths = this.getLengths(divisions);\n    var i = 0;\n    var il = arcLengths.length;\n    var targetArcLength; // The targeted u distance value to get\n\n    if (distance) {\n      //  Cannot overshoot the curve\n      targetArcLength = Math.min(distance, arcLengths[il - 1]);\n    } else {\n      targetArcLength = u * arcLengths[il - 1];\n    } // binary search for the index with largest value smaller than target u distance\n\n\n    var low = 0;\n    var high = il - 1;\n    var comparison;\n\n    while (low <= high) {\n      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n      comparison = arcLengths[i] - targetArcLength;\n\n      if (comparison < 0) {\n        low = i + 1;\n      } else if (comparison > 0) {\n        high = i - 1;\n      } else {\n        high = i;\n        break;\n      }\n    }\n\n    i = high;\n\n    if (arcLengths[i] === targetArcLength) {\n      return i / (il - 1);\n    } // we could get finer grain at lengths, or use simple interpolation between two points\n\n\n    var lengthBefore = arcLengths[i];\n    var lengthAfter = arcLengths[i + 1];\n    var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points\n\n    var segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t\n\n    return (i + segmentFraction) / (il - 1);\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Curve#updateArcLengths\r\n   * @since 3.0.0\r\n   */\n  updateArcLengths: function updateArcLengths() {\n    this.needsUpdate = true;\n    this.getLengths();\n  }\n});\nmodule.exports = Curve;","map":null,"metadata":{},"sourceType":"script"}