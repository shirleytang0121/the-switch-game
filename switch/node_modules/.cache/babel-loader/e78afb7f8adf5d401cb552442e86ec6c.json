{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar DegToRad = require('../../math/DegToRad');\n\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\n\nvar DistanceSquared = require('../../math/distance/DistanceSquared');\n\nvar Factory = require('./Factory');\n\nvar GetFastValue = require('../../utils/object/GetFastValue');\n\nvar Merge = require('../../utils/object/Merge');\n\nvar PluginCache = require('../../plugins/PluginCache');\n\nvar SceneEvents = require('../../scene/events');\n\nvar Vector2 = require('../../math/Vector2');\n\nvar World = require('./World');\n/**\r\n * @classdesc\r\n * The Arcade Physics Plugin belongs to a Scene and sets up and manages the Scene's physics simulation.\r\n * It also holds some useful methods for moving and rotating Arcade Physics Bodies.\r\n *\r\n * You can access it from within a Scene using `this.physics`.\r\n *\r\n * @class ArcadePhysics\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that this Plugin belongs to.\r\n */\n\n\nvar ArcadePhysics = new Class({\n  initialize: function ArcadePhysics(scene) {\n    /**\r\n     * The Scene that this Plugin belongs to.\r\n     *\r\n     * @name Phaser.Physics.Arcade.ArcadePhysics#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n    this.scene = scene;\n    /**\r\n     * The Scene's Systems.\r\n     *\r\n     * @name Phaser.Physics.Arcade.ArcadePhysics#systems\r\n     * @type {Phaser.Scenes.Systems}\r\n     * @since 3.0.0\r\n     */\n\n    this.systems = scene.sys;\n    /**\r\n     * A configuration object. Union of the `physics.arcade.*` properties of the GameConfig and SceneConfig objects.\r\n     *\r\n     * @name Phaser.Physics.Arcade.ArcadePhysics#config\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.config = this.getConfig();\n    /**\r\n     * The physics simulation.\r\n     *\r\n     * @name Phaser.Physics.Arcade.ArcadePhysics#world\r\n     * @type {Phaser.Physics.Arcade.World}\r\n     * @since 3.0.0\r\n     */\n\n    this.world;\n    /**\r\n     * An object holding the Arcade Physics factory methods.\r\n     *\r\n     * @name Phaser.Physics.Arcade.ArcadePhysics#add\r\n     * @type {Phaser.Physics.Arcade.Factory}\r\n     * @since 3.0.0\r\n     */\n\n    this.add;\n    scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\n    scene.sys.events.on(SceneEvents.START, this.start, this);\n  },\n\n  /**\r\n   * This method is called automatically, only once, when the Scene is first created.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#boot\r\n   * @private\r\n   * @since 3.5.1\r\n   */\n  boot: function boot() {\n    this.world = new World(this.scene, this.config);\n    this.add = new Factory(this.world);\n    this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\n  },\n\n  /**\r\n   * This method is called automatically by the Scene when it is starting up.\r\n   * It is responsible for creating local systems, properties and listening for Scene events.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#start\r\n   * @private\r\n   * @since 3.5.0\r\n   */\n  start: function start() {\n    if (!this.world) {\n      this.world = new World(this.scene, this.config);\n      this.add = new Factory(this.world);\n    }\n\n    var eventEmitter = this.systems.events;\n    eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);\n    eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);\n    eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\n  },\n\n  /**\r\n   * Creates the physics configuration for the current Scene.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#getConfig\r\n   * @since 3.0.0\r\n   *\r\n   * @return {object} The physics configuration.\r\n   */\n  getConfig: function getConfig() {\n    var gameConfig = this.systems.game.config.physics;\n    var sceneConfig = this.systems.settings.physics;\n    var config = Merge(GetFastValue(sceneConfig, 'arcade', {}), GetFastValue(gameConfig, 'arcade', {}));\n    return config;\n  },\n\n  /**\r\n   * Tests if Game Objects overlap. See {@link Phaser.Physics.Arcade.World#overlap}\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#overlap\r\n   * @since 3.0.0\r\n   *\r\n   * @param {ArcadeColliderType} object1 - The first object or array of objects to check.\r\n   * @param {ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n   *\r\n   * @return {boolean} True if at least one Game Object overlaps another.\r\n   *\r\n   * @see Phaser.Physics.Arcade.World#overlap\r\n   */\n  overlap: function overlap(object1, object2, overlapCallback, processCallback, callbackContext) {\n    if (overlapCallback === undefined) {\n      overlapCallback = null;\n    }\n\n    if (processCallback === undefined) {\n      processCallback = null;\n    }\n\n    if (callbackContext === undefined) {\n      callbackContext = overlapCallback;\n    }\n\n    return this.world.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);\n  },\n\n  /**\r\n   * Tests if Game Objects overlap and separates them (if possible). See {@link Phaser.Physics.Arcade.World#collide}.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#collide\r\n   * @since 3.0.0\r\n   *\r\n   * @param {ArcadeColliderType} object1 - The first object or array of objects to check.\r\n   * @param {ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n   *\r\n   * @return {boolean} True if any overlapping Game Objects were separated, otherwise false.\r\n   *\r\n   * @see Phaser.Physics.Arcade.World#collide\r\n   */\n  collide: function collide(object1, object2, collideCallback, processCallback, callbackContext) {\n    if (collideCallback === undefined) {\n      collideCallback = null;\n    }\n\n    if (processCallback === undefined) {\n      processCallback = null;\n    }\n\n    if (callbackContext === undefined) {\n      callbackContext = collideCallback;\n    }\n\n    return this.world.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);\n  },\n\n  /**\r\n   * Pauses the simulation.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#pause\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Arcade.World} The simulation.\r\n   */\n  pause: function pause() {\n    return this.world.pause();\n  },\n\n  /**\r\n   * Resumes the simulation (if paused).\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#resume\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Arcade.World} The simulation.\r\n   */\n  resume: function resume() {\n    return this.world.resume();\n  },\n\n  /**\r\n   * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\r\n   *\r\n   * You must give a maximum speed value, beyond which the game object won't go any faster.\r\n   *\r\n   * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\r\n   * Note: The game object doesn't stop moving once it reaches the destination coordinates.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateTo\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n   * @param {number} x - The x coordinate to accelerate towards.\r\n   * @param {number} y - The y coordinate to accelerate towards.\r\n   * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\r\n   * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\r\n   * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\r\n   *\r\n   * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n   */\n  accelerateTo: function accelerateTo(gameObject, x, y, speed, xSpeedMax, ySpeedMax) {\n    if (speed === undefined) {\n      speed = 60;\n    }\n\n    var angle = Math.atan2(y - gameObject.y, x - gameObject.x);\n    gameObject.body.acceleration.setToPolar(angle, speed);\n\n    if (xSpeedMax !== undefined && ySpeedMax !== undefined) {\n      gameObject.body.maxVelocity.set(xSpeedMax, ySpeedMax);\n    }\n\n    return angle;\n  },\n\n  /**\r\n   * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\r\n   *\r\n   * You must give a maximum speed value, beyond which the game object won't go any faster.\r\n   *\r\n   * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\r\n   * Note: The game object doesn't stop moving once it reaches the destination coordinates.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateToObject\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n   * @param {Phaser.GameObjects.GameObject} destination - The Game Object to move towards. Can be any object but must have visible x/y properties.\r\n   * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\r\n   * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\r\n   * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\r\n   *\r\n   * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n   */\n  accelerateToObject: function accelerateToObject(gameObject, destination, speed, xSpeedMax, ySpeedMax) {\n    return this.accelerateTo(gameObject, destination.x, destination.y, speed, xSpeedMax, ySpeedMax);\n  },\n\n  /**\r\n   * Finds the Body closest to a source point or object.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#closest\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} The closest Body to the given source point.\r\n   */\n  closest: function closest(source) {\n    var bodies = this.world.tree.all();\n    var min = Number.MAX_VALUE;\n    var closest = null;\n    var x = source.x;\n    var y = source.y;\n\n    for (var i = bodies.length - 1; i >= 0; i--) {\n      var target = bodies[i];\n      var distance = DistanceSquared(x, y, target.x, target.y);\n\n      if (distance < min) {\n        closest = target;\n        min = distance;\n      }\n    }\n\n    return closest;\n  },\n\n  /**\r\n   * Finds the Body farthest from a source point or object.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#furthest\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} The Body furthest from the given source point.\r\n   */\n  furthest: function furthest(source) {\n    var bodies = this.world.tree.all();\n    var max = -1;\n    var farthest = null;\n    var x = source.x;\n    var y = source.y;\n\n    for (var i = bodies.length - 1; i >= 0; i--) {\n      var target = bodies[i];\n      var distance = DistanceSquared(x, y, target.x, target.y);\n\n      if (distance > max) {\n        farthest = target;\n        max = distance;\n      }\n    }\n\n    return farthest;\n  },\n\n  /**\r\n   * Move the given display object towards the x/y coordinates at a steady velocity.\r\n   * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\r\n   * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\r\n   * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\r\n   * Note: The display object doesn't stop moving once it reaches the destination coordinates.\r\n   * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#moveTo\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n   * @param {number} x - The x coordinate to move towards.\r\n   * @param {number} y - The y coordinate to move towards.\r\n   * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\r\n   * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\r\n   *\r\n   * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n   */\n  moveTo: function moveTo(gameObject, x, y, speed, maxTime) {\n    if (speed === undefined) {\n      speed = 60;\n    }\n\n    if (maxTime === undefined) {\n      maxTime = 0;\n    }\n\n    var angle = Math.atan2(y - gameObject.y, x - gameObject.x);\n\n    if (maxTime > 0) {\n      //  We know how many pixels we need to move, but how fast?\n      speed = DistanceBetween(gameObject.x, gameObject.y, x, y) / (maxTime / 1000);\n    }\n\n    gameObject.body.velocity.setToPolar(angle, speed);\n    return angle;\n  },\n\n  /**\r\n   * Move the given display object towards the destination object at a steady velocity.\r\n   * If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.\r\n   * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\r\n   * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\r\n   * Note: The display object doesn't stop moving once it reaches the destination coordinates.\r\n   * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#moveToObject\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n   * @param {object} destination - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n   * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\r\n   * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\r\n   *\r\n   * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n   */\n  moveToObject: function moveToObject(gameObject, destination, speed, maxTime) {\n    return this.moveTo(gameObject, destination.x, destination.y, speed, maxTime);\n  },\n\n  /**\r\n   * Given the angle (in degrees) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\r\n   * One way to use this is: velocityFromAngle(angle, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromAngle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} angle - The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)\r\n   * @param {number} [speed=60] - The speed it will move, in pixels per second squared.\r\n   * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\r\n   */\n  velocityFromAngle: function velocityFromAngle(angle, speed, vec2) {\n    if (speed === undefined) {\n      speed = 60;\n    }\n\n    if (vec2 === undefined) {\n      vec2 = new Vector2();\n    }\n\n    return vec2.setToPolar(DegToRad(angle), speed);\n  },\n\n  /**\r\n   * Given the rotation (in radians) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\r\n   * One way to use this is: velocityFromRotation(rotation, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromRotation\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} rotation - The angle in radians.\r\n   * @param {number} [speed=60] - The speed it will move, in pixels per second squared\r\n   * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\r\n   */\n  velocityFromRotation: function velocityFromRotation(rotation, speed, vec2) {\n    if (speed === undefined) {\n      speed = 60;\n    }\n\n    if (vec2 === undefined) {\n      vec2 = new Vector2();\n    }\n\n    return vec2.setToPolar(rotation, speed);\n  },\n\n  /**\r\n   * The Scene that owns this plugin is shutting down.\r\n   * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#shutdown\r\n   * @since 3.0.0\r\n   */\n  shutdown: function shutdown() {\n    if (!this.world) {\n      //  Already destroyed\n      return;\n    }\n\n    var eventEmitter = this.systems.events;\n    eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);\n    eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);\n    eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\n    this.add.destroy();\n    this.world.destroy();\n    this.add = null;\n    this.world = null;\n  },\n\n  /**\r\n   * The Scene that owns this plugin is being destroyed.\r\n   * We need to shutdown and then kill off all external references.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    this.shutdown();\n    this.scene.sys.events.off(SceneEvents.START, this.start, this);\n    this.scene = null;\n    this.systems = null;\n  }\n});\nPluginCache.register('ArcadePhysics', ArcadePhysics, 'arcadePhysics');\nmodule.exports = ArcadePhysics;","map":null,"metadata":{},"sourceType":"script"}