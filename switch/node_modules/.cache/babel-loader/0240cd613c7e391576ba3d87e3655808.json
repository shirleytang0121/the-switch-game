{"ast":null,"code":"/**\r\n* The `Matter.Composites` module contains factory methods for creating composite bodies\r\n* with commonly used configurations (such as stacks and chains).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Composites\r\n*/\nvar Composites = {};\nmodule.exports = Composites;\n\nvar Composite = require('../body/Composite');\n\nvar Constraint = require('../constraint/Constraint');\n\nvar Common = require('../core/Common');\n\nvar Body = require('../body/Body');\n\nvar Bodies = require('./Bodies');\n\n(function () {\n  /**\r\n   * Create a new composite containing bodies created in the callback in a grid arrangement.\r\n   * This function uses the body's bounds to prevent overlaps.\r\n   * @method stack\r\n   * @param {number} xx\r\n   * @param {number} yy\r\n   * @param {number} columns\r\n   * @param {number} rows\r\n   * @param {number} columnGap\r\n   * @param {number} rowGap\r\n   * @param {function} callback\r\n   * @return {composite} A new composite containing objects created in the callback\r\n   */\n  Composites.stack = function (xx, yy, columns, rows, columnGap, rowGap, callback) {\n    var stack = Composite.create({\n      label: 'Stack'\n    }),\n        x = xx,\n        y = yy,\n        lastBody,\n        i = 0;\n\n    for (var row = 0; row < rows; row++) {\n      var maxHeight = 0;\n\n      for (var column = 0; column < columns; column++) {\n        var body = callback(x, y, column, row, lastBody, i);\n\n        if (body) {\n          var bodyHeight = body.bounds.max.y - body.bounds.min.y,\n              bodyWidth = body.bounds.max.x - body.bounds.min.x;\n          if (bodyHeight > maxHeight) maxHeight = bodyHeight;\n          Body.translate(body, {\n            x: bodyWidth * 0.5,\n            y: bodyHeight * 0.5\n          });\n          x = body.bounds.max.x + columnGap;\n          Composite.addBody(stack, body);\n          lastBody = body;\n          i += 1;\n        } else {\n          x += columnGap;\n        }\n      }\n\n      y += maxHeight + rowGap;\n      x = xx;\n    }\n\n    return stack;\n  };\n  /**\r\n   * Chains all bodies in the given composite together using constraints.\r\n   * @method chain\r\n   * @param {composite} composite\r\n   * @param {number} xOffsetA\r\n   * @param {number} yOffsetA\r\n   * @param {number} xOffsetB\r\n   * @param {number} yOffsetB\r\n   * @param {object} options\r\n   * @return {composite} A new composite containing objects chained together with constraints\r\n   */\n\n\n  Composites.chain = function (composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {\n    var bodies = composite.bodies;\n\n    for (var i = 1; i < bodies.length; i++) {\n      var bodyA = bodies[i - 1],\n          bodyB = bodies[i],\n          bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y,\n          bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x,\n          bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y,\n          bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;\n      var defaults = {\n        bodyA: bodyA,\n        pointA: {\n          x: bodyAWidth * xOffsetA,\n          y: bodyAHeight * yOffsetA\n        },\n        bodyB: bodyB,\n        pointB: {\n          x: bodyBWidth * xOffsetB,\n          y: bodyBHeight * yOffsetB\n        }\n      };\n      var constraint = Common.extend(defaults, options);\n      Composite.addConstraint(composite, Constraint.create(constraint));\n    }\n\n    composite.label += ' Chain';\n    return composite;\n  };\n  /**\r\n   * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.\r\n   * @method mesh\r\n   * @param {composite} composite\r\n   * @param {number} columns\r\n   * @param {number} rows\r\n   * @param {boolean} crossBrace\r\n   * @param {object} options\r\n   * @return {composite} The composite containing objects meshed together with constraints\r\n   */\n\n\n  Composites.mesh = function (composite, columns, rows, crossBrace, options) {\n    var bodies = composite.bodies,\n        row,\n        col,\n        bodyA,\n        bodyB,\n        bodyC;\n\n    for (row = 0; row < rows; row++) {\n      for (col = 1; col < columns; col++) {\n        bodyA = bodies[col - 1 + row * columns];\n        bodyB = bodies[col + row * columns];\n        Composite.addConstraint(composite, Constraint.create(Common.extend({\n          bodyA: bodyA,\n          bodyB: bodyB\n        }, options)));\n      }\n\n      if (row > 0) {\n        for (col = 0; col < columns; col++) {\n          bodyA = bodies[col + (row - 1) * columns];\n          bodyB = bodies[col + row * columns];\n          Composite.addConstraint(composite, Constraint.create(Common.extend({\n            bodyA: bodyA,\n            bodyB: bodyB\n          }, options)));\n\n          if (crossBrace && col > 0) {\n            bodyC = bodies[col - 1 + (row - 1) * columns];\n            Composite.addConstraint(composite, Constraint.create(Common.extend({\n              bodyA: bodyC,\n              bodyB: bodyB\n            }, options)));\n          }\n\n          if (crossBrace && col < columns - 1) {\n            bodyC = bodies[col + 1 + (row - 1) * columns];\n            Composite.addConstraint(composite, Constraint.create(Common.extend({\n              bodyA: bodyC,\n              bodyB: bodyB\n            }, options)));\n          }\n        }\n      }\n    }\n\n    composite.label += ' Mesh';\n    return composite;\n  };\n  /**\r\n   * Create a new composite containing bodies created in the callback in a pyramid arrangement.\r\n   * This function uses the body's bounds to prevent overlaps.\r\n   * @method pyramid\r\n   * @param {number} xx\r\n   * @param {number} yy\r\n   * @param {number} columns\r\n   * @param {number} rows\r\n   * @param {number} columnGap\r\n   * @param {number} rowGap\r\n   * @param {function} callback\r\n   * @return {composite} A new composite containing objects created in the callback\r\n   */\n\n\n  Composites.pyramid = function (xx, yy, columns, rows, columnGap, rowGap, callback) {\n    return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function (x, y, column, row, lastBody, i) {\n      var actualRows = Math.min(rows, Math.ceil(columns / 2)),\n          lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;\n      if (row > actualRows) return; // reverse row order\n\n      row = actualRows - row;\n      var start = row,\n          end = columns - 1 - row;\n      if (column < start || column > end) return; // retroactively fix the first body's position, since width was unknown\n\n      if (i === 1) {\n        Body.translate(lastBody, {\n          x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth,\n          y: 0\n        });\n      }\n\n      var xOffset = lastBody ? column * lastBodyWidth : 0;\n      return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);\n    });\n  };\n  /**\r\n   * Creates a composite with a Newton's Cradle setup of bodies and constraints.\r\n   * @method newtonsCradle\r\n   * @param {number} xx\r\n   * @param {number} yy\r\n   * @param {number} number\r\n   * @param {number} size\r\n   * @param {number} length\r\n   * @return {composite} A new composite newtonsCradle body\r\n   */\n\n\n  Composites.newtonsCradle = function (xx, yy, number, size, length) {\n    var newtonsCradle = Composite.create({\n      label: 'Newtons Cradle'\n    });\n\n    for (var i = 0; i < number; i++) {\n      var separation = 1.9,\n          circle = Bodies.circle(xx + i * (size * separation), yy + length, size, {\n        inertia: Infinity,\n        restitution: 1,\n        friction: 0,\n        frictionAir: 0.0001,\n        slop: 1\n      }),\n          constraint = Constraint.create({\n        pointA: {\n          x: xx + i * (size * separation),\n          y: yy\n        },\n        bodyB: circle\n      });\n      Composite.addBody(newtonsCradle, circle);\n      Composite.addConstraint(newtonsCradle, constraint);\n    }\n\n    return newtonsCradle;\n  };\n  /**\r\n   * Creates a composite with simple car setup of bodies and constraints.\r\n   * @method car\r\n   * @param {number} xx\r\n   * @param {number} yy\r\n   * @param {number} width\r\n   * @param {number} height\r\n   * @param {number} wheelSize\r\n   * @return {composite} A new composite car body\r\n   */\n\n\n  Composites.car = function (xx, yy, width, height, wheelSize) {\n    var group = Body.nextGroup(true),\n        wheelBase = 20,\n        wheelAOffset = -width * 0.5 + wheelBase,\n        wheelBOffset = width * 0.5 - wheelBase,\n        wheelYOffset = 0;\n    var car = Composite.create({\n      label: 'Car'\n    }),\n        body = Bodies.rectangle(xx, yy, width, height, {\n      collisionFilter: {\n        group: group\n      },\n      chamfer: {\n        radius: height * 0.5\n      },\n      density: 0.0002\n    });\n    var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, {\n      collisionFilter: {\n        group: group\n      },\n      friction: 0.8\n    });\n    var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, {\n      collisionFilter: {\n        group: group\n      },\n      friction: 0.8\n    });\n    var axelA = Constraint.create({\n      bodyB: body,\n      pointB: {\n        x: wheelAOffset,\n        y: wheelYOffset\n      },\n      bodyA: wheelA,\n      stiffness: 1,\n      length: 0\n    });\n    var axelB = Constraint.create({\n      bodyB: body,\n      pointB: {\n        x: wheelBOffset,\n        y: wheelYOffset\n      },\n      bodyA: wheelB,\n      stiffness: 1,\n      length: 0\n    });\n    Composite.addBody(car, body);\n    Composite.addBody(car, wheelA);\n    Composite.addBody(car, wheelB);\n    Composite.addConstraint(car, axelA);\n    Composite.addConstraint(car, axelB);\n    return car;\n  };\n  /**\r\n   * Creates a simple soft body like object.\r\n   * @method softBody\r\n   * @param {number} xx\r\n   * @param {number} yy\r\n   * @param {number} columns\r\n   * @param {number} rows\r\n   * @param {number} columnGap\r\n   * @param {number} rowGap\r\n   * @param {boolean} crossBrace\r\n   * @param {number} particleRadius\r\n   * @param {} particleOptions\r\n   * @param {} constraintOptions\r\n   * @return {composite} A new composite softBody\r\n   */\n\n\n  Composites.softBody = function (xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {\n    particleOptions = Common.extend({\n      inertia: Infinity\n    }, particleOptions);\n    constraintOptions = Common.extend({\n      stiffness: 0.2,\n      render: {\n        type: 'line',\n        anchors: false\n      }\n    }, constraintOptions);\n    var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function (x, y) {\n      return Bodies.circle(x, y, particleRadius, particleOptions);\n    });\n    Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);\n    softBody.label = 'Soft Body';\n    return softBody;\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}