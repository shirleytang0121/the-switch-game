{"ast":null,"code":"/**\r\n * Copyright (c) 2016, Lee Byron\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @ignore\r\n */\n\n/**\r\n * [Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator)\r\n * is a *protocol* which describes a standard way to produce a sequence of\r\n * values, typically the values of the Iterable represented by this Iterator.\r\n *\r\n * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterator-interface)\r\n * it can be utilized by any version of JavaScript.\r\n *\r\n * @external Iterator\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator|MDN Iteration protocols}\r\n */\n\n/**\r\n * [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\r\n * is a *protocol* which when implemented allows a JavaScript object to define\r\n * their iteration behavior, such as what values are looped over in a\r\n * [`for...of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)\r\n * loop or `iterall`'s `forEach` function. Many [built-in types](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#Builtin_iterables)\r\n * implement the Iterable protocol, including `Array` and `Map`.\r\n *\r\n * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterable-interface)\r\n * it can be utilized by any version of JavaScript.\r\n *\r\n * @external Iterable\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable|MDN Iteration protocols}\r\n */\n// In ES2015 (or a polyfilled) environment, this will be Symbol.iterator\nvar SYMBOL_ITERATOR = typeof Symbol === 'function' && Symbol.iterator;\n/**\r\n * A property name to be used as the name of an Iterable's method responsible\r\n * for producing an Iterator, referred to as `@@iterator`. Typically represents\r\n * the value `Symbol.iterator` but falls back to the string `\"@@iterator\"` when\r\n * `Symbol.iterator` is not defined.\r\n *\r\n * Use `$$iterator` for defining new Iterables instead of `Symbol.iterator`,\r\n * but do not use it for accessing existing Iterables, instead use\r\n * {@link getIterator} or {@link isIterable}.\r\n *\r\n * @example\r\n *\r\n * var $$iterator = require('iterall').$$iterator\r\n *\r\n * function Counter (to) {\r\n *   this.to = to\r\n * }\r\n *\r\n * Counter.prototype[$$iterator] = function () {\r\n *   return {\r\n *     to: this.to,\r\n *     num: 0,\r\n *     next () {\r\n *       if (this.num >= this.to) {\r\n *         return { value: undefined, done: true }\r\n *       }\r\n *       return { value: this.num++, done: false }\r\n *     }\r\n *   }\r\n * }\r\n *\r\n * var counter = new Counter(3)\r\n * for (var number of counter) {\r\n *   console.log(number) // 0 ... 1 ... 2\r\n * }\r\n *\r\n * @type {Symbol|string}\r\n */\n\nvar $$iterator = SYMBOL_ITERATOR || '@@iterator';\nexports.$$iterator = $$iterator;\n/**\r\n * Returns true if the provided object implements the Iterator protocol via\r\n * either implementing a `Symbol.iterator` or `\"@@iterator\"` method.\r\n *\r\n * @example\r\n *\r\n * var isIterable = require('iterall').isIterable\r\n * isIterable([ 1, 2, 3 ]) // true\r\n * isIterable('ABC') // true\r\n * isIterable({ length: 1, 0: 'Alpha' }) // false\r\n * isIterable({ key: 'value' }) // false\r\n * isIterable(new Map()) // true\r\n *\r\n * @param obj\r\n *   A value which might implement the Iterable protocol.\r\n * @return {boolean} true if Iterable.\r\n */\n\nfunction isIterable(obj) {\n  return !!getIteratorMethod(obj);\n}\n\nexports.isIterable = isIterable;\n/**\r\n * Returns true if the provided object implements the Array-like protocol via\r\n * defining a positive-integer `length` property.\r\n *\r\n * @example\r\n *\r\n * var isArrayLike = require('iterall').isArrayLike\r\n * isArrayLike([ 1, 2, 3 ]) // true\r\n * isArrayLike('ABC') // true\r\n * isArrayLike({ length: 1, 0: 'Alpha' }) // true\r\n * isArrayLike({ key: 'value' }) // false\r\n * isArrayLike(new Map()) // false\r\n *\r\n * @param obj\r\n *   A value which might implement the Array-like protocol.\r\n * @return {boolean} true if Array-like.\r\n */\n\nfunction isArrayLike(obj) {\n  var length = obj != null && obj.length;\n  return typeof length === 'number' && length >= 0 && length % 1 === 0;\n}\n\nexports.isArrayLike = isArrayLike;\n/**\r\n * Returns true if the provided object is an Object (i.e. not a string literal)\r\n * and is either Iterable or Array-like.\r\n *\r\n * This may be used in place of [Array.isArray()][isArray] to determine if an\r\n * object should be iterated-over. It always excludes string literals and\r\n * includes Arrays (regardless of if it is Iterable). It also includes other\r\n * Array-like objects such as NodeList, TypedArray, and Buffer.\r\n *\r\n * @example\r\n *\r\n * var isCollection = require('iterall').isCollection\r\n * isCollection([ 1, 2, 3 ]) // true\r\n * isCollection('ABC') // false\r\n * isCollection({ length: 1, 0: 'Alpha' }) // true\r\n * isCollection({ key: 'value' }) // false\r\n * isCollection(new Map()) // true\r\n *\r\n * @example\r\n *\r\n * var forEach = require('iterall').forEach\r\n * if (isCollection(obj)) {\r\n *   forEach(obj, function (value) {\r\n *     console.log(value)\r\n *   })\r\n * }\r\n *\r\n * @param obj\r\n *   An Object value which might implement the Iterable or Array-like protocols.\r\n * @return {boolean} true if Iterable or Array-like Object.\r\n */\n\nfunction isCollection(obj) {\n  return Object(obj) === obj && (isArrayLike(obj) || isIterable(obj));\n}\n\nexports.isCollection = isCollection;\n/**\r\n * If the provided object implements the Iterator protocol, its Iterator object\r\n * is returned. Otherwise returns undefined.\r\n *\r\n * @example\r\n *\r\n * var getIterator = require('iterall').getIterator\r\n * var iterator = getIterator([ 1, 2, 3 ])\r\n * iterator.next() // { value: 1, done: false }\r\n * iterator.next() // { value: 2, done: false }\r\n * iterator.next() // { value: 3, done: false }\r\n * iterator.next() // { value: undefined, done: true }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {Iterable<T>} iterable\r\n *   An Iterable object which is the source of an Iterator.\r\n * @return {Iterator<T>} new Iterator instance.\r\n */\n\nfunction getIterator(iterable) {\n  var method = getIteratorMethod(iterable);\n\n  if (method) {\n    return method.call(iterable);\n  }\n}\n\nexports.getIterator = getIterator;\n/**\r\n * If the provided object implements the Iterator protocol, the method\r\n * responsible for producing its Iterator object is returned.\r\n *\r\n * This is used in rare cases for performance tuning. This method must be called\r\n * with obj as the contextual this-argument.\r\n *\r\n * @example\r\n *\r\n * var getIteratorMethod = require('iterall').getIteratorMethod\r\n * var myArray = [ 1, 2, 3 ]\r\n * var method = getIteratorMethod(myArray)\r\n * if (method) {\r\n *   var iterator = method.call(myArray)\r\n * }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {Iterable<T>} iterable\r\n *   An Iterable object which defines an `@@iterator` method.\r\n * @return {function(): Iterator<T>} `@@iterator` method.\r\n */\n\nfunction getIteratorMethod(iterable) {\n  if (iterable != null) {\n    var method = SYMBOL_ITERATOR && iterable[SYMBOL_ITERATOR] || iterable['@@iterator'];\n\n    if (typeof method === 'function') {\n      return method;\n    }\n  }\n}\n\nexports.getIteratorMethod = getIteratorMethod;\n/**\r\n * Similar to {@link getIterator}, this method returns a new Iterator given an\r\n * Iterable. However it will also create an Iterator for a non-Iterable\r\n * Array-like collection, such as Array in a non-ES2015 environment.\r\n *\r\n * `createIterator` is complimentary to `forEach`, but allows a \"pull\"-based\r\n * iteration as opposed to `forEach`'s \"push\"-based iteration.\r\n *\r\n * `createIterator` produces an Iterator for Array-likes with the same behavior\r\n * as ArrayIteratorPrototype described in the ECMAScript specification, and\r\n * does *not* skip over \"holes\".\r\n *\r\n * @example\r\n *\r\n * var createIterator = require('iterall').createIterator\r\n *\r\n * var myArraylike = { length: 3, 0: 'Alpha', 1: 'Bravo', 2: 'Charlie' }\r\n * var iterator = createIterator(myArraylike)\r\n * iterator.next() // { value: 'Alpha', done: false }\r\n * iterator.next() // { value: 'Bravo', done: false }\r\n * iterator.next() // { value: 'Charlie', done: false }\r\n * iterator.next() // { value: undefined, done: true }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {Iterable<T>|{ length: number }} collection\r\n *   An Iterable or Array-like object to produce an Iterator.\r\n * @return {Iterator<T>} new Iterator instance.\r\n */\n\nfunction createIterator(collection) {\n  if (collection != null) {\n    var iterator = getIterator(collection);\n\n    if (iterator) {\n      return iterator;\n    }\n\n    if (isArrayLike(collection)) {\n      return new ArrayLikeIterator(collection);\n    }\n  }\n}\n\nexports.createIterator = createIterator; // When the object provided to `createIterator` is not Iterable but is\n// Array-like, this simple Iterator is created.\n\nfunction ArrayLikeIterator(obj) {\n  this._o = obj;\n  this._i = 0;\n} // Note: all Iterators are themselves Iterable.\n\n\nArrayLikeIterator.prototype[$$iterator] = function () {\n  return this;\n}; // A simple state-machine determines the IteratorResult returned, yielding\n// each value in the Array-like object in order of their indicies.\n\n\nArrayLikeIterator.prototype.next = function () {\n  if (this._o === void 0 || this._i >= this._o.length) {\n    this._o = void 0;\n    return {\n      value: void 0,\n      done: true\n    };\n  }\n\n  return {\n    value: this._o[this._i++],\n    done: false\n  };\n};\n/**\r\n * Given an object which either implements the Iterable protocol or is\r\n * Array-like, iterate over it, calling the `callback` at each iteration.\r\n *\r\n * Use `forEach` where you would expect to use a `for ... of` loop in ES6.\r\n * However `forEach` adheres to the behavior of [Array#forEach][] described in\r\n * the ECMAScript specification, skipping over \"holes\" in Array-likes. It will\r\n * also delegate to a `forEach` method on `collection` if one is defined,\r\n * ensuring native performance for `Arrays`.\r\n *\r\n * Similar to [Array#forEach][], the `callback` function accepts three\r\n * arguments, and is provided with `thisArg` as the calling context.\r\n *\r\n * Note: providing an infinite Iterator to forEach will produce an error.\r\n *\r\n * [Array#forEach]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\r\n *\r\n * @example\r\n *\r\n * var forEach = require('iterall').forEach\r\n *\r\n * forEach(myIterable, function (value, index, iterable) {\r\n *   console.log(value, index, iterable === myIterable)\r\n * })\r\n *\r\n * @example\r\n *\r\n * // ES6:\r\n * for (let value of myIterable) {\r\n *   console.log(value)\r\n * }\r\n *\r\n * // Any JavaScript environment:\r\n * forEach(myIterable, function (value) {\r\n *   console.log(value)\r\n * })\r\n *\r\n * @template T the type of each iterated value\r\n * @param {Iterable<T>|{ length: number }} collection\r\n *   The Iterable or array to iterate over.\r\n * @param {function(T, number, object)} callback\r\n *   Function to execute for each iteration, taking up to three arguments\r\n * @param [thisArg]\r\n *   Optional. Value to use as `this` when executing `callback`.\r\n */\n\n\nfunction forEach(collection, callback, thisArg) {\n  if (collection != null) {\n    if (typeof collection.forEach === 'function') {\n      return collection.forEach(callback, thisArg);\n    }\n\n    var i = 0;\n    var iterator = getIterator(collection);\n\n    if (iterator) {\n      var step;\n\n      while (!(step = iterator.next()).done) {\n        callback.call(thisArg, step.value, i++, collection); // Infinite Iterators could cause forEach to run forever.\n        // After a very large number of iterations, produce an error.\n\n        /* istanbul ignore if */\n\n        if (i > 9999999) {\n          throw new TypeError('Near-infinite iteration.');\n        }\n      }\n    } else if (isArrayLike(collection)) {\n      for (; i < collection.length; i++) {\n        if (collection.hasOwnProperty(i)) {\n          callback.call(thisArg, collection[i], i, collection);\n        }\n      }\n    }\n  }\n}\n\nexports.forEach = forEach; /////////////////////////////////////////////////////\n//                                                 //\n//                 ASYNC ITERATORS                 //\n//                                                 //\n/////////////////////////////////////////////////////\n\n/**\r\n * [AsyncIterable](https://tc39.github.io/proposal-async-iteration/#sec-asynciterable-interface)\r\n * is a *protocol* which when implemented allows a JavaScript object to define\r\n * an asynchronous iteration behavior, such as what values are looped over in\r\n * a [`for-await-of`](https://tc39.github.io/proposal-async-iteration/#sec-for-in-and-for-of-statements)\r\n * loop or `iterall`'s {@link forAwaitEach} function.\r\n *\r\n * While described as a proposed addition to the [ES2017 version of JavaScript](https://tc39.github.io/proposal-async-iteration/)\r\n * it can be utilized by any version of JavaScript.\r\n *\r\n * @external AsyncIterable\r\n * @see {@link https://tc39.github.io/proposal-async-iteration/#sec-asynciterable-interface|Async Iteration Proposal}\r\n * @template T The type of each iterated value\r\n * @property {function (): AsyncIterator<T>} Symbol.asyncIterator\r\n *   A method which produces an AsyncIterator for this AsyncIterable.\r\n */\n\n/**\r\n * [AsyncIterator](https://tc39.github.io/proposal-async-iteration/#sec-asynciterator-interface)\r\n * is a *protocol* which describes a standard way to produce and consume an\r\n * asynchronous sequence of values, typically the values of the\r\n * {@link AsyncIterable} represented by this {@link AsyncIterator}.\r\n *\r\n * AsyncIterator is similar to Observable or Stream. Like an {@link Iterator} it\r\n * also as a `next()` method, however instead of an IteratorResult,\r\n * calling this method returns a {@link Promise} for a IteratorResult.\r\n *\r\n * While described as a proposed addition to the [ES2017 version of JavaScript](https://tc39.github.io/proposal-async-iteration/)\r\n * it can be utilized by any version of JavaScript.\r\n *\r\n * @external AsyncIterator\r\n * @see {@link https://tc39.github.io/proposal-async-iteration/#sec-asynciterator-interface|Async Iteration Proposal}\r\n */\n// In ES2017 (or a polyfilled) environment, this will be Symbol.asyncIterator\n\nvar SYMBOL_ASYNC_ITERATOR = typeof Symbol === 'function' && Symbol.asyncIterator;\n/**\r\n * A property name to be used as the name of an AsyncIterable's method\r\n * responsible for producing an Iterator, referred to as `@@asyncIterator`.\r\n * Typically represents the value `Symbol.asyncIterator` but falls back to the\r\n * string `\"@@asyncIterator\"` when `Symbol.asyncIterator` is not defined.\r\n *\r\n * Use `$$asyncIterator` for defining new AsyncIterables instead of\r\n * `Symbol.asyncIterator`, but do not use it for accessing existing Iterables,\r\n * instead use {@link getAsyncIterator} or {@link isAsyncIterable}.\r\n *\r\n * @example\r\n *\r\n * var $$asyncIterator = require('iterall').$$asyncIterator\r\n *\r\n * function Chirper (to) {\r\n *   this.to = to\r\n * }\r\n *\r\n * Chirper.prototype[$$asyncIterator] = function () {\r\n *   return {\r\n *     to: this.to,\r\n *     num: 0,\r\n *     next () {\r\n *       return new Promise(resolve => {\r\n *         if (this.num >= this.to) {\r\n *           resolve({ value: undefined, done: true })\r\n *         } else {\r\n *           setTimeout(() => {\r\n *             resolve({ value: this.num++, done: false })\r\n *           }, 1000)\r\n *         }\r\n *       })\r\n *     }\r\n *   }\r\n * }\r\n *\r\n * var chirper = new Chirper(3)\r\n * for await (var number of chirper) {\r\n *   console.log(number) // 0 ...wait... 1 ...wait... 2\r\n * }\r\n *\r\n * @type {Symbol|string}\r\n */\n\nvar $$asyncIterator = SYMBOL_ASYNC_ITERATOR || '@@asyncIterator';\nexports.$$asyncIterator = $$asyncIterator;\n/**\r\n * Returns true if the provided object implements the AsyncIterator protocol via\r\n * either implementing a `Symbol.asyncIterator` or `\"@@asyncIterator\"` method.\r\n *\r\n * @example\r\n *\r\n * var isAsyncIterable = require('iterall').isAsyncIterable\r\n * isAsyncIterable(myStream) // true\r\n * isAsyncIterable('ABC') // false\r\n *\r\n * @param obj\r\n *   A value which might implement the AsyncIterable protocol.\r\n * @return {boolean} true if AsyncIterable.\r\n */\n\nfunction isAsyncIterable(obj) {\n  return !!getAsyncIteratorMethod(obj);\n}\n\nexports.isAsyncIterable = isAsyncIterable;\n/**\r\n * If the provided object implements the AsyncIterator protocol, its\r\n * AsyncIterator object is returned. Otherwise returns undefined.\r\n *\r\n * @example\r\n *\r\n * var getAsyncIterator = require('iterall').getAsyncIterator\r\n * var asyncIterator = getAsyncIterator(myStream)\r\n * asyncIterator.next().then(console.log) // { value: 1, done: false }\r\n * asyncIterator.next().then(console.log) // { value: 2, done: false }\r\n * asyncIterator.next().then(console.log) // { value: 3, done: false }\r\n * asyncIterator.next().then(console.log) // { value: undefined, done: true }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {AsyncIterable<T>} asyncIterable\r\n *   An AsyncIterable object which is the source of an AsyncIterator.\r\n * @return {AsyncIterator<T>} new AsyncIterator instance.\r\n */\n\nfunction getAsyncIterator(asyncIterable) {\n  var method = getAsyncIteratorMethod(asyncIterable);\n\n  if (method) {\n    return method.call(asyncIterable);\n  }\n}\n\nexports.getAsyncIterator = getAsyncIterator;\n/**\r\n * If the provided object implements the AsyncIterator protocol, the method\r\n * responsible for producing its AsyncIterator object is returned.\r\n *\r\n * This is used in rare cases for performance tuning. This method must be called\r\n * with obj as the contextual this-argument.\r\n *\r\n * @example\r\n *\r\n * var getAsyncIteratorMethod = require('iterall').getAsyncIteratorMethod\r\n * var method = getAsyncIteratorMethod(myStream)\r\n * if (method) {\r\n *   var asyncIterator = method.call(myStream)\r\n * }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {AsyncIterable<T>} asyncIterable\r\n *   An AsyncIterable object which defines an `@@asyncIterator` method.\r\n * @return {function(): AsyncIterator<T>} `@@asyncIterator` method.\r\n */\n\nfunction getAsyncIteratorMethod(asyncIterable) {\n  if (asyncIterable != null) {\n    var method = SYMBOL_ASYNC_ITERATOR && asyncIterable[SYMBOL_ASYNC_ITERATOR] || asyncIterable['@@asyncIterator'];\n\n    if (typeof method === 'function') {\n      return method;\n    }\n  }\n}\n\nexports.getAsyncIteratorMethod = getAsyncIteratorMethod;\n/**\r\n * Similar to {@link getAsyncIterator}, this method returns a new AsyncIterator\r\n * given an AsyncIterable. However it will also create an AsyncIterator for a\r\n * non-async Iterable as well as non-Iterable Array-like collection, such as\r\n * Array in a pre-ES2015 environment.\r\n *\r\n * `createAsyncIterator` is complimentary to `forAwaitEach`, but allows a\r\n * buffering \"pull\"-based iteration as opposed to `forAwaitEach`'s\r\n * \"push\"-based iteration.\r\n *\r\n * `createAsyncIterator` produces an AsyncIterator for non-async Iterables as\r\n * described in the ECMAScript proposal [Async-from-Sync Iterator Objects](https://tc39.github.io/proposal-async-iteration/#sec-async-from-sync-iterator-objects).\r\n *\r\n * > Note: Creating `AsyncIterator`s requires the existence of `Promise`.\r\n * > While `Promise` has been available in modern browsers for a number of\r\n * > years, legacy browsers (like IE 11) may require a polyfill.\r\n *\r\n * @example\r\n *\r\n * var createAsyncIterator = require('iterall').createAsyncIterator\r\n *\r\n * var myArraylike = { length: 3, 0: 'Alpha', 1: 'Bravo', 2: 'Charlie' }\r\n * var iterator = createAsyncIterator(myArraylike)\r\n * iterator.next().then(console.log) // { value: 'Alpha', done: false }\r\n * iterator.next().then(console.log) // { value: 'Bravo', done: false }\r\n * iterator.next().then(console.log) // { value: 'Charlie', done: false }\r\n * iterator.next().then(console.log) // { value: undefined, done: true }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {AsyncIterable<T>|Iterable<T>|{ length: number }} source\r\n *   An AsyncIterable, Iterable, or Array-like object to produce an Iterator.\r\n * @return {AsyncIterator<T>} new AsyncIterator instance.\r\n */\n\nfunction createAsyncIterator(source) {\n  if (source != null) {\n    var asyncIterator = getAsyncIterator(source);\n\n    if (asyncIterator) {\n      return asyncIterator;\n    }\n\n    var iterator = createIterator(source);\n\n    if (iterator) {\n      return new AsyncFromSyncIterator(iterator);\n    }\n  }\n}\n\nexports.createAsyncIterator = createAsyncIterator; // When the object provided to `createAsyncIterator` is not AsyncIterable but is\n// sync Iterable, this simple wrapper is created.\n\nfunction AsyncFromSyncIterator(iterator) {\n  this._i = iterator;\n} // Note: all AsyncIterators are themselves AsyncIterable.\n\n\nAsyncFromSyncIterator.prototype[$$asyncIterator] = function () {\n  return this;\n}; // A simple state-machine determines the IteratorResult returned, yielding\n// each value in the Array-like object in order of their indicies.\n\n\nAsyncFromSyncIterator.prototype.next = function () {\n  var step = this._i.next();\n\n  return Promise.resolve(step.value).then(function (value) {\n    return {\n      value: value,\n      done: step.done\n    };\n  });\n};\n/**\r\n * Given an object which either implements the AsyncIterable protocol or is\r\n * Array-like, iterate over it, calling the `callback` at each iteration.\r\n *\r\n * Use `forAwaitEach` where you would expect to use a [for-await-of](https://tc39.github.io/proposal-async-iteration/#sec-for-in-and-for-of-statements) loop.\r\n *\r\n * Similar to [Array#forEach][], the `callback` function accepts three\r\n * arguments, and is provided with `thisArg` as the calling context.\r\n *\r\n * > Note: Using `forAwaitEach` requires the existence of `Promise`.\r\n * > While `Promise` has been available in modern browsers for a number of\r\n * > years, legacy browsers (like IE 11) may require a polyfill.\r\n *\r\n * @example\r\n *\r\n * var forAwaitEach = require('iterall').forAwaitEach\r\n *\r\n * forAwaitEach(myIterable, function (value, index, iterable) {\r\n *   console.log(value, index, iterable === myIterable)\r\n * })\r\n *\r\n * @example\r\n *\r\n * // ES2017:\r\n * for await (let value of myAsyncIterable) {\r\n *   console.log(await doSomethingAsync(value))\r\n * }\r\n * console.log('done')\r\n *\r\n * // Any JavaScript environment:\r\n * forAwaitEach(myAsyncIterable, function (value) {\r\n *   return doSomethingAsync(value).then(console.log)\r\n * }).then(function () {\r\n *   console.log('done')\r\n * })\r\n *\r\n * @template T the type of each iterated value\r\n * @param {AsyncIterable<T>|Iterable<Promise<T> | T>|{ length: number }} source\r\n *   The AsyncIterable or array to iterate over.\r\n * @param {function(T, number, object)} callback\r\n *   Function to execute for each iteration, taking up to three arguments\r\n * @param [thisArg]\r\n *   Optional. Value to use as `this` when executing `callback`.\r\n */\n\n\nfunction forAwaitEach(source, callback, thisArg) {\n  var asyncIterator = createAsyncIterator(source);\n\n  if (asyncIterator) {\n    var i = 0;\n    return new Promise(function (resolve, reject) {\n      function next() {\n        asyncIterator.next().then(function (step) {\n          if (!step.done) {\n            Promise.resolve(callback.call(thisArg, step.value, i++, source)).then(next).catch(reject);\n          } else {\n            resolve();\n          } // Explicitly return null, silencing bluebird-style warnings.\n\n\n          return null;\n        }).catch(reject); // Explicitly return null, silencing bluebird-style warnings.\n\n        return null;\n      }\n\n      next();\n    });\n  }\n}\n\nexports.forAwaitEach = forAwaitEach;","map":null,"metadata":{},"sourceType":"script"}