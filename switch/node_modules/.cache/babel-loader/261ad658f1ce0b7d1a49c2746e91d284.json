{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../../../utils/Class');\n\nvar ShaderSourceFS = require('../shaders/ForwardDiffuse-frag.js');\n\nvar TextureTintPipeline = require('./TextureTintPipeline');\n\nvar LIGHT_COUNT = 10;\n/**\r\n * @classdesc\r\n * ForwardDiffuseLightPipeline implements a forward rendering approach for 2D lights.\r\n * This pipeline extends TextureTintPipeline so it implements all it's rendering functions\r\n * and batching system.\r\n *\r\n * @class ForwardDiffuseLightPipeline\r\n * @extends Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline\r\n * @memberof Phaser.Renderer.WebGL.Pipelines\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The configuration of the pipeline, same as the {@link Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline}. The fragment shader will be replaced with the lighting shader.\r\n */\n\nvar ForwardDiffuseLightPipeline = new Class({\n  Extends: TextureTintPipeline,\n  initialize: function ForwardDiffuseLightPipeline(config) {\n    LIGHT_COUNT = config.maxLights;\n    config.fragShader = ShaderSourceFS.replace('%LIGHT_COUNT%', LIGHT_COUNT.toString());\n    TextureTintPipeline.call(this, config);\n    /**\r\n     * Default normal map texture to use.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#defaultNormalMap\r\n     * @type {Phaser.Texture.Frame}\r\n     * @private\r\n     * @since 3.11.0\r\n     */\n\n    this.defaultNormalMap;\n    /**\r\n     * Inverse rotation matrix for normal map rotations.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#inverseRotationMatrix\r\n     * @type {Float32Array}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this.inverseRotationMatrix = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n  },\n\n  /**\r\n   * Called when the Game has fully booted and the Renderer has finished setting up.\r\n   * \r\n   * By this stage all Game level systems are now in place and you can perform any final\r\n   * tasks that the pipeline may need that relied on game systems such as the Texture Manager.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#boot\r\n   * @override\r\n   * @since 3.11.0\r\n   */\n  boot: function boot() {\n    this.defaultNormalMap = this.game.textures.getFrame('__DEFAULT');\n  },\n\n  /**\r\n   * This function binds its base class resources and this lights 2D resources.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#onBind\r\n   * @override\r\n   * @since 3.0.0\r\n   * \r\n   * @param {Phaser.GameObjects.GameObject} [gameObject] - The Game Object that invoked this pipeline, if any.\r\n   *\r\n   * @return {this} This WebGLPipeline instance.\r\n   */\n  onBind: function onBind(gameObject) {\n    TextureTintPipeline.prototype.onBind.call(this);\n    var renderer = this.renderer;\n    var program = this.program;\n    this.mvpUpdate();\n    renderer.setInt1(program, 'uNormSampler', 1);\n    renderer.setFloat2(program, 'uResolution', this.width, this.height);\n\n    if (gameObject) {\n      this.setNormalMap(gameObject);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * This function sets all the needed resources for each camera pass.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#onRender\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Scene} scene - The Scene being rendered.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera being rendered with.\r\n   *\r\n   * @return {this} This WebGLPipeline instance.\r\n   */\n  onRender: function onRender(scene, camera) {\n    this.active = false;\n    var lightManager = scene.sys.lights;\n\n    if (!lightManager || lightManager.lights.length <= 0 || !lightManager.active) {\n      //  Passthru\n      return this;\n    }\n\n    var lights = lightManager.cull(camera);\n    var lightCount = Math.min(lights.length, LIGHT_COUNT);\n\n    if (lightCount === 0) {\n      return this;\n    }\n\n    this.active = true;\n    var renderer = this.renderer;\n    var program = this.program;\n    var cameraMatrix = camera.matrix;\n    var point = {\n      x: 0,\n      y: 0\n    };\n    var height = renderer.height;\n    var index;\n\n    for (index = 0; index < LIGHT_COUNT; ++index) {\n      //  Reset lights\n      renderer.setFloat1(program, 'uLights[' + index + '].radius', 0);\n    }\n\n    renderer.setFloat4(program, 'uCamera', camera.x, camera.y, camera.rotation, camera.zoom);\n    renderer.setFloat3(program, 'uAmbientLightColor', lightManager.ambientColor.r, lightManager.ambientColor.g, lightManager.ambientColor.b);\n\n    for (index = 0; index < lightCount; ++index) {\n      var light = lights[index];\n      var lightName = 'uLights[' + index + '].';\n      cameraMatrix.transformPoint(light.x, light.y, point);\n      renderer.setFloat2(program, lightName + 'position', point.x - camera.scrollX * light.scrollFactorX * camera.zoom, height - (point.y - camera.scrollY * light.scrollFactorY * camera.zoom));\n      renderer.setFloat3(program, lightName + 'color', light.r, light.g, light.b);\n      renderer.setFloat1(program, lightName + 'intensity', light.intensity);\n      renderer.setFloat1(program, lightName + 'radius', light.radius);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Generic function for batching a textured quad\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#batchTexture\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - Source GameObject\r\n   * @param {WebGLTexture} texture - Raw WebGLTexture associated with the quad\r\n   * @param {integer} textureWidth - Real texture width\r\n   * @param {integer} textureHeight - Real texture height\r\n   * @param {number} srcX - X coordinate of the quad\r\n   * @param {number} srcY - Y coordinate of the quad\r\n   * @param {number} srcWidth - Width of the quad\r\n   * @param {number} srcHeight - Height of the quad\r\n   * @param {number} scaleX - X component of scale\r\n   * @param {number} scaleY - Y component of scale\r\n   * @param {number} rotation - Rotation of the quad\r\n   * @param {boolean} flipX - Indicates if the quad is horizontally flipped\r\n   * @param {boolean} flipY - Indicates if the quad is vertically flipped\r\n   * @param {number} scrollFactorX - By which factor is the quad affected by the camera horizontal scroll\r\n   * @param {number} scrollFactorY - By which factor is the quad effected by the camera vertical scroll\r\n   * @param {number} displayOriginX - Horizontal origin in pixels\r\n   * @param {number} displayOriginY - Vertical origin in pixels\r\n   * @param {number} frameX - X coordinate of the texture frame\r\n   * @param {number} frameY - Y coordinate of the texture frame\r\n   * @param {number} frameWidth - Width of the texture frame\r\n   * @param {number} frameHeight - Height of the texture frame\r\n   * @param {integer} tintTL - Tint for top left\r\n   * @param {integer} tintTR - Tint for top right\r\n   * @param {integer} tintBL - Tint for bottom left\r\n   * @param {integer} tintBR - Tint for bottom right\r\n   * @param {number} tintEffect - The tint effect (0 for additive, 1 for replacement)\r\n   * @param {number} uOffset - Horizontal offset on texture coordinate\r\n   * @param {number} vOffset - Vertical offset on texture coordinate\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - Current used camera\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - Parent container\r\n   */\n  batchTexture: function batchTexture(gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix) {\n    if (!this.active) {\n      return;\n    }\n\n    this.renderer.setPipeline(this);\n    var normalTexture;\n\n    if (gameObject.displayTexture) {\n      normalTexture = gameObject.displayTexture.dataSource[gameObject.displayFrame.sourceIndex];\n    } else if (gameObject.texture) {\n      normalTexture = gameObject.texture.dataSource[gameObject.frame.sourceIndex];\n    } else if (gameObject.tileset) {\n      normalTexture = gameObject.tileset.image.dataSource[0];\n    }\n\n    if (!normalTexture) {\n      console.warn('Normal map missing or invalid');\n      return;\n    }\n\n    this.setTexture2D(normalTexture.glTexture, 1);\n    this.setNormalMapRotation(rotation);\n    var camMatrix = this._tempMatrix1;\n    var spriteMatrix = this._tempMatrix2;\n    var calcMatrix = this._tempMatrix3;\n    var u0 = frameX / textureWidth + uOffset;\n    var v0 = frameY / textureHeight + vOffset;\n    var u1 = (frameX + frameWidth) / textureWidth + uOffset;\n    var v1 = (frameY + frameHeight) / textureHeight + vOffset;\n    var width = srcWidth;\n    var height = srcHeight; // var x = -displayOriginX + frameX;\n    // var y = -displayOriginY + frameY;\n\n    var x = -displayOriginX;\n    var y = -displayOriginY;\n\n    if (gameObject.isCropped) {\n      var crop = gameObject._crop;\n      width = crop.width;\n      height = crop.height;\n      srcWidth = crop.width;\n      srcHeight = crop.height;\n      frameX = crop.x;\n      frameY = crop.y;\n      var ox = frameX;\n      var oy = frameY;\n\n      if (flipX) {\n        ox = frameWidth - crop.x - crop.width;\n      }\n\n      if (flipY && !texture.isRenderTexture) {\n        oy = frameHeight - crop.y - crop.height;\n      }\n\n      u0 = ox / textureWidth + uOffset;\n      v0 = oy / textureHeight + vOffset;\n      u1 = (ox + crop.width) / textureWidth + uOffset;\n      v1 = (oy + crop.height) / textureHeight + vOffset;\n      x = -displayOriginX + frameX;\n      y = -displayOriginY + frameY;\n    } //  Invert the flipY if this is a RenderTexture\n\n\n    flipY = flipY ^ (texture.isRenderTexture ? 1 : 0);\n\n    if (flipX) {\n      width *= -1;\n      x += srcWidth;\n    }\n\n    if (flipY) {\n      height *= -1;\n      y += srcHeight;\n    } //  Do we need this? (doubt it)\n    // if (camera.roundPixels)\n    // {\n    //     x |= 0;\n    //     y |= 0;\n    // }\n\n\n    var xw = x + width;\n    var yh = y + height;\n    spriteMatrix.applyITRS(srcX, srcY, rotation, scaleX, scaleY);\n    camMatrix.copyFrom(camera.matrix);\n\n    if (parentTransformMatrix) {\n      //  Multiply the camera by the parent matrix\n      camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY); //  Undo the camera scroll\n\n      spriteMatrix.e = srcX;\n      spriteMatrix.f = srcY; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n      camMatrix.multiply(spriteMatrix, calcMatrix);\n    } else {\n      spriteMatrix.e -= camera.scrollX * scrollFactorX;\n      spriteMatrix.f -= camera.scrollY * scrollFactorY; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n      camMatrix.multiply(spriteMatrix, calcMatrix);\n    }\n\n    var tx0 = calcMatrix.getX(x, y);\n    var ty0 = calcMatrix.getY(x, y);\n    var tx1 = calcMatrix.getX(x, yh);\n    var ty1 = calcMatrix.getY(x, yh);\n    var tx2 = calcMatrix.getX(xw, yh);\n    var ty2 = calcMatrix.getY(xw, yh);\n    var tx3 = calcMatrix.getX(xw, y);\n    var ty3 = calcMatrix.getY(xw, y);\n\n    if (camera.roundPixels) {\n      tx0 = Math.round(tx0);\n      ty0 = Math.round(ty0);\n      tx1 = Math.round(tx1);\n      ty1 = Math.round(ty1);\n      tx2 = Math.round(tx2);\n      ty2 = Math.round(ty2);\n      tx3 = Math.round(tx3);\n      ty3 = Math.round(ty3);\n    }\n\n    this.setTexture2D(texture, 0);\n    this.batchQuad(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, 0);\n  },\n\n  /**\r\n   * Sets the Game Objects normal map as the active texture.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#setNormalMap\r\n   * @since 3.11.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to update.\r\n   */\n  setNormalMap: function setNormalMap(gameObject) {\n    if (!this.active || !gameObject) {\n      return;\n    }\n\n    var normalTexture;\n\n    if (gameObject.texture) {\n      normalTexture = gameObject.texture.dataSource[gameObject.frame.sourceIndex];\n    }\n\n    if (!normalTexture) {\n      normalTexture = this.defaultNormalMap;\n    }\n\n    this.setTexture2D(normalTexture.glTexture, 1);\n    this.renderer.setPipeline(gameObject.defaultPipeline);\n  },\n\n  /**\r\n   * Rotates the normal map vectors inversely by the given angle.\r\n   * Only works in 2D space.\r\n   * \r\n   * @method Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#setNormalMapRotation\r\n   * @since 3.16.0\r\n   * \r\n   * @param {number} rotation - The angle of rotation in radians.\r\n   */\n  setNormalMapRotation: function setNormalMapRotation(rotation) {\n    var inverseRotationMatrix = this.inverseRotationMatrix;\n\n    if (rotation) {\n      var rot = -rotation;\n      var c = Math.cos(rot);\n      var s = Math.sin(rot);\n      inverseRotationMatrix[1] = s;\n      inverseRotationMatrix[3] = -s;\n      inverseRotationMatrix[0] = inverseRotationMatrix[4] = c;\n    } else {\n      inverseRotationMatrix[0] = inverseRotationMatrix[4] = 1;\n      inverseRotationMatrix[1] = inverseRotationMatrix[3] = 0;\n    }\n\n    this.renderer.setMatrix3(this.program, 'uInverseRotationMatrix', false, inverseRotationMatrix);\n  },\n\n  /**\r\n   * Takes a Sprite Game Object, or any object that extends it, which has a normal texture and adds it to the batch.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline#batchSprite\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Sprite} sprite - The texture-based Game Object to add to the batch.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use for the rendering transform.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - The transform matrix of the parent container, if set.\r\n   */\n  batchSprite: function batchSprite(sprite, camera, parentTransformMatrix) {\n    if (!this.active) {\n      return;\n    }\n\n    var normalTexture = sprite.texture.dataSource[sprite.frame.sourceIndex];\n\n    if (normalTexture) {\n      this.renderer.setPipeline(this);\n      this.setTexture2D(normalTexture.glTexture, 1);\n      this.setNormalMapRotation(sprite.rotation);\n      TextureTintPipeline.prototype.batchSprite.call(this, sprite, camera, parentTransformMatrix);\n    }\n  }\n});\nForwardDiffuseLightPipeline.LIGHT_COUNT = LIGHT_COUNT;\nmodule.exports = ForwardDiffuseLightPipeline;","map":null,"metadata":{},"sourceType":"script"}