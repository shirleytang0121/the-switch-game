{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../../../utils/Class');\n\nvar Earcut = require('../../../geom/polygon/Earcut');\n\nvar GetFastValue = require('../../../utils/object/GetFastValue');\n\nvar ModelViewProjection = require('./components/ModelViewProjection');\n\nvar ShaderSourceFS = require('../shaders/TextureTint-frag.js');\n\nvar ShaderSourceVS = require('../shaders/TextureTint-vert.js');\n\nvar TransformMatrix = require('../../../gameobjects/components/TransformMatrix');\n\nvar Utils = require('../Utils');\n\nvar WebGLPipeline = require('../WebGLPipeline');\n/**\r\n * @classdesc\r\n * TextureTintPipeline implements the rendering infrastructure\r\n * for displaying textured objects\r\n * The config properties are:\r\n * - game: Current game instance.\r\n * - renderer: Current WebGL renderer.\r\n * - topology: This indicates how the primitives are rendered. The default value is GL_TRIANGLES.\r\n *              Here is the full list of rendering primitives (https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants).\r\n * - vertShader: Source for vertex shader as a string.\r\n * - fragShader: Source for fragment shader as a string.\r\n * - vertexCapacity: The amount of vertices that shall be allocated\r\n * - vertexSize: The size of a single vertex in bytes.\r\n *\r\n * @class TextureTintPipeline\r\n * @extends Phaser.Renderer.WebGL.WebGLPipeline\r\n * @memberof Phaser.Renderer.WebGL.Pipelines\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The configuration options for this Texture Tint Pipeline, as described above.\r\n */\n\n\nvar TextureTintPipeline = new Class({\n  Extends: WebGLPipeline,\n  Mixins: [ModelViewProjection],\n  initialize: function TextureTintPipeline(config) {\n    var rendererConfig = config.renderer.config; //  Vertex Size = attribute size added together (2 + 2 + 1 + 4)\n\n    WebGLPipeline.call(this, {\n      game: config.game,\n      renderer: config.renderer,\n      gl: config.renderer.gl,\n      topology: GetFastValue(config, 'topology', config.renderer.gl.TRIANGLES),\n      vertShader: GetFastValue(config, 'vertShader', ShaderSourceVS),\n      fragShader: GetFastValue(config, 'fragShader', ShaderSourceFS),\n      vertexCapacity: GetFastValue(config, 'vertexCapacity', 6 * rendererConfig.batchSize),\n      vertexSize: GetFastValue(config, 'vertexSize', Float32Array.BYTES_PER_ELEMENT * 5 + Uint8Array.BYTES_PER_ELEMENT * 4),\n      attributes: [{\n        name: 'inPosition',\n        size: 2,\n        type: config.renderer.gl.FLOAT,\n        normalized: false,\n        offset: 0\n      }, {\n        name: 'inTexCoord',\n        size: 2,\n        type: config.renderer.gl.FLOAT,\n        normalized: false,\n        offset: Float32Array.BYTES_PER_ELEMENT * 2\n      }, {\n        name: 'inTintEffect',\n        size: 1,\n        type: config.renderer.gl.FLOAT,\n        normalized: false,\n        offset: Float32Array.BYTES_PER_ELEMENT * 4\n      }, {\n        name: 'inTint',\n        size: 4,\n        type: config.renderer.gl.UNSIGNED_BYTE,\n        normalized: true,\n        offset: Float32Array.BYTES_PER_ELEMENT * 5\n      }]\n    });\n    /**\r\n     * Float32 view of the array buffer containing the pipeline's vertices.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#vertexViewF32\r\n     * @type {Float32Array}\r\n     * @since 3.0.0\r\n     */\n\n    this.vertexViewF32 = new Float32Array(this.vertexData);\n    /**\r\n     * Uint32 view of the array buffer containing the pipeline's vertices.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#vertexViewU32\r\n     * @type {Uint32Array}\r\n     * @since 3.0.0\r\n     */\n\n    this.vertexViewU32 = new Uint32Array(this.vertexData);\n    /**\r\n     * Size of the batch.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#maxQuads\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.maxQuads = rendererConfig.batchSize;\n    /**\r\n     * Collection of batch information\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batches\r\n     * @type {array}\r\n     * @since 3.1.0\r\n     */\n\n    this.batches = [];\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#_tempMatrix1\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.11.0\r\n     */\n\n    this._tempMatrix1 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#_tempMatrix2\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.11.0\r\n     */\n\n    this._tempMatrix2 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#_tempMatrix3\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.11.0\r\n     */\n\n    this._tempMatrix3 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#_tempMatrix4\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.11.0\r\n     */\n\n    this._tempMatrix4 = new TransformMatrix();\n    /**\r\n     * Used internally to draw stroked triangles.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#tempTriangle\r\n     * @type {array}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this.tempTriangle = [{\n      x: 0,\n      y: 0,\n      width: 0\n    }, {\n      x: 0,\n      y: 0,\n      width: 0\n    }, {\n      x: 0,\n      y: 0,\n      width: 0\n    }, {\n      x: 0,\n      y: 0,\n      width: 0\n    }];\n    /**\r\n     * The tint effect to be applied by the shader in the next geometry draw:\r\n     * \r\n     * 0 = texture multiplied by color\r\n     * 1 = solid color + texture alpha\r\n     * 2 = solid color, no texture\r\n     * 3 = solid texture, no color\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#tintEffect\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this.tintEffect = 2;\n    /**\r\n     * Cached stroke tint.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#strokeTint\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this.strokeTint = {\n      TL: 0,\n      TR: 0,\n      BL: 0,\n      BR: 0\n    };\n    /**\r\n     * Cached fill tint.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#fillTint\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this.fillTint = {\n      TL: 0,\n      TR: 0,\n      BL: 0,\n      BR: 0\n    };\n    /**\r\n     * Internal texture frame reference.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#currentFrame\r\n     * @type {Phaser.Textures.Frame}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this.currentFrame = {\n      u0: 0,\n      v0: 0,\n      u1: 1,\n      v1: 1\n    };\n    /**\r\n     * Internal path quad cache.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#firstQuad\r\n     * @type {array}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this.firstQuad = [0, 0, 0, 0, 0];\n    /**\r\n     * Internal path quad cache.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#prevQuad\r\n     * @type {array}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this.prevQuad = [0, 0, 0, 0, 0];\n    /**\r\n     * Used internally for triangulating a polygon.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#polygonCache\r\n     * @type {array}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this.polygonCache = [];\n    this.mvpInit();\n  },\n\n  /**\r\n   * Called every time the pipeline needs to be used.\r\n   * It binds all necessary resources.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#onBind\r\n   * @since 3.0.0\r\n   *\r\n   * @return {this} This WebGLPipeline instance.\r\n   */\n  onBind: function onBind() {\n    WebGLPipeline.prototype.onBind.call(this);\n    this.mvpUpdate();\n    return this;\n  },\n\n  /**\r\n   * Resizes this pipeline and updates the projection.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#resize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} width - The new width.\r\n   * @param {number} height - The new height.\r\n   * @param {number} resolution - The resolution.\r\n   *\r\n   * @return {this} This WebGLPipeline instance.\r\n   */\n  resize: function resize(width, height, resolution) {\n    WebGLPipeline.prototype.resize.call(this, width, height, resolution);\n    this.projOrtho(0, this.width, this.height, 0, -1000.0, 1000.0);\n    return this;\n  },\n\n  /**\r\n   * Assigns a texture to the current batch. If a different texture is already set it creates a new batch object.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#setTexture2D\r\n   * @since 3.1.0\r\n   *\r\n   * @param {WebGLTexture} [texture] - WebGLTexture that will be assigned to the current batch. If not given uses blankTexture.\r\n   * @param {integer} [unit=0] - Texture unit to which the texture needs to be bound.\r\n   *\r\n   * @return {Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline} This pipeline instance.\r\n   */\n  setTexture2D: function setTexture2D(texture, unit) {\n    if (texture === undefined) {\n      texture = this.renderer.blankTexture.glTexture;\n    }\n\n    if (unit === undefined) {\n      unit = 0;\n    }\n\n    if (this.requireTextureBatch(texture, unit)) {\n      this.pushBatch(texture, unit);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Checks if the current batch has the same texture and texture unit, or if we need to create a new batch.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#requireTextureBatch\r\n   * @since 3.16.0\r\n   *\r\n   * @param {WebGLTexture} texture - WebGLTexture that will be assigned to the current batch. If not given uses blankTexture.\r\n   * @param {integer} unit - Texture unit to which the texture needs to be bound.\r\n   *\r\n   * @return {boolean} `true` if the pipeline needs to create a new batch, otherwise `false`.\r\n   */\n  requireTextureBatch: function requireTextureBatch(texture, unit) {\n    var batches = this.batches;\n    var batchLength = batches.length;\n\n    if (batchLength > 0) {\n      //  If Texture Unit specified, we get the texture from the textures array, otherwise we use the texture property\n      var currentTexture = unit > 0 ? batches[batchLength - 1].textures[unit - 1] : batches[batchLength - 1].texture;\n      return !(currentTexture === texture);\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Creates a new batch object and pushes it to a batch array.\r\n   * The batch object contains information relevant to the current \r\n   * vertex batch like the offset in the vertex buffer, vertex count and \r\n   * the textures used by that batch.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#pushBatch\r\n   * @since 3.1.0\r\n   * \r\n   * @param {WebGLTexture} texture - Optional WebGLTexture that will be assigned to the created batch.\r\n   * @param {integer} unit - Texture unit to which the texture needs to be bound.\r\n   */\n  pushBatch: function pushBatch(texture, unit) {\n    if (unit === 0) {\n      this.batches.push({\n        first: this.vertexCount,\n        texture: texture,\n        textures: []\n      });\n    } else {\n      var textures = [];\n      textures[unit - 1] = texture;\n      this.batches.push({\n        first: this.vertexCount,\n        texture: null,\n        textures: textures\n      });\n    }\n  },\n\n  /**\r\n   * Uploads the vertex data and emits a draw call for the current batch of vertices.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#flush\r\n   * @since 3.0.0\r\n   *\r\n   * @return {this} This WebGLPipeline instance.\r\n   */\n  flush: function flush() {\n    if (this.flushLocked) {\n      return this;\n    }\n\n    this.flushLocked = true;\n    var gl = this.gl;\n    var vertexCount = this.vertexCount;\n    var topology = this.topology;\n    var vertexSize = this.vertexSize;\n    var renderer = this.renderer;\n    var batches = this.batches;\n    var batchCount = batches.length;\n    var batchVertexCount = 0;\n    var batch = null;\n    var batchNext;\n    var textureIndex;\n    var nTexture;\n\n    if (batchCount === 0 || vertexCount === 0) {\n      this.flushLocked = false;\n      return this;\n    }\n\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize)); //  Process the TEXTURE BATCHES\n\n    for (var index = 0; index < batchCount - 1; index++) {\n      batch = batches[index];\n      batchNext = batches[index + 1]; //  Multi-texture check (for non-zero texture units)\n\n      if (batch.textures.length > 0) {\n        for (textureIndex = 0; textureIndex < batch.textures.length; ++textureIndex) {\n          nTexture = batch.textures[textureIndex];\n\n          if (nTexture) {\n            renderer.setTexture2D(nTexture, 1 + textureIndex, false);\n          }\n        }\n\n        gl.activeTexture(gl.TEXTURE0);\n      }\n\n      batchVertexCount = batchNext.first - batch.first; //  Bail out if texture property is null (i.e. if a texture unit > 0)\n\n      if (batch.texture === null || batchVertexCount <= 0) {\n        continue;\n      }\n\n      renderer.setTexture2D(batch.texture, 0, false);\n      gl.drawArrays(topology, batch.first, batchVertexCount);\n    } // Left over data\n\n\n    batch = batches[batchCount - 1]; //  Multi-texture check (for non-zero texture units)\n\n    if (batch.textures.length > 0) {\n      for (textureIndex = 0; textureIndex < batch.textures.length; ++textureIndex) {\n        nTexture = batch.textures[textureIndex];\n\n        if (nTexture) {\n          renderer.setTexture2D(nTexture, 1 + textureIndex, false);\n        }\n      }\n\n      gl.activeTexture(gl.TEXTURE0);\n    }\n\n    batchVertexCount = vertexCount - batch.first;\n\n    if (batch.texture && batchVertexCount > 0) {\n      renderer.setTexture2D(batch.texture, 0, false);\n      gl.drawArrays(topology, batch.first, batchVertexCount);\n    }\n\n    this.vertexCount = 0;\n    batches.length = 0;\n    this.flushLocked = false;\n    return this;\n  },\n\n  /**\r\n   * Takes a Sprite Game Object, or any object that extends it, and adds it to the batch.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchSprite\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.Image|Phaser.GameObjects.Sprite)} sprite - The texture based Game Object to add to the batch.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use for the rendering transform.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} [parentTransformMatrix] - The transform matrix of the parent container, if set.\r\n   */\n  batchSprite: function batchSprite(sprite, camera, parentTransformMatrix) {\n    //  Will cause a flush if there are batchSize entries already\n    this.renderer.setPipeline(this);\n    var camMatrix = this._tempMatrix1;\n    var spriteMatrix = this._tempMatrix2;\n    var calcMatrix = this._tempMatrix3;\n    var frame = sprite.frame;\n    var texture = frame.glTexture;\n    var u0 = frame.u0;\n    var v0 = frame.v0;\n    var u1 = frame.u1;\n    var v1 = frame.v1;\n    var frameX = frame.x;\n    var frameY = frame.y;\n    var frameWidth = frame.cutWidth;\n    var frameHeight = frame.cutHeight;\n    var x = -sprite.displayOriginX + frameX;\n    var y = -sprite.displayOriginY + frameY;\n\n    if (sprite.isCropped) {\n      var crop = sprite._crop;\n\n      if (crop.flipX !== sprite.flipX || crop.flipY !== sprite.flipY) {\n        frame.updateCropUVs(crop, sprite.flipX, sprite.flipY);\n      }\n\n      u0 = crop.u0;\n      v0 = crop.v0;\n      u1 = crop.u1;\n      v1 = crop.v1;\n      frameWidth = crop.width;\n      frameHeight = crop.height;\n      frameX = crop.x;\n      frameY = crop.y;\n      x = -sprite.displayOriginX + frameX;\n      y = -sprite.displayOriginY + frameY;\n    }\n\n    if (sprite.flipX) {\n      x += frameWidth;\n      frameWidth *= -1;\n    }\n\n    if (sprite.flipY) {\n      y += frameHeight;\n      frameHeight *= -1;\n    }\n\n    var xw = x + frameWidth;\n    var yh = y + frameHeight;\n    spriteMatrix.applyITRS(sprite.x, sprite.y, sprite.rotation, sprite.scaleX, sprite.scaleY);\n    camMatrix.copyFrom(camera.matrix);\n\n    if (parentTransformMatrix) {\n      //  Multiply the camera by the parent matrix\n      camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * sprite.scrollFactorX, -camera.scrollY * sprite.scrollFactorY); //  Undo the camera scroll\n\n      spriteMatrix.e = sprite.x;\n      spriteMatrix.f = sprite.y; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n      camMatrix.multiply(spriteMatrix, calcMatrix);\n    } else {\n      spriteMatrix.e -= camera.scrollX * sprite.scrollFactorX;\n      spriteMatrix.f -= camera.scrollY * sprite.scrollFactorY; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n      camMatrix.multiply(spriteMatrix, calcMatrix);\n    }\n\n    var tx0 = calcMatrix.getX(x, y);\n    var ty0 = calcMatrix.getY(x, y);\n    var tx1 = calcMatrix.getX(x, yh);\n    var ty1 = calcMatrix.getY(x, yh);\n    var tx2 = calcMatrix.getX(xw, yh);\n    var ty2 = calcMatrix.getY(xw, yh);\n    var tx3 = calcMatrix.getX(xw, y);\n    var ty3 = calcMatrix.getY(xw, y);\n    var tintTL = Utils.getTintAppendFloatAlpha(sprite._tintTL, camera.alpha * sprite._alphaTL);\n    var tintTR = Utils.getTintAppendFloatAlpha(sprite._tintTR, camera.alpha * sprite._alphaTR);\n    var tintBL = Utils.getTintAppendFloatAlpha(sprite._tintBL, camera.alpha * sprite._alphaBL);\n    var tintBR = Utils.getTintAppendFloatAlpha(sprite._tintBR, camera.alpha * sprite._alphaBR);\n\n    if (camera.roundPixels) {\n      tx0 = Math.round(tx0);\n      ty0 = Math.round(ty0);\n      tx1 = Math.round(tx1);\n      ty1 = Math.round(ty1);\n      tx2 = Math.round(tx2);\n      ty2 = Math.round(ty2);\n      tx3 = Math.round(tx3);\n      ty3 = Math.round(ty3);\n    }\n\n    this.setTexture2D(texture, 0);\n    var tintEffect = sprite._isTinted && sprite.tintFill;\n    this.batchQuad(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, 0);\n  },\n\n  /**\r\n   * Adds the vertices data into the batch and flushes if full.\r\n   * \r\n   * Assumes 6 vertices in the following arrangement:\r\n   * \r\n   * ```\r\n   * 0----3\r\n   * |\\  B|\r\n   * | \\  |\r\n   * |  \\ |\r\n   * | A \\|\r\n   * |    \\\r\n   * 1----2\r\n   * ```\r\n   * \r\n   * Where tx0/ty0 = 0, tx1/ty1 = 1, tx2/ty2 = 2 and tx3/ty3 = 3\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchQuad\r\n   * @since 3.12.0\r\n   *\r\n   * @param {number} x0 - The top-left x position.\r\n   * @param {number} y0 - The top-left y position.\r\n   * @param {number} x1 - The bottom-left x position.\r\n   * @param {number} y1 - The bottom-left y position.\r\n   * @param {number} x2 - The bottom-right x position.\r\n   * @param {number} y2 - The bottom-right y position.\r\n   * @param {number} x3 - The top-right x position.\r\n   * @param {number} y3 - The top-right y position.\r\n   * @param {number} u0 - UV u0 value.\r\n   * @param {number} v0 - UV v0 value.\r\n   * @param {number} u1 - UV u1 value.\r\n   * @param {number} v1 - UV v1 value.\r\n   * @param {number} tintTL - The top-left tint color value.\r\n   * @param {number} tintTR - The top-right tint color value.\r\n   * @param {number} tintBL - The bottom-left tint color value.\r\n   * @param {number} tintBR - The bottom-right tint color value.\r\n   * @param {(number|boolean)} tintEffect - The tint effect for the shader to use.\r\n   * @param {WebGLTexture} [texture] - WebGLTexture that will be assigned to the current batch if a flush occurs.\r\n   * @param {integer} [unit=0] - Texture unit to which the texture needs to be bound.\r\n   * \r\n   * @return {boolean} `true` if this method caused the batch to flush, otherwise `false`.\r\n   */\n  batchQuad: function batchQuad(x0, y0, x1, y1, x2, y2, x3, y3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, unit) {\n    var hasFlushed = false;\n\n    if (this.vertexCount + 6 > this.vertexCapacity) {\n      this.flush();\n      hasFlushed = true;\n      this.setTexture2D(texture, unit);\n    }\n\n    var vertexViewF32 = this.vertexViewF32;\n    var vertexViewU32 = this.vertexViewU32;\n    var vertexOffset = this.vertexCount * this.vertexComponentCount - 1;\n    vertexViewF32[++vertexOffset] = x0;\n    vertexViewF32[++vertexOffset] = y0;\n    vertexViewF32[++vertexOffset] = u0;\n    vertexViewF32[++vertexOffset] = v0;\n    vertexViewF32[++vertexOffset] = tintEffect;\n    vertexViewU32[++vertexOffset] = tintTL;\n    vertexViewF32[++vertexOffset] = x1;\n    vertexViewF32[++vertexOffset] = y1;\n    vertexViewF32[++vertexOffset] = u0;\n    vertexViewF32[++vertexOffset] = v1;\n    vertexViewF32[++vertexOffset] = tintEffect;\n    vertexViewU32[++vertexOffset] = tintBL;\n    vertexViewF32[++vertexOffset] = x2;\n    vertexViewF32[++vertexOffset] = y2;\n    vertexViewF32[++vertexOffset] = u1;\n    vertexViewF32[++vertexOffset] = v1;\n    vertexViewF32[++vertexOffset] = tintEffect;\n    vertexViewU32[++vertexOffset] = tintBR;\n    vertexViewF32[++vertexOffset] = x0;\n    vertexViewF32[++vertexOffset] = y0;\n    vertexViewF32[++vertexOffset] = u0;\n    vertexViewF32[++vertexOffset] = v0;\n    vertexViewF32[++vertexOffset] = tintEffect;\n    vertexViewU32[++vertexOffset] = tintTL;\n    vertexViewF32[++vertexOffset] = x2;\n    vertexViewF32[++vertexOffset] = y2;\n    vertexViewF32[++vertexOffset] = u1;\n    vertexViewF32[++vertexOffset] = v1;\n    vertexViewF32[++vertexOffset] = tintEffect;\n    vertexViewU32[++vertexOffset] = tintBR;\n    vertexViewF32[++vertexOffset] = x3;\n    vertexViewF32[++vertexOffset] = y3;\n    vertexViewF32[++vertexOffset] = u1;\n    vertexViewF32[++vertexOffset] = v0;\n    vertexViewF32[++vertexOffset] = tintEffect;\n    vertexViewU32[++vertexOffset] = tintTR;\n    this.vertexCount += 6;\n    return hasFlushed;\n  },\n\n  /**\r\n   * Adds the vertices data into the batch and flushes if full.\r\n   * \r\n   * Assumes 3 vertices in the following arrangement:\r\n   * \r\n   * ```\r\n   * 0\r\n   * |\\\r\n   * | \\\r\n   * |  \\\r\n   * |   \\\r\n   * |    \\\r\n   * 1-----2\r\n   * ```\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchTri\r\n   * @since 3.12.0\r\n   *\r\n   * @param {number} x1 - The bottom-left x position.\r\n   * @param {number} y1 - The bottom-left y position.\r\n   * @param {number} x2 - The bottom-right x position.\r\n   * @param {number} y2 - The bottom-right y position.\r\n   * @param {number} x3 - The top-right x position.\r\n   * @param {number} y3 - The top-right y position.\r\n   * @param {number} u0 - UV u0 value.\r\n   * @param {number} v0 - UV v0 value.\r\n   * @param {number} u1 - UV u1 value.\r\n   * @param {number} v1 - UV v1 value.\r\n   * @param {number} tintTL - The top-left tint color value.\r\n   * @param {number} tintTR - The top-right tint color value.\r\n   * @param {number} tintBL - The bottom-left tint color value.\r\n   * @param {(number|boolean)} tintEffect - The tint effect for the shader to use.\r\n   * @param {WebGLTexture} [texture] - WebGLTexture that will be assigned to the current batch if a flush occurs.\r\n   * @param {integer} [unit=0] - Texture unit to which the texture needs to be bound.\r\n   * \r\n   * @return {boolean} `true` if this method caused the batch to flush, otherwise `false`.\r\n   */\n  batchTri: function batchTri(x1, y1, x2, y2, x3, y3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintEffect, texture, unit) {\n    var hasFlushed = false;\n\n    if (this.vertexCount + 3 > this.vertexCapacity) {\n      this.flush();\n      this.setTexture2D(texture, unit);\n      hasFlushed = true;\n    }\n\n    var vertexViewF32 = this.vertexViewF32;\n    var vertexViewU32 = this.vertexViewU32;\n    var vertexOffset = this.vertexCount * this.vertexComponentCount - 1;\n    vertexViewF32[++vertexOffset] = x1;\n    vertexViewF32[++vertexOffset] = y1;\n    vertexViewF32[++vertexOffset] = u0;\n    vertexViewF32[++vertexOffset] = v0;\n    vertexViewF32[++vertexOffset] = tintEffect;\n    vertexViewU32[++vertexOffset] = tintTL;\n    vertexViewF32[++vertexOffset] = x2;\n    vertexViewF32[++vertexOffset] = y2;\n    vertexViewF32[++vertexOffset] = u0;\n    vertexViewF32[++vertexOffset] = v1;\n    vertexViewF32[++vertexOffset] = tintEffect;\n    vertexViewU32[++vertexOffset] = tintTR;\n    vertexViewF32[++vertexOffset] = x3;\n    vertexViewF32[++vertexOffset] = y3;\n    vertexViewF32[++vertexOffset] = u1;\n    vertexViewF32[++vertexOffset] = v1;\n    vertexViewF32[++vertexOffset] = tintEffect;\n    vertexViewU32[++vertexOffset] = tintBL;\n    this.vertexCount += 3;\n    return hasFlushed;\n  },\n\n  /**\r\n   * Generic function for batching a textured quad using argument values instead of a Game Object.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchTexture\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - Source GameObject.\r\n   * @param {WebGLTexture} texture - Raw WebGLTexture associated with the quad.\r\n   * @param {integer} textureWidth - Real texture width.\r\n   * @param {integer} textureHeight - Real texture height.\r\n   * @param {number} srcX - X coordinate of the quad.\r\n   * @param {number} srcY - Y coordinate of the quad.\r\n   * @param {number} srcWidth - Width of the quad.\r\n   * @param {number} srcHeight - Height of the quad.\r\n   * @param {number} scaleX - X component of scale.\r\n   * @param {number} scaleY - Y component of scale.\r\n   * @param {number} rotation - Rotation of the quad.\r\n   * @param {boolean} flipX - Indicates if the quad is horizontally flipped.\r\n   * @param {boolean} flipY - Indicates if the quad is vertically flipped.\r\n   * @param {number} scrollFactorX - By which factor is the quad affected by the camera horizontal scroll.\r\n   * @param {number} scrollFactorY - By which factor is the quad effected by the camera vertical scroll.\r\n   * @param {number} displayOriginX - Horizontal origin in pixels.\r\n   * @param {number} displayOriginY - Vertical origin in pixels.\r\n   * @param {number} frameX - X coordinate of the texture frame.\r\n   * @param {number} frameY - Y coordinate of the texture frame.\r\n   * @param {number} frameWidth - Width of the texture frame.\r\n   * @param {number} frameHeight - Height of the texture frame.\r\n   * @param {integer} tintTL - Tint for top left.\r\n   * @param {integer} tintTR - Tint for top right.\r\n   * @param {integer} tintBL - Tint for bottom left.\r\n   * @param {integer} tintBR - Tint for bottom right.\r\n   * @param {number} tintEffect - The tint effect.\r\n   * @param {number} uOffset - Horizontal offset on texture coordinate.\r\n   * @param {number} vOffset - Vertical offset on texture coordinate.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - Current used camera.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - Parent container.\r\n   * @param {boolean} [skipFlip=false] - Skip the renderTexture check.\r\n   */\n  batchTexture: function batchTexture(gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip) {\n    this.renderer.setPipeline(this, gameObject);\n    var camMatrix = this._tempMatrix1;\n    var spriteMatrix = this._tempMatrix2;\n    var calcMatrix = this._tempMatrix3;\n    var u0 = frameX / textureWidth + uOffset;\n    var v0 = frameY / textureHeight + vOffset;\n    var u1 = (frameX + frameWidth) / textureWidth + uOffset;\n    var v1 = (frameY + frameHeight) / textureHeight + vOffset;\n    var width = srcWidth;\n    var height = srcHeight;\n    var x = -displayOriginX;\n    var y = -displayOriginY;\n\n    if (gameObject.isCropped) {\n      var crop = gameObject._crop;\n      width = crop.width;\n      height = crop.height;\n      srcWidth = crop.width;\n      srcHeight = crop.height;\n      frameX = crop.x;\n      frameY = crop.y;\n      var ox = frameX;\n      var oy = frameY;\n\n      if (flipX) {\n        ox = frameWidth - crop.x - crop.width;\n      }\n\n      if (flipY && !texture.isRenderTexture) {\n        oy = frameHeight - crop.y - crop.height;\n      }\n\n      u0 = ox / textureWidth + uOffset;\n      v0 = oy / textureHeight + vOffset;\n      u1 = (ox + crop.width) / textureWidth + uOffset;\n      v1 = (oy + crop.height) / textureHeight + vOffset;\n      x = -displayOriginX + frameX;\n      y = -displayOriginY + frameY;\n    } //  Invert the flipY if this is a RenderTexture\n\n\n    flipY = flipY ^ (!skipFlip && texture.isRenderTexture ? 1 : 0);\n\n    if (flipX) {\n      width *= -1;\n      x += srcWidth;\n    }\n\n    if (flipY) {\n      height *= -1;\n      y += srcHeight;\n    }\n\n    var xw = x + width;\n    var yh = y + height;\n    spriteMatrix.applyITRS(srcX, srcY, rotation, scaleX, scaleY);\n    camMatrix.copyFrom(camera.matrix);\n\n    if (parentTransformMatrix) {\n      //  Multiply the camera by the parent matrix\n      camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY); //  Undo the camera scroll\n\n      spriteMatrix.e = srcX;\n      spriteMatrix.f = srcY; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n      camMatrix.multiply(spriteMatrix, calcMatrix);\n    } else {\n      spriteMatrix.e -= camera.scrollX * scrollFactorX;\n      spriteMatrix.f -= camera.scrollY * scrollFactorY; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n      camMatrix.multiply(spriteMatrix, calcMatrix);\n    }\n\n    var tx0 = calcMatrix.getX(x, y);\n    var ty0 = calcMatrix.getY(x, y);\n    var tx1 = calcMatrix.getX(x, yh);\n    var ty1 = calcMatrix.getY(x, yh);\n    var tx2 = calcMatrix.getX(xw, yh);\n    var ty2 = calcMatrix.getY(xw, yh);\n    var tx3 = calcMatrix.getX(xw, y);\n    var ty3 = calcMatrix.getY(xw, y);\n\n    if (camera.roundPixels) {\n      tx0 = Math.round(tx0);\n      ty0 = Math.round(ty0);\n      tx1 = Math.round(tx1);\n      ty1 = Math.round(ty1);\n      tx2 = Math.round(tx2);\n      ty2 = Math.round(ty2);\n      tx3 = Math.round(tx3);\n      ty3 = Math.round(ty3);\n    }\n\n    this.setTexture2D(texture, 0);\n    this.batchQuad(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, 0);\n  },\n\n  /**\r\n   * Adds a Texture Frame into the batch for rendering.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchTextureFrame\r\n   * @since 3.12.0\r\n   *\r\n   * @param {Phaser.Textures.Frame} frame - The Texture Frame to be rendered.\r\n   * @param {number} x - The horizontal position to render the texture at.\r\n   * @param {number} y - The vertical position to render the texture at.\r\n   * @param {number} tint - The tint color.\r\n   * @param {number} alpha - The alpha value.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} transformMatrix - The Transform Matrix to use for the texture.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} [parentTransformMatrix] - A parent Transform Matrix.\r\n   */\n  batchTextureFrame: function batchTextureFrame(frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix) {\n    this.renderer.setPipeline(this);\n\n    var spriteMatrix = this._tempMatrix1.copyFrom(transformMatrix);\n\n    var calcMatrix = this._tempMatrix2;\n    var xw = x + frame.width;\n    var yh = y + frame.height;\n\n    if (parentTransformMatrix) {\n      spriteMatrix.multiply(parentTransformMatrix, calcMatrix);\n    } else {\n      calcMatrix = spriteMatrix;\n    }\n\n    var tx0 = calcMatrix.getX(x, y);\n    var ty0 = calcMatrix.getY(x, y);\n    var tx1 = calcMatrix.getX(x, yh);\n    var ty1 = calcMatrix.getY(x, yh);\n    var tx2 = calcMatrix.getX(xw, yh);\n    var ty2 = calcMatrix.getY(xw, yh);\n    var tx3 = calcMatrix.getX(xw, y);\n    var ty3 = calcMatrix.getY(xw, y);\n    this.setTexture2D(frame.glTexture, 0);\n    tint = Utils.getTintAppendFloatAlpha(tint, alpha);\n    this.batchQuad(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, 0, frame.glTexture, 0);\n  },\n\n  /**\r\n   * Pushes a filled rectangle into the vertex batch.\r\n   * Rectangle has no transform values and isn't transformed into the local space.\r\n   * Used for directly batching untransformed rectangles, such as Camera background colors.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#drawFillRect\r\n   * @since 3.12.0\r\n   *\r\n   * @param {number} x - Horizontal top left coordinate of the rectangle.\r\n   * @param {number} y - Vertical top left coordinate of the rectangle.\r\n   * @param {number} width - Width of the rectangle.\r\n   * @param {number} height - Height of the rectangle.\r\n   * @param {number} color - Color of the rectangle to draw.\r\n   * @param {number} alpha - Alpha value of the rectangle to draw.\r\n   */\n  drawFillRect: function drawFillRect(x, y, width, height, color, alpha) {\n    var xw = x + width;\n    var yh = y + height;\n    this.setTexture2D();\n    var tint = Utils.getTintAppendFloatAlphaAndSwap(color, alpha);\n    this.batchQuad(x, y, x, yh, xw, yh, xw, y, 0, 0, 1, 1, tint, tint, tint, tint, 2);\n  },\n\n  /**\r\n   * Pushes a filled rectangle into the vertex batch.\r\n   * Rectangle factors in the given transform matrices before adding to the batch.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchFillRect\r\n   * @since 3.12.0\r\n   *\r\n   * @param {number} x - Horizontal top left coordinate of the rectangle.\r\n   * @param {number} y - Vertical top left coordinate of the rectangle.\r\n   * @param {number} width - Width of the rectangle.\r\n   * @param {number} height - Height of the rectangle.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n   */\n  batchFillRect: function batchFillRect(x, y, width, height, currentMatrix, parentMatrix) {\n    this.renderer.setPipeline(this);\n    var calcMatrix = this._tempMatrix3; //  Multiply and store result in calcMatrix, only if the parentMatrix is set, otherwise we'll use whatever values are already in the calcMatrix\n\n    if (parentMatrix) {\n      parentMatrix.multiply(currentMatrix, calcMatrix);\n    }\n\n    var xw = x + width;\n    var yh = y + height;\n    var x0 = calcMatrix.getX(x, y);\n    var y0 = calcMatrix.getY(x, y);\n    var x1 = calcMatrix.getX(x, yh);\n    var y1 = calcMatrix.getY(x, yh);\n    var x2 = calcMatrix.getX(xw, yh);\n    var y2 = calcMatrix.getY(xw, yh);\n    var x3 = calcMatrix.getX(xw, y);\n    var y3 = calcMatrix.getY(xw, y);\n    var frame = this.currentFrame;\n    var u0 = frame.u0;\n    var v0 = frame.v0;\n    var u1 = frame.u1;\n    var v1 = frame.v1;\n    this.batchQuad(x0, y0, x1, y1, x2, y2, x3, y3, u0, v0, u1, v1, this.fillTint.TL, this.fillTint.TR, this.fillTint.BL, this.fillTint.BR, this.tintEffect);\n  },\n\n  /**\r\n   * Pushes a filled triangle into the vertex batch.\r\n   * Triangle factors in the given transform matrices before adding to the batch.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchFillTriangle\r\n   * @since 3.12.0\r\n   *\r\n   * @param {number} x0 - Point 0 x coordinate.\r\n   * @param {number} y0 - Point 0 y coordinate.\r\n   * @param {number} x1 - Point 1 x coordinate.\r\n   * @param {number} y1 - Point 1 y coordinate.\r\n   * @param {number} x2 - Point 2 x coordinate.\r\n   * @param {number} y2 - Point 2 y coordinate.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n   */\n  batchFillTriangle: function batchFillTriangle(x0, y0, x1, y1, x2, y2, currentMatrix, parentMatrix) {\n    this.renderer.setPipeline(this);\n    var calcMatrix = this._tempMatrix3; //  Multiply and store result in calcMatrix, only if the parentMatrix is set, otherwise we'll use whatever values are already in the calcMatrix\n\n    if (parentMatrix) {\n      parentMatrix.multiply(currentMatrix, calcMatrix);\n    }\n\n    var tx0 = calcMatrix.getX(x0, y0);\n    var ty0 = calcMatrix.getY(x0, y0);\n    var tx1 = calcMatrix.getX(x1, y1);\n    var ty1 = calcMatrix.getY(x1, y1);\n    var tx2 = calcMatrix.getX(x2, y2);\n    var ty2 = calcMatrix.getY(x2, y2);\n    var frame = this.currentFrame;\n    var u0 = frame.u0;\n    var v0 = frame.v0;\n    var u1 = frame.u1;\n    var v1 = frame.v1;\n    this.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, u0, v0, u1, v1, this.fillTint.TL, this.fillTint.TR, this.fillTint.BL, this.tintEffect);\n  },\n\n  /**\r\n   * Pushes a stroked triangle into the vertex batch.\r\n   * Triangle factors in the given transform matrices before adding to the batch.\r\n   * The triangle is created from 3 lines and drawn using the `batchStrokePath` method.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchStrokeTriangle\r\n   * @since 3.12.0\r\n   *\r\n   * @param {number} x0 - Point 0 x coordinate.\r\n   * @param {number} y0 - Point 0 y coordinate.\r\n   * @param {number} x1 - Point 1 x coordinate.\r\n   * @param {number} y1 - Point 1 y coordinate.\r\n   * @param {number} x2 - Point 2 x coordinate.\r\n   * @param {number} y2 - Point 2 y coordinate.\r\n   * @param {number} lineWidth - The width of the line in pixels.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n   */\n  batchStrokeTriangle: function batchStrokeTriangle(x0, y0, x1, y1, x2, y2, lineWidth, currentMatrix, parentMatrix) {\n    var tempTriangle = this.tempTriangle;\n    tempTriangle[0].x = x0;\n    tempTriangle[0].y = y0;\n    tempTriangle[0].width = lineWidth;\n    tempTriangle[1].x = x1;\n    tempTriangle[1].y = y1;\n    tempTriangle[1].width = lineWidth;\n    tempTriangle[2].x = x2;\n    tempTriangle[2].y = y2;\n    tempTriangle[2].width = lineWidth;\n    tempTriangle[3].x = x0;\n    tempTriangle[3].y = y0;\n    tempTriangle[3].width = lineWidth;\n    this.batchStrokePath(tempTriangle, lineWidth, false, currentMatrix, parentMatrix);\n  },\n\n  /**\r\n   * Adds the given path to the vertex batch for rendering.\r\n   * \r\n   * It works by taking the array of path data and then passing it through Earcut, which\r\n   * creates a list of polygons. Each polygon is then added to the batch.\r\n   * \r\n   * The path is always automatically closed because it's filled.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchFillPath\r\n   * @since 3.12.0\r\n   *\r\n   * @param {array} path - Collection of points that represent the path.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n   */\n  batchFillPath: function batchFillPath(path, currentMatrix, parentMatrix) {\n    this.renderer.setPipeline(this);\n    var calcMatrix = this._tempMatrix3; //  Multiply and store result in calcMatrix, only if the parentMatrix is set, otherwise we'll use whatever values are already in the calcMatrix\n\n    if (parentMatrix) {\n      parentMatrix.multiply(currentMatrix, calcMatrix);\n    }\n\n    var length = path.length;\n    var polygonCache = this.polygonCache;\n    var polygonIndexArray;\n    var point;\n    var tintTL = this.fillTint.TL;\n    var tintTR = this.fillTint.TR;\n    var tintBL = this.fillTint.BL;\n    var tintEffect = this.tintEffect;\n\n    for (var pathIndex = 0; pathIndex < length; ++pathIndex) {\n      point = path[pathIndex];\n      polygonCache.push(point.x, point.y);\n    }\n\n    polygonIndexArray = Earcut(polygonCache);\n    length = polygonIndexArray.length;\n    var frame = this.currentFrame;\n\n    for (var index = 0; index < length; index += 3) {\n      var p0 = polygonIndexArray[index + 0] * 2;\n      var p1 = polygonIndexArray[index + 1] * 2;\n      var p2 = polygonIndexArray[index + 2] * 2;\n      var x0 = polygonCache[p0 + 0];\n      var y0 = polygonCache[p0 + 1];\n      var x1 = polygonCache[p1 + 0];\n      var y1 = polygonCache[p1 + 1];\n      var x2 = polygonCache[p2 + 0];\n      var y2 = polygonCache[p2 + 1];\n      var tx0 = calcMatrix.getX(x0, y0);\n      var ty0 = calcMatrix.getY(x0, y0);\n      var tx1 = calcMatrix.getX(x1, y1);\n      var ty1 = calcMatrix.getY(x1, y1);\n      var tx2 = calcMatrix.getX(x2, y2);\n      var ty2 = calcMatrix.getY(x2, y2);\n      var u0 = frame.u0;\n      var v0 = frame.v0;\n      var u1 = frame.u1;\n      var v1 = frame.v1;\n      this.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintEffect);\n    }\n\n    polygonCache.length = 0;\n  },\n\n  /**\r\n   * Adds the given path to the vertex batch for rendering.\r\n   * \r\n   * It works by taking the array of path data and calling `batchLine` for each section\r\n   * of the path.\r\n   * \r\n   * The path is optionally closed at the end.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchStrokePath\r\n   * @since 3.12.0\r\n   *\r\n   * @param {array} path - Collection of points that represent the path.\r\n   * @param {number} lineWidth - The width of the line segments in pixels.\r\n   * @param {boolean} pathOpen - Indicates if the path should be closed or left open.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n   */\n  batchStrokePath: function batchStrokePath(path, lineWidth, pathOpen, currentMatrix, parentMatrix) {\n    this.renderer.setPipeline(this); //  Reset the closePath booleans\n\n    this.prevQuad[4] = 0;\n    this.firstQuad[4] = 0;\n    var pathLength = path.length - 1;\n\n    for (var pathIndex = 0; pathIndex < pathLength; pathIndex++) {\n      var point0 = path[pathIndex];\n      var point1 = path[pathIndex + 1];\n      this.batchLine(point0.x, point0.y, point1.x, point1.y, point0.width / 2, point1.width / 2, lineWidth, pathIndex, !pathOpen && pathIndex === pathLength - 1, currentMatrix, parentMatrix);\n    }\n  },\n\n  /**\r\n   * Creates a quad and adds it to the vertex batch based on the given line values.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline#batchLine\r\n   * @since 3.12.0\r\n   *\r\n   * @param {number} ax - X coordinate to the start of the line\r\n   * @param {number} ay - Y coordinate to the start of the line\r\n   * @param {number} bx - X coordinate to the end of the line\r\n   * @param {number} by - Y coordinate to the end of the line\r\n   * @param {number} aLineWidth - Width of the start of the line\r\n   * @param {number} bLineWidth - Width of the end of the line\r\n   * @param {Float32Array} currentMatrix - Parent matrix, generally used by containers\r\n   */\n  batchLine: function batchLine(ax, ay, bx, by, aLineWidth, bLineWidth, lineWidth, index, closePath, currentMatrix, parentMatrix) {\n    this.renderer.setPipeline(this);\n    var calcMatrix = this._tempMatrix3; //  Multiply and store result in calcMatrix, only if the parentMatrix is set, otherwise we'll use whatever values are already in the calcMatrix\n\n    if (parentMatrix) {\n      parentMatrix.multiply(currentMatrix, calcMatrix);\n    }\n\n    var dx = bx - ax;\n    var dy = by - ay;\n    var len = Math.sqrt(dx * dx + dy * dy);\n    var al0 = aLineWidth * (by - ay) / len;\n    var al1 = aLineWidth * (ax - bx) / len;\n    var bl0 = bLineWidth * (by - ay) / len;\n    var bl1 = bLineWidth * (ax - bx) / len;\n    var lx0 = bx - bl0;\n    var ly0 = by - bl1;\n    var lx1 = ax - al0;\n    var ly1 = ay - al1;\n    var lx2 = bx + bl0;\n    var ly2 = by + bl1;\n    var lx3 = ax + al0;\n    var ly3 = ay + al1; //  tx0 = bottom right\n\n    var brX = calcMatrix.getX(lx0, ly0);\n    var brY = calcMatrix.getY(lx0, ly0); //  tx1 = bottom left\n\n    var blX = calcMatrix.getX(lx1, ly1);\n    var blY = calcMatrix.getY(lx1, ly1); //  tx2 = top right\n\n    var trX = calcMatrix.getX(lx2, ly2);\n    var trY = calcMatrix.getY(lx2, ly2); //  tx3 = top left\n\n    var tlX = calcMatrix.getX(lx3, ly3);\n    var tlY = calcMatrix.getY(lx3, ly3);\n    var tint = this.strokeTint;\n    var tintEffect = this.tintEffect;\n    var tintTL = tint.TL;\n    var tintTR = tint.TR;\n    var tintBL = tint.BL;\n    var tintBR = tint.BR;\n    var frame = this.currentFrame;\n    var u0 = frame.u0;\n    var v0 = frame.v0;\n    var u1 = frame.u1;\n    var v1 = frame.v1; //  TL, BL, BR, TR\n\n    this.batchQuad(tlX, tlY, blX, blY, brX, brY, trX, trY, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect);\n\n    if (lineWidth <= 2) {\n      //  No point doing a linejoin if the line isn't thick enough\n      return;\n    }\n\n    var prev = this.prevQuad;\n    var first = this.firstQuad;\n\n    if (index > 0 && prev[4]) {\n      this.batchQuad(tlX, tlY, blX, blY, prev[0], prev[1], prev[2], prev[3], u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect);\n    } else {\n      first[0] = tlX;\n      first[1] = tlY;\n      first[2] = blX;\n      first[3] = blY;\n      first[4] = 1;\n    }\n\n    if (closePath && first[4]) {\n      //  Add a join for the final path segment\n      this.batchQuad(brX, brY, trX, trY, first[0], first[1], first[2], first[3], u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect);\n    } else {\n      //  Store it\n      prev[0] = brX;\n      prev[1] = brY;\n      prev[2] = trX;\n      prev[3] = trY;\n      prev[4] = 1;\n    }\n  }\n});\nmodule.exports = TextureTintPipeline;","map":null,"metadata":{},"sourceType":"script"}