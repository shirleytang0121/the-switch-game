{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar CanvasPool = require('../display/canvas/CanvasPool');\n\nvar CanvasTexture = require('./CanvasTexture');\n\nvar Class = require('../utils/Class');\n\nvar Color = require('../display/color/Color');\n\nvar CONST = require('../const');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar GameEvents = require('../core/events');\n\nvar GenerateTexture = require('../create/GenerateTexture');\n\nvar GetValue = require('../utils/object/GetValue');\n\nvar Parser = require('./parsers');\n\nvar Texture = require('./Texture');\n/**\r\n * @callback EachTextureCallback\r\n *\r\n * @param {Phaser.Textures.Texture} texture - Each texture in Texture Manager.\r\n * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n */\n\n/**\r\n * @classdesc\r\n * Textures are managed by the global TextureManager. This is a singleton class that is\r\n * responsible for creating and delivering Textures and their corresponding Frames to Game Objects.\r\n *\r\n * Sprites and other Game Objects get the texture data they need from the TextureManager.\r\n *\r\n * Access it via `scene.textures`.\r\n *\r\n * @class TextureManager\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Textures\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser.Game instance this Texture Manager belongs to.\r\n */\n\n\nvar TextureManager = new Class({\n  Extends: EventEmitter,\n  initialize: function TextureManager(game) {\n    EventEmitter.call(this);\n    /**\r\n     * The Game that this TextureManager belongs to.\r\n     *\r\n     * @name Phaser.Textures.TextureManager#game\r\n     * @type {Phaser.Game}\r\n     * @since 3.0.0\r\n     */\n\n    this.game = game;\n    /**\r\n     * The name of this manager.\r\n     *\r\n     * @name Phaser.Textures.TextureManager#name\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n\n    this.name = 'TextureManager';\n    /**\r\n     * An object that has all of textures that Texture Manager creates.\r\n     * Textures are assigned to keys so we can access to any texture that this object has directly by key value without iteration.\r\n     *\r\n     * @name Phaser.Textures.TextureManager#list\r\n     * @type {object}\r\n     * @default {}\r\n     * @since 3.0.0\r\n     */\n\n    this.list = {};\n    /**\r\n     * The temporary canvas element to save an pixel data of an arbitrary texture in getPixel() and getPixelAlpha() method.\r\n     *\r\n     * @name Phaser.Textures.TextureManager#_tempCanvas\r\n     * @type {HTMLCanvasElement}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._tempCanvas = CanvasPool.create2D(this, 1, 1);\n    /**\r\n     * The context of the temporary canvas element made to save an pixel data in getPixel() and getPixelAlpha() method.\r\n     *\r\n     * @name Phaser.Textures.TextureManager#_tempContext\r\n     * @type {CanvasRenderingContext2D}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._tempContext = this._tempCanvas.getContext('2d');\n    /**\r\n     * An counting value used for emitting 'ready' event after all of managers in game is loaded.\r\n     *\r\n     * @name Phaser.Textures.TextureManager#_pending\r\n     * @type {integer}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this._pending = 0;\n    game.events.once(GameEvents.BOOT, this.boot, this);\n  },\n\n  /**\r\n   * The Boot Handler called by Phaser.Game when it first starts up.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#boot\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  boot: function boot() {\n    this._pending = 2;\n    this.on(Events.LOAD, this.updatePending, this);\n    this.on(Events.ERROR, this.updatePending, this);\n    this.addBase64('__DEFAULT', this.game.config.defaultImage);\n    this.addBase64('__MISSING', this.game.config.missingImage);\n    this.game.events.once(GameEvents.DESTROY, this.destroy, this);\n  },\n\n  /**\r\n   * After 'onload' or 'onerror' invoked twice, emit 'ready' event.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#updatePending\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  updatePending: function updatePending() {\n    this._pending--;\n\n    if (this._pending === 0) {\n      this.off(Events.LOAD);\n      this.off(Events.ERROR);\n      this.emit(Events.READY);\n    }\n  },\n\n  /**\r\n   * Checks the given texture key and throws a console.warn if the key is already in use, then returns false.\r\n   * If you wish to avoid the console.warn then use `TextureManager.exists` instead.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#checkKey\r\n   * @since 3.7.0\r\n   *\r\n   * @param {string} key - The texture key to check.\r\n   *\r\n   * @return {boolean} `true` if it's safe to use the texture key, otherwise `false`.\r\n   */\n  checkKey: function checkKey(key) {\n    if (this.exists(key)) {\n      // eslint-disable-next-line no-console\n      console.error('Texture key already in use: ' + key);\n      return false;\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Removes a Texture from the Texture Manager and destroys it. This will immediately\r\n   * clear all references to it from the Texture Manager, and if it has one, destroy its\r\n   * WebGLTexture. This will emit a `removetexture` event.\r\n   *\r\n   * Note: If you have any Game Objects still using this texture they will start throwing\r\n   * errors the next time they try to render. Make sure that removing the texture is the final\r\n   * step when clearing down to avoid this.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#remove\r\n   * @fires Phaser.Textures.Events#REMOVE\r\n   * @since 3.7.0\r\n   *\r\n   * @param {(string|Phaser.Textures.Texture)} key - The key of the Texture to remove, or a reference to it.\r\n   *\r\n   * @return {Phaser.Textures.TextureManager} The Texture Manager.\r\n   */\n  remove: function remove(key) {\n    if (typeof key === 'string') {\n      if (this.exists(key)) {\n        key = this.get(key);\n      } else {\n        console.warn('No texture found matching key: ' + key);\n        return this;\n      }\n    } //  By this point key should be a Texture, if not, the following fails anyway\n\n\n    if (this.list.hasOwnProperty(key.key)) {\n      delete this.list[key.key];\n      key.destroy();\n      this.emit(Events.REMOVE, key.key);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Adds a new Texture to the Texture Manager created from the given Base64 encoded data.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addBase64\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @fires Phaser.Textures.Events#ERROR\r\n   * @fires Phaser.Textures.Events#LOAD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {*} data - The Base64 encoded data.\r\n   * \r\n   * @return {this} This Texture Manager instance.\r\n   */\n  addBase64: function addBase64(key, data) {\n    if (this.checkKey(key)) {\n      var _this = this;\n\n      var image = new Image();\n\n      image.onerror = function () {\n        _this.emit(Events.ERROR, key);\n      };\n\n      image.onload = function () {\n        var texture = _this.create(key, image);\n\n        Parser.Image(texture, 0);\n\n        _this.emit(Events.ADD, key, texture);\n\n        _this.emit(Events.LOAD, key, texture);\n      };\n\n      image.src = data;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Gets an existing texture frame and converts it into a base64 encoded image and returns the base64 data.\r\n   * \r\n   * You can also provide the image type and encoder options.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#getBase64\r\n   * @since 3.12.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(string|integer)} [frame] - The string-based name, or integer based index, of the Frame to get from the Texture.\r\n   * @param {string} [type='image/png'] - [description]\r\n   * @param {number} [encoderOptions=0.92] - [description]\r\n   * \r\n   * @return {string} The base64 encoded data, or an empty string if the texture frame could not be found.\r\n   */\n  getBase64: function getBase64(key, frame, type, encoderOptions) {\n    if (type === undefined) {\n      type = 'image/png';\n    }\n\n    if (encoderOptions === undefined) {\n      encoderOptions = 0.92;\n    }\n\n    var data = '';\n    var textureFrame = this.getFrame(key, frame);\n\n    if (textureFrame) {\n      var cd = textureFrame.canvasData;\n      var canvas = CanvasPool.create2D(this, cd.width, cd.height);\n      var ctx = canvas.getContext('2d');\n      ctx.drawImage(textureFrame.source.image, cd.x, cd.y, cd.width, cd.height, 0, 0, cd.width, cd.height);\n      data = canvas.toDataURL(type, encoderOptions);\n      CanvasPool.remove(canvas);\n    }\n\n    return data;\n  },\n\n  /**\r\n   * Adds a new Texture to the Texture Manager created from the given Image element.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addImage\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLImageElement} source - The source Image element.\r\n   * @param {HTMLImageElement|HTMLCanvasElement} [dataSource] - An optional data Image element.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addImage: function addImage(key, source, dataSource) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = this.create(key, source);\n      Parser.Image(texture, 0);\n\n      if (dataSource) {\n        texture.setDataSource(dataSource);\n      }\n\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Adds a Render Texture to the Texture Manager using the given key.\r\n   * This allows you to then use the Render Texture as a normal texture for texture based Game Objects like Sprites.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addRenderTexture\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.12.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {Phaser.GameObjects.RenderTexture} renderTexture - The source Render Texture.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addRenderTexture: function addRenderTexture(key, renderTexture) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = this.create(key, renderTexture);\n      texture.add('__BASE', 0, 0, 0, renderTexture.width, renderTexture.height);\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Creates a new Texture using the given config values.\r\n   * Generated textures consist of a Canvas element to which the texture data is drawn.\r\n   * See the Phaser.Create function for the more direct way to create textures.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#generate\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {object} config - The configuration object needed to generate the texture.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  generate: function generate(key, config) {\n    if (this.checkKey(key)) {\n      var canvas = CanvasPool.create(this, 1, 1);\n      config.canvas = canvas;\n      GenerateTexture(config);\n      return this.addCanvas(key, canvas);\n    } else {\n      return null;\n    }\n  },\n\n  /**\r\n   * Creates a new Texture using a blank Canvas element of the size given.\r\n   *\r\n   * Canvas elements are automatically pooled and calling this method will\r\n   * extract a free canvas from the CanvasPool, or create one if none are available.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#createCanvas\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {integer} [width=256] - The width of the Canvas element.\r\n   * @param {integer} [height=256] - The height of the Canvas element.\r\n   *\r\n   * @return {?Phaser.Textures.CanvasTexture} The Canvas Texture that was created, or `null` if the key is already in use.\r\n   */\n  createCanvas: function createCanvas(key, width, height) {\n    if (width === undefined) {\n      width = 256;\n    }\n\n    if (height === undefined) {\n      height = 256;\n    }\n\n    if (this.checkKey(key)) {\n      var canvas = CanvasPool.create(this, width, height, CONST.CANVAS, true);\n      return this.addCanvas(key, canvas);\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Creates a new Canvas Texture object from an existing Canvas element\r\n   * and adds it to this Texture Manager, unless `skipCache` is true.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addCanvas\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLCanvasElement} source - The Canvas element to form the base of the new Texture.\r\n   * @param {boolean} [skipCache=false] - Skip adding this Texture into the Cache?\r\n   *\r\n   * @return {?Phaser.Textures.CanvasTexture} The Canvas Texture that was created, or `null` if the key is already in use.\r\n   */\n  addCanvas: function addCanvas(key, source, skipCache) {\n    if (skipCache === undefined) {\n      skipCache = false;\n    }\n\n    var texture = null;\n\n    if (skipCache) {\n      texture = new CanvasTexture(this, key, source, source.width, source.height);\n    } else if (this.checkKey(key)) {\n      texture = new CanvasTexture(this, key, source, source.width, source.height);\n      this.list[key] = texture;\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Adds a new Texture Atlas to this Texture Manager.\r\n   * It can accept either JSON Array or JSON Hash formats, as exported by Texture Packer and similar software.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addAtlas\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLImageElement} source - The source Image element.\r\n   * @param {object} data - The Texture Atlas data.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addAtlas: function addAtlas(key, source, data, dataSource) {\n    //  New Texture Packer format?\n    if (Array.isArray(data.textures) || Array.isArray(data.frames)) {\n      return this.addAtlasJSONArray(key, source, data, dataSource);\n    } else {\n      return this.addAtlasJSONHash(key, source, data, dataSource);\n    }\n  },\n\n  /**\r\n   * Adds a Texture Atlas to this Texture Manager.\r\n   * The frame data of the atlas must be stored in an Array within the JSON.\r\n   * This is known as a JSON Array in software such as Texture Packer.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addAtlasJSONArray\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(HTMLImageElement|HTMLImageElement[])} source - The source Image element/s.\r\n   * @param {(object|object[])} data - The Texture Atlas data/s.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addAtlasJSONArray: function addAtlasJSONArray(key, source, data, dataSource) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = this.create(key, source); //  Multi-Atlas?\n\n      if (Array.isArray(data)) {\n        var singleAtlasFile = data.length === 1; // multi-pack with one atlas file for all images\n        //  !! Assumes the textures are in the same order in the source array as in the json data !!\n\n        for (var i = 0; i < texture.source.length; i++) {\n          var atlasData = singleAtlasFile ? data[0] : data[i];\n          Parser.JSONArray(texture, i, atlasData);\n        }\n      } else {\n        Parser.JSONArray(texture, 0, data);\n      }\n\n      if (dataSource) {\n        texture.setDataSource(dataSource);\n      }\n\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Adds a Texture Atlas to this Texture Manager.\r\n   * The frame data of the atlas must be stored in an Object within the JSON.\r\n   * This is known as a JSON Hash in software such as Texture Packer.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addAtlasJSONHash\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLImageElement} source - The source Image element.\r\n   * @param {object} data - The Texture Atlas data.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addAtlasJSONHash: function addAtlasJSONHash(key, source, data, dataSource) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = this.create(key, source);\n\n      if (Array.isArray(data)) {\n        for (var i = 0; i < data.length; i++) {\n          Parser.JSONHash(texture, i, data[i]);\n        }\n      } else {\n        Parser.JSONHash(texture, 0, data);\n      }\n\n      if (dataSource) {\n        texture.setDataSource(dataSource);\n      }\n\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Adds a Texture Atlas to this Texture Manager, where the atlas data is given\r\n   * in the XML format.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addAtlasXML\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.7.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLImageElement} source - The source Image element.\r\n   * @param {object} data - The Texture Atlas XML data.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addAtlasXML: function addAtlasXML(key, source, data, dataSource) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = this.create(key, source);\n      Parser.AtlasXML(texture, 0, data);\n\n      if (dataSource) {\n        texture.setDataSource(dataSource);\n      }\n\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Adds a Unity Texture Atlas to this Texture Manager.\r\n   * The data must be in the form of a Unity YAML file.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addUnityAtlas\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLImageElement} source - The source Image element.\r\n   * @param {object} data - The Texture Atlas data.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addUnityAtlas: function addUnityAtlas(key, source, data, dataSource) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = this.create(key, source);\n      Parser.UnityYAML(texture, 0, data);\n\n      if (dataSource) {\n        texture.setDataSource(dataSource);\n      }\n\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * @typedef {object} SpriteSheetConfig\r\n   * \r\n   * @property {integer} frameWidth - The fixed width of each frame.\r\n   * @property {integer} [frameHeight] - The fixed height of each frame. If not set it will use the frameWidth as the height.\r\n   * @property {integer} [startFrame=0] - Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.\r\n   * @property {integer} [endFrame=-1] - The total number of frames to extract from the Sprite Sheet. The default value of -1 means \"extract all frames\".\r\n   * @property {integer} [margin=0] - If the frames have been drawn with a margin, specify the amount here.\r\n   * @property {integer} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.\r\n   */\n\n  /**\r\n   * Adds a Sprite Sheet to this Texture Manager.\r\n   *\r\n   * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact\r\n   * same size and cannot be trimmed or rotated.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addSpriteSheet\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLImageElement} source - The source Image element.\r\n   * @param {SpriteSheetConfig} config - The configuration object for this Sprite Sheet.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addSpriteSheet: function addSpriteSheet(key, source, config) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = this.create(key, source);\n      var width = texture.source[0].width;\n      var height = texture.source[0].height;\n      Parser.SpriteSheet(texture, 0, 0, 0, width, height, config);\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * @typedef {object} SpriteSheetFromAtlasConfig\r\n   * \r\n   * @property {string} atlas - The key of the Texture Atlas in which this Sprite Sheet can be found.\r\n   * @property {string} frame - The key of the Texture Atlas Frame in which this Sprite Sheet can be found.\r\n   * @property {integer} frameWidth - The fixed width of each frame.\r\n   * @property {integer} [frameHeight] - The fixed height of each frame. If not set it will use the frameWidth as the height.\r\n   * @property {integer} [startFrame=0] - Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.\r\n   * @property {integer} [endFrame=-1] - The total number of frames to extract from the Sprite Sheet. The default value of -1 means \"extract all frames\".\r\n   * @property {integer} [margin=0] - If the frames have been drawn with a margin, specify the amount here.\r\n   * @property {integer} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.\r\n   */\n\n  /**\r\n   * Adds a Sprite Sheet to this Texture Manager, where the Sprite Sheet exists as a Frame within a Texture Atlas.\r\n   *\r\n   * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact\r\n   * same size and cannot be trimmed or rotated.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addSpriteSheetFromAtlas\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {SpriteSheetFromAtlasConfig} config - The configuration object for this Sprite Sheet.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addSpriteSheetFromAtlas: function addSpriteSheetFromAtlas(key, config) {\n    if (!this.checkKey(key)) {\n      return null;\n    }\n\n    var atlasKey = GetValue(config, 'atlas', null);\n    var atlasFrame = GetValue(config, 'frame', null);\n\n    if (!atlasKey || !atlasFrame) {\n      return;\n    }\n\n    var atlas = this.get(atlasKey);\n    var sheet = atlas.get(atlasFrame);\n\n    if (sheet) {\n      var texture = this.create(key, sheet.source.image);\n\n      if (sheet.trimmed) {\n        //  If trimmed we need to help the parser adjust\n        Parser.SpriteSheetFromAtlas(texture, sheet, config);\n      } else {\n        Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config);\n      }\n\n      this.emit(Events.ADD, key, texture);\n      return texture;\n    }\n  },\n\n  /**\r\n   * Creates a new Texture using the given source and dimensions.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#create\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLImageElement} source - The source Image element.\r\n   * @param {integer} width - The width of the Texture.\r\n   * @param {integer} height - The height of the Texture.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  create: function create(key, source, width, height) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = new Texture(this, key, source, width, height);\n      this.list[key] = texture;\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Checks the given key to see if a Texture using it exists within this Texture Manager.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#exists\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   *\r\n   * @return {boolean} Returns `true` if a Texture matching the given key exists in this Texture Manager.\r\n   */\n  exists: function exists(key) {\n    return this.list.hasOwnProperty(key);\n  },\n\n  /**\r\n   * Returns a Texture from the Texture Manager that matches the given key.\r\n   * If the key is undefined it will return the `__DEFAULT` Texture.\r\n   * If the key is given, but not found, it will return the `__MISSING` Texture.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#get\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   *\r\n   * @return {Phaser.Textures.Texture} The Texture that was created.\r\n   */\n  get: function get(key) {\n    if (key === undefined) {\n      key = '__DEFAULT';\n    }\n\n    if (this.list[key]) {\n      return this.list[key];\n    } else {\n      return this.list['__MISSING'];\n    }\n  },\n\n  /**\r\n   * Takes a Texture key and Frame name and returns a clone of that Frame if found.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#cloneFrame\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(string|integer)} frame - The string or index of the Frame to be cloned.\r\n   *\r\n   * @return {Phaser.Textures.Frame} A Clone of the given Frame.\r\n   */\n  cloneFrame: function cloneFrame(key, frame) {\n    if (this.list[key]) {\n      return this.list[key].get(frame).clone();\n    }\n  },\n\n  /**\r\n   * Takes a Texture key and Frame name and returns a reference to that Frame, if found.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#getFrame\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(string|integer)} [frame] - The string-based name, or integer based index, of the Frame to get from the Texture.\r\n   *\r\n   * @return {Phaser.Textures.Frame} A Texture Frame object.\r\n   */\n  getFrame: function getFrame(key, frame) {\n    if (this.list[key]) {\n      return this.list[key].get(frame);\n    }\n  },\n\n  /**\r\n   * Returns an array with all of the keys of all Textures in this Texture Manager.\r\n   * The output array will exclude the `__DEFAULT` and `__MISSING` keys.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#getTextureKeys\r\n   * @since 3.0.0\r\n   *\r\n   * @return {string[]} An array containing all of the Texture keys stored in this Texture Manager.\r\n   */\n  getTextureKeys: function getTextureKeys() {\n    var output = [];\n\n    for (var key in this.list) {\n      if (key !== '__DEFAULT' && key !== '__MISSING') {\n        output.push(key);\n      }\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Given a Texture and an `x` and `y` coordinate this method will return a new\r\n   * Color object that has been populated with the color and alpha values of the pixel\r\n   * at that location in the Texture.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#getPixel\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} x - The x coordinate of the pixel within the Texture.\r\n   * @param {integer} y - The y coordinate of the pixel within the Texture.\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(string|integer)} [frame] - The string or index of the Frame.\r\n   *\r\n   * @return {?Phaser.Display.Color} A Color object populated with the color values of the requested pixel,\r\n   * or `null` if the coordinates were out of bounds.\r\n   */\n  getPixel: function getPixel(x, y, key, frame) {\n    var textureFrame = this.getFrame(key, frame);\n\n    if (textureFrame) {\n      //  Adjust for trim (if not trimmed x and y are just zero)\n      x -= textureFrame.x;\n      y -= textureFrame.y;\n      var data = textureFrame.data.cut;\n      x += data.x;\n      y += data.y;\n\n      if (x >= data.x && x < data.r && y >= data.y && y < data.b) {\n        var ctx = this._tempContext;\n        ctx.clearRect(0, 0, 1, 1);\n        ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);\n        var rgb = ctx.getImageData(0, 0, 1, 1);\n        return new Color(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);\n      }\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Given a Texture and an `x` and `y` coordinate this method will return a value between 0 and 255\r\n   * corresponding to the alpha value of the pixel at that location in the Texture. If the coordinate\r\n   * is out of bounds it will return null.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#getPixelAlpha\r\n   * @since 3.10.0\r\n   *\r\n   * @param {integer} x - The x coordinate of the pixel within the Texture.\r\n   * @param {integer} y - The y coordinate of the pixel within the Texture.\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(string|integer)} [frame] - The string or index of the Frame.\r\n   *\r\n   * @return {integer} A value between 0 and 255, or `null` if the coordinates were out of bounds.\r\n   */\n  getPixelAlpha: function getPixelAlpha(x, y, key, frame) {\n    var textureFrame = this.getFrame(key, frame);\n\n    if (textureFrame) {\n      //  Adjust for trim (if not trimmed x and y are just zero)\n      x -= textureFrame.x;\n      y -= textureFrame.y;\n      var data = textureFrame.data.cut;\n      x += data.x;\n      y += data.y;\n\n      if (x >= data.x && x < data.r && y >= data.y && y < data.b) {\n        var ctx = this._tempContext;\n        ctx.clearRect(0, 0, 1, 1);\n        ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);\n        var rgb = ctx.getImageData(0, 0, 1, 1);\n        return rgb.data[3];\n      }\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Sets the given Game Objects `texture` and `frame` properties so that it uses\r\n   * the Texture and Frame specified in the `key` and `frame` arguments to this method.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#setTexture\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object the texture would be set on.\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(string|integer)} [frame] - The string or index of the Frame.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject} The Game Object the texture was set on.\r\n   */\n  setTexture: function setTexture(gameObject, key, frame) {\n    if (this.list[key]) {\n      gameObject.texture = this.list[key];\n      gameObject.frame = gameObject.texture.get(frame);\n    }\n\n    return gameObject;\n  },\n\n  /**\r\n   * Changes the key being used by a Texture to the new key provided.\r\n   * \r\n   * The old key is removed, allowing it to be re-used.\r\n   * \r\n   * Game Objects are linked to Textures by a reference to the Texture object, so\r\n   * all existing references will be retained.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#renameTexture\r\n   * @since 3.12.0\r\n   *\r\n   * @param {string} currentKey - The current string-based key of the Texture you wish to rename.\r\n   * @param {string} newKey - The new unique string-based key to use for the Texture.\r\n   *\r\n   * @return {boolean} `true` if the Texture key was successfully renamed, otherwise `false`.\r\n   */\n  renameTexture: function renameTexture(currentKey, newKey) {\n    var texture = this.get(currentKey);\n\n    if (texture && currentKey !== newKey) {\n      texture.key = newKey;\n      this.list[newKey] = texture;\n      delete this.list[currentKey];\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Passes all Textures to the given callback.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#each\r\n   * @since 3.0.0\r\n   *\r\n   * @param {EachTextureCallback} callback - The callback function to be sent the Textures.\r\n   * @param {object} scope - The value to use as `this` when executing the callback.\r\n   * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n   */\n  each: function each(callback, scope) {\n    var args = [null];\n\n    for (var i = 1; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    for (var texture in this.list) {\n      args[0] = this.list[texture];\n      callback.apply(scope, args);\n    }\n  },\n\n  /**\r\n   * Destroys the Texture Manager and all Textures stored within it.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    for (var texture in this.list) {\n      this.list[texture].destroy();\n    }\n\n    this.list = {};\n    this.game = null;\n    CanvasPool.remove(this._tempCanvas);\n  }\n});\nmodule.exports = TextureManager;","map":null,"metadata":{},"sourceType":"script"}