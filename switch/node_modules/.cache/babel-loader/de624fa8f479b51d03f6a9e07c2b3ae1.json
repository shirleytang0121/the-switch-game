{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Circle = require('../geom/circle/Circle');\n\nvar CircleContains = require('../geom/circle/Contains');\n\nvar Class = require('../utils/Class');\n\nvar CreateInteractiveObject = require('./CreateInteractiveObject');\n\nvar CreatePixelPerfectHandler = require('./CreatePixelPerfectHandler');\n\nvar DistanceBetween = require('../math/distance/DistanceBetween');\n\nvar Ellipse = require('../geom/ellipse/Ellipse');\n\nvar EllipseContains = require('../geom/ellipse/Contains');\n\nvar Events = require('./events');\n\nvar EventEmitter = require('eventemitter3');\n\nvar GetFastValue = require('../utils/object/GetFastValue');\n\nvar InputPluginCache = require('./InputPluginCache');\n\nvar IsPlainObject = require('../utils/object/IsPlainObject');\n\nvar PluginCache = require('../plugins/PluginCache');\n\nvar Rectangle = require('../geom/rectangle/Rectangle');\n\nvar RectangleContains = require('../geom/rectangle/Contains');\n\nvar SceneEvents = require('../scene/events');\n\nvar Triangle = require('../geom/triangle/Triangle');\n\nvar TriangleContains = require('../geom/triangle/Contains');\n/**\r\n * @classdesc\r\n * The Input Plugin belongs to a Scene and handles all input related events and operations for it.\r\n *\r\n * You can access it from within a Scene using `this.input`.\r\n *\r\n * It emits events directly. For example, you can do:\r\n *\r\n * ```javascript\r\n * this.input.on('pointerdown', callback, context);\r\n * ```\r\n *\r\n * To listen for a pointer down event anywhere on the game canvas.\r\n *\r\n * Game Objects can be enabled for input by calling their `setInteractive` method. After which they\r\n * will directly emit input events:\r\n *\r\n * ```javascript\r\n * var sprite = this.add.sprite(x, y, texture);\r\n * sprite.setInteractive();\r\n * sprite.on('pointerdown', callback, context);\r\n * ```\r\n *\r\n * Please see the Input examples and tutorials for more information.\r\n *\r\n * @class InputPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that this Input Plugin is responsible for.\r\n */\n\n\nvar InputPlugin = new Class({\n  Extends: EventEmitter,\n  initialize: function InputPlugin(scene) {\n    EventEmitter.call(this);\n    /**\r\n     * A reference to the Scene that this Input Plugin is responsible for.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n\n    this.scene = scene;\n    /**\r\n     * A reference to the Scene Systems class.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#systems\r\n     * @type {Phaser.Scenes.Systems}\r\n     * @since 3.0.0\r\n     */\n\n    this.systems = scene.sys;\n    /**\r\n     * A reference to the Scene Systems Settings.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#settings\r\n     * @type {Phaser.Scenes.Settings.Object}\r\n     * @since 3.5.0\r\n     */\n\n    this.settings = scene.sys.settings;\n    /**\r\n     * A reference to the Game Input Manager.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#manager\r\n     * @type {Phaser.Input.InputManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.manager = scene.sys.game.input;\n    /**\r\n     * Internal event queue used for plugins only.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pluginEvents\r\n     * @type {Phaser.Events.EventEmitter}\r\n     * @private\r\n     * @since 3.10.0\r\n     */\n\n    this.pluginEvents = new EventEmitter();\n    /**\r\n     * If set, the Input Plugin will run its update loop every frame.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#enabled\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.5.0\r\n     */\n\n    this.enabled = true;\n    /**\r\n     * A reference to the Scene Display List. This property is set during the `boot` method.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#displayList\r\n     * @type {Phaser.GameObjects.DisplayList}\r\n     * @since 3.0.0\r\n     */\n\n    this.displayList;\n    /**\r\n     * A reference to the Scene Cameras Manager. This property is set during the `boot` method.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#cameras\r\n     * @type {Phaser.Cameras.Scene2D.CameraManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.cameras; //  Inject the available input plugins into this class\n\n    InputPluginCache.install(this);\n    /**\r\n     * A reference to the Mouse Manager.\r\n     * \r\n     * This property is only set if Mouse support has been enabled in your Game Configuration file.\r\n     * \r\n     * If you just wish to get access to the mouse pointer, use the `mousePointer` property instead.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#mouse\r\n     * @type {?Phaser.Input.Mouse.MouseManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.mouse = this.manager.mouse;\n    /**\r\n     * When set to `true` (the default) the Input Plugin will emulate DOM behavior by only emitting events from\r\n     * the top-most Game Objects in the Display List.\r\n     *\r\n     * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#topOnly\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.topOnly = true;\n    /**\r\n     * How often should the Pointers be checked?\r\n     * \r\n     * The value is a time, given in ms, and is the time that must have elapsed between game steps before\r\n     * the Pointers will be polled again. When a pointer is polled it runs a hit test to see which Game\r\n     * Objects are currently below it, or being interacted with it.\r\n     * \r\n     * Pointers will *always* be checked if they have been moved by the user, or press or released.\r\n     * \r\n     * This property only controls how often they will be polled if they have not been updated.\r\n     * You should set this if you want to have Game Objects constantly check against the pointers, even\r\n     * if the pointer didn't move itself.\r\n     * \r\n     * Set to 0 to poll constantly. Set to -1 to only poll on user movement.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pollRate\r\n     * @type {integer}\r\n     * @default -1\r\n     * @since 3.0.0\r\n     */\n\n    this.pollRate = -1;\n    /**\r\n     * Internal poll timer value.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_pollTimer\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this._pollTimer = 0;\n    var _eventData = {\n      cancelled: false\n    };\n    /**\r\n     * Internal event propagation callback container.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_eventContainer\r\n     * @type {Phaser.Input.EventData}\r\n     * @private\r\n     * @since 3.13.0\r\n     */\n\n    this._eventContainer = {\n      stopPropagation: function stopPropagation() {\n        _eventData.cancelled = true;\n      }\n    };\n    /**\r\n     * Internal event propagation data object.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_eventData\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.13.0\r\n     */\n\n    this._eventData = _eventData;\n    /**\r\n     * The distance, in pixels, a pointer has to move while being held down, before it thinks it is being dragged.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#dragDistanceThreshold\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.dragDistanceThreshold = 0;\n    /**\r\n     * The amount of time, in ms, a pointer has to be held down before it thinks it is dragging.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#dragTimeThreshold\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.dragTimeThreshold = 0;\n    /**\r\n     * Used to temporarily store the results of the Hit Test\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_temp\r\n     * @type {array}\r\n     * @private\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this._temp = [];\n    /**\r\n     * Used to temporarily store the results of the Hit Test dropZones\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_tempZones\r\n     * @type {array}\r\n     * @private\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this._tempZones = [];\n    /**\r\n     * A list of all Game Objects that have been set to be interactive in the Scene this Input Plugin is managing.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_list\r\n     * @type {Phaser.GameObjects.GameObject[]}\r\n     * @private\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this._list = [];\n    /**\r\n     * Objects waiting to be inserted to the list on the next call to 'begin'.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_pendingInsertion\r\n     * @type {Phaser.GameObjects.GameObject[]}\r\n     * @private\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this._pendingInsertion = [];\n    /**\r\n     * Objects waiting to be removed from the list on the next call to 'begin'.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_pendingRemoval\r\n     * @type {Phaser.GameObjects.GameObject[]}\r\n     * @private\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this._pendingRemoval = [];\n    /**\r\n     * A list of all Game Objects that have been enabled for dragging.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_draggable\r\n     * @type {Phaser.GameObjects.GameObject[]}\r\n     * @private\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this._draggable = [];\n    /**\r\n     * A list of all Interactive Objects currently considered as being 'draggable' by any pointer, indexed by pointer ID.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_drag\r\n     * @type {{0:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array}}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._drag = {\n      0: [],\n      1: [],\n      2: [],\n      3: [],\n      4: [],\n      5: [],\n      6: [],\n      7: [],\n      8: [],\n      9: [],\n      10: []\n    };\n    /**\r\n     * A array containing the dragStates, for this Scene, index by the Pointer ID.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_dragState\r\n     * @type {integer[]}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this._dragState = [];\n    /**\r\n     * A list of all Interactive Objects currently considered as being 'over' by any pointer, indexed by pointer ID.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_over\r\n     * @type {{0:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array}}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._over = {\n      0: [],\n      1: [],\n      2: [],\n      3: [],\n      4: [],\n      5: [],\n      6: [],\n      7: [],\n      8: [],\n      9: [],\n      10: []\n    };\n    /**\r\n     * A list of valid DOM event types.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_validTypes\r\n     * @type {string[]}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._validTypes = ['onDown', 'onUp', 'onOver', 'onOut', 'onMove', 'onDragStart', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragLeave', 'onDragOver', 'onDrop'];\n    scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\n    scene.sys.events.on(SceneEvents.START, this.start, this);\n  },\n\n  /**\r\n   * This method is called automatically, only once, when the Scene is first created.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#boot\r\n   * @fires Phaser.Input.Events#BOOT\r\n   * @private\r\n   * @since 3.5.1\r\n   */\n  boot: function boot() {\n    this.cameras = this.systems.cameras;\n    this.displayList = this.systems.displayList;\n    this.systems.events.once(SceneEvents.DESTROY, this.destroy, this); //  Registered input plugins listen for this\n\n    this.pluginEvents.emit(Events.BOOT);\n  },\n\n  /**\r\n   * This method is called automatically by the Scene when it is starting up.\r\n   * It is responsible for creating local systems, properties and listening for Scene events.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#start\r\n   * @fires Phaser.Input.Events#START\r\n   * @private\r\n   * @since 3.5.0\r\n   */\n  start: function start() {\n    var eventEmitter = this.systems.events;\n    eventEmitter.on(SceneEvents.TRANSITION_START, this.transitionIn, this);\n    eventEmitter.on(SceneEvents.TRANSITION_OUT, this.transitionOut, this);\n    eventEmitter.on(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);\n    eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);\n\n    if (this.manager.useQueue) {\n      eventEmitter.on(SceneEvents.UPDATE, this.update, this);\n    }\n\n    eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\n    this.manager.events.on(Events.GAME_OUT, this.onGameOut, this);\n    this.manager.events.on(Events.GAME_OVER, this.onGameOver, this);\n    this.enabled = true; //  Populate the pointer drag states\n\n    this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; //  Registered input plugins listen for this\n\n    this.pluginEvents.emit(Events.START);\n  },\n\n  /**\r\n   * Game Over handler.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#onGameOver\r\n   * @fires Phaser.Input.Events#GAME_OVER\r\n   * @private\r\n   * @since 3.16.2\r\n   */\n  onGameOver: function onGameOver(event) {\n    if (this.isActive()) {\n      this.emit(Events.GAME_OVER, event.timeStamp, event);\n    }\n  },\n\n  /**\r\n   * Game Out handler.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#onGameOut\r\n   * @fires Phaser.Input.Events#GAME_OUT\r\n   * @private\r\n   * @since 3.16.2\r\n   */\n  onGameOut: function onGameOut(event) {\n    if (this.isActive()) {\n      this.emit(Events.GAME_OUT, event.timeStamp, event);\n    }\n  },\n\n  /**\r\n   * The pre-update handler is responsible for checking the pending removal and insertion lists and\r\n   * deleting old Game Objects.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#preUpdate\r\n   * @fires Phaser.Input.Events#PRE_UPDATE\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  preUpdate: function preUpdate() {\n    //  Registered input plugins listen for this\n    this.pluginEvents.emit(Events.PRE_UPDATE);\n    var removeList = this._pendingRemoval;\n    var insertList = this._pendingInsertion;\n    var toRemove = removeList.length;\n    var toInsert = insertList.length;\n\n    if (toRemove === 0 && toInsert === 0) {\n      //  Quick bail\n      return;\n    }\n\n    var current = this._list; //  Delete old gameObjects\n\n    for (var i = 0; i < toRemove; i++) {\n      var gameObject = removeList[i];\n      var index = current.indexOf(gameObject);\n\n      if (index > -1) {\n        current.splice(index, 1);\n        this.clear(gameObject);\n      }\n    } //  Clear the removal list\n\n\n    removeList.length = 0;\n    this._pendingRemoval.length = 0; //  Move pendingInsertion to list (also clears pendingInsertion at the same time)\n\n    this._list = current.concat(insertList.splice(0));\n  },\n\n  /**\r\n   * Checks to see if both this plugin and the Scene to which it belongs is active.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#isActive\r\n   * @since 3.10.0\r\n   *\r\n   * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n   */\n  isActive: function isActive() {\n    return this.enabled && this.scene.sys.isActive();\n  },\n\n  /**\r\n   * The internal update loop for the Input Plugin.\r\n   * Called automatically by the Scene Systems step.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#update\r\n   * @fires Phaser.Input.Events#UPDATE\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} time - The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().\r\n   * @param {number} delta - The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.\r\n   */\n  update: function update(time, delta) {\n    if (!this.isActive()) {\n      return;\n    }\n\n    var manager = this.manager;\n    this.pluginEvents.emit(Events.UPDATE, time, delta); //  Another Scene above this one has already consumed the input events, or we're in transition\n\n    if (manager.globalTopOnly && manager.ignoreEvents) {\n      return;\n    }\n\n    var runUpdate = manager.dirty || this.pollRate === 0;\n\n    if (this.pollRate > -1) {\n      this._pollTimer -= delta;\n\n      if (this._pollTimer < 0) {\n        runUpdate = true; //  Discard timer diff\n\n        this._pollTimer = this.pollRate;\n      }\n    }\n\n    if (!runUpdate) {\n      return;\n    }\n\n    var pointers = this.manager.pointers;\n    var pointersTotal = this.manager.pointersTotal;\n\n    for (var i = 0; i < pointersTotal; i++) {\n      var pointer = pointers[i]; //  Always reset this array\n\n      this._tempZones = []; //  _temp contains a hit tested and camera culled list of IO objects\n\n      this._temp = this.hitTestPointer(pointer);\n      this.sortGameObjects(this._temp);\n      this.sortGameObjects(this._tempZones);\n\n      if (this.topOnly) {\n        //  Only the top-most one counts now, so safely ignore the rest\n        if (this._temp.length) {\n          this._temp.splice(1);\n        }\n\n        if (this._tempZones.length) {\n          this._tempZones.splice(1);\n        }\n      }\n\n      var total = this.processDragEvents(pointer, time); //  TODO: Enable for touch - the method needs recoding to take ALL pointers at once\n      //  and process them all together, in the same batch, otherwise the justOut and stillOver\n      //  arrays will get corrupted in multi-touch enabled games. For now, we'll enable it for\n      //  single touch games (which is probably the majority anyway).\n\n      if (pointersTotal < 3 || !pointer.wasTouch) {\n        total += this.processOverOutEvents(pointer);\n      }\n\n      if (pointer.justDown) {\n        total += this.processDownEvents(pointer);\n      }\n\n      if (pointer.justMoved) {\n        total += this.processMoveEvents(pointer);\n      }\n\n      if (pointer.justUp) {\n        total += this.processUpEvents(pointer);\n      }\n\n      if (total > 0 && manager.globalTopOnly) {\n        //  We interacted with an event in this Scene, so block any Scenes below us from doing the same this frame\n        manager.ignoreEvents = true;\n      }\n    }\n  },\n\n  /**\r\n   * Clears a Game Object so it no longer has an Interactive Object associated with it.\r\n   * The Game Object is then queued for removal from the Input Plugin on the next update.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#clear\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will have its Interactive Object removed.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject} The Game Object that had its Interactive Object removed.\r\n   */\n  clear: function clear(gameObject) {\n    var input = gameObject.input; // If GameObject.input already cleared from higher class\n\n    if (!input) {\n      return;\n    }\n\n    this.queueForRemoval(gameObject);\n    input.gameObject = undefined;\n    input.target = undefined;\n    input.hitArea = undefined;\n    input.hitAreaCallback = undefined;\n    input.callbackContext = undefined;\n    this.manager.resetCursor(input);\n    gameObject.input = null; //  Clear from _draggable, _drag and _over\n\n    var index = this._draggable.indexOf(gameObject);\n\n    if (index > -1) {\n      this._draggable.splice(index, 1);\n    }\n\n    index = this._drag[0].indexOf(gameObject);\n\n    if (index > -1) {\n      this._drag[0].splice(index, 1);\n    }\n\n    index = this._over[0].indexOf(gameObject);\n\n    if (index > -1) {\n      this._over[0].splice(index, 1);\n    }\n\n    return gameObject;\n  },\n\n  /**\r\n   * Disables Input on a single Game Object.\r\n   *\r\n   * An input disabled Game Object still retains its Interactive Object component and can be re-enabled\r\n   * at any time, by passing it to `InputPlugin.enable`.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#disable\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to have its input system disabled.\r\n   */\n  disable: function disable(gameObject) {\n    gameObject.input.enabled = false;\n  },\n\n  /**\r\n   * Enable a Game Object for interaction.\r\n   *\r\n   * If the Game Object already has an Interactive Object component, it is enabled and returned.\r\n   *\r\n   * Otherwise, a new Interactive Object component is created and assigned to the Game Object's `input` property.\r\n   *\r\n   * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area\r\n   * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced\r\n   * input detection.\r\n   *\r\n   * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If\r\n   * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific\r\n   * shape for it to use.\r\n   *\r\n   * You can also provide an Input Configuration Object as the only argument to this method.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#enable\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to be enabled for input.\r\n   * @param {(Phaser.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n   * @param {HitAreaCallback} [callback] - The 'contains' function to invoke to check if the pointer is within the hit area.\r\n   * @param {boolean} [dropZone=false] - Is this Game Object a drop zone or not?\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This Input Plugin.\r\n   */\n  enable: function enable(gameObject, shape, callback, dropZone) {\n    if (dropZone === undefined) {\n      dropZone = false;\n    }\n\n    if (gameObject.input) {\n      //  If it is already has an InteractiveObject then just enable it and return\n      gameObject.input.enabled = true;\n    } else {\n      //  Create an InteractiveObject and enable it\n      this.setHitArea(gameObject, shape, callback);\n    }\n\n    if (gameObject.input && dropZone && !gameObject.input.dropZone) {\n      gameObject.input.dropZone = dropZone;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Takes the given Pointer and performs a hit test against it, to see which interactive Game Objects\r\n   * it is currently above.\r\n   *\r\n   * The hit test is performed against which-ever Camera the Pointer is over. If it is over multiple\r\n   * cameras, it starts checking the camera at the top of the camera list, and if nothing is found, iterates down the list.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#hitTestPointer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to check against the Game Objects.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject[]} An array of all the interactive Game Objects the Pointer was above.\r\n   */\n  hitTestPointer: function hitTestPointer(pointer) {\n    var cameras = this.cameras.getCamerasBelowPointer(pointer);\n\n    for (var c = 0; c < cameras.length; c++) {\n      var camera = cameras[c]; //  Get a list of all objects that can be seen by the camera below the pointer in the scene and store in 'over' array.\n      //  All objects in this array are input enabled, as checked by the hitTest method, so we don't need to check later on as well.\n\n      var over = this.manager.hitTest(pointer, this._list, camera); //  Filter out the drop zones\n\n      for (var i = 0; i < over.length; i++) {\n        var obj = over[i];\n\n        if (obj.input.dropZone) {\n          this._tempZones.push(obj);\n        }\n      }\n\n      if (over.length > 0) {\n        pointer.camera = camera;\n        return over;\n      }\n    } //  If we got this far then there were no Game Objects below the pointer, but it was still over\n    //  a camera, so set that the top-most one into the pointer\n\n\n    pointer.camera = cameras[0];\n    return [];\n  },\n\n  /**\r\n   * An internal method that handles the Pointer down event.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processDownEvents\r\n   * @private\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_DOWN\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DOWN\r\n   * @fires Phaser.Input.Events#POINTER_DOWN\r\n   * @fires Phaser.Input.Events#POINTER_DOWN_OUTSIDE\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer being tested.\r\n   *\r\n   * @return {integer} The total number of objects interacted with.\r\n   */\n  processDownEvents: function processDownEvents(pointer) {\n    var total = 0;\n    var currentlyOver = this._temp;\n    var _eventData = this._eventData;\n    var _eventContainer = this._eventContainer;\n    _eventData.cancelled = false;\n    var aborted = false; //  Go through all objects the pointer was over and fire their events / callbacks\n\n    for (var i = 0; i < currentlyOver.length; i++) {\n      var gameObject = currentlyOver[i];\n\n      if (!gameObject.input) {\n        continue;\n      }\n\n      total++;\n      gameObject.emit(Events.GAMEOBJECT_POINTER_DOWN, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\n\n      if (_eventData.cancelled) {\n        aborted = true;\n        break;\n      }\n\n      this.emit(Events.GAMEOBJECT_DOWN, pointer, gameObject, _eventContainer);\n\n      if (_eventData.cancelled) {\n        aborted = true;\n        break;\n      }\n    } //  If they released outside the canvas, but pressed down inside it, we'll still dispatch the event.\n\n\n    if (!aborted) {\n      if (pointer.downElement === this.manager.game.canvas) {\n        this.emit(Events.POINTER_DOWN, pointer, currentlyOver);\n      } else {\n        this.emit(Events.POINTER_DOWN_OUTSIDE, pointer);\n      }\n    }\n\n    return total;\n  },\n\n  /**\r\n   * Returns the drag state of the given Pointer for this Input Plugin.\r\n   * \r\n   * The state will be one of the following:\r\n   * \r\n   * 0 = Not dragging anything\r\n   * 1 = Primary button down and objects below, so collect a draglist\r\n   * 2 = Pointer being checked if meets drag criteria\r\n   * 3 = Pointer meets criteria, notify the draglist\r\n   * 4 = Pointer actively dragging the draglist and has moved\r\n   * 5 = Pointer actively dragging but has been released, notify draglist\r\n   *\r\n   * @method Phaser.Input.InputPlugin#getDragState\r\n   * @since 3.16.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to get the drag state for.\r\n   *\r\n   * @return {integer} The drag state of the given Pointer.\r\n   */\n  getDragState: function getDragState(pointer) {\n    return this._dragState[pointer.id];\n  },\n\n  /**\r\n   * Sets the drag state of the given Pointer for this Input Plugin.\r\n   * \r\n   * The state must be one of the following values:\r\n   * \r\n   * 0 = Not dragging anything\r\n   * 1 = Primary button down and objects below, so collect a draglist\r\n   * 2 = Pointer being checked if meets drag criteria\r\n   * 3 = Pointer meets criteria, notify the draglist\r\n   * 4 = Pointer actively dragging the draglist and has moved\r\n   * 5 = Pointer actively dragging but has been released, notify draglist\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setDragState\r\n   * @since 3.16.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to set the drag state for.\r\n   * @param {integer} state - The drag state value. An integer between 0 and 5.\r\n   */\n  setDragState: function setDragState(pointer, state) {\n    this._dragState[pointer.id] = state;\n  },\n\n  /**\r\n   * An internal method that handles the Pointer drag events.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processDragEvents\r\n   * @private\r\n   * @fires Phaser.Input.Events#DRAG_END\r\n   * @fires Phaser.Input.Events#DRAG_ENTER\r\n   * @fires Phaser.Input.Events#DRAG\r\n   * @fires Phaser.Input.Events#DRAG_LEAVE\r\n   * @fires Phaser.Input.Events#DRAG_OVER\r\n   * @fires Phaser.Input.Events#DRAG_START\r\n   * @fires Phaser.Input.Events#DROP\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DOWN\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_END\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_ENTER\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DRAG\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_LEAVE\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_OVER\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_START\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DROP\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to check against the Game Objects.\r\n   * @param {number} time - The time stamp of the most recent Game step.\r\n   *\r\n   * @return {integer} The total number of objects interacted with.\r\n   */\n  processDragEvents: function processDragEvents(pointer, time) {\n    if (this._draggable.length === 0) {\n      //  There are no draggable items, so let's not even bother going further\n      return 0;\n    }\n\n    var i;\n    var gameObject;\n    var list;\n    var input;\n    var currentlyOver = this._temp; //  0 = Not dragging anything\n    //  1 = Primary button down and objects below, so collect a draglist\n    //  2 = Pointer being checked if meets drag criteria\n    //  3 = Pointer meets criteria, notify the draglist\n    //  4 = Pointer actively dragging the draglist and has moved\n    //  5 = Pointer actively dragging but has been released, notify draglist\n\n    if (this.getDragState(pointer) === 0 && pointer.primaryDown && pointer.justDown && currentlyOver.length > 0) {\n      this.setDragState(pointer, 1);\n    } else if (this.getDragState(pointer) > 0 && !pointer.primaryDown && pointer.justUp) {\n      this.setDragState(pointer, 5);\n    } //  Process the various drag states\n    //  1 = Primary button down and objects below, so collect a draglist\n\n\n    if (this.getDragState(pointer) === 1) {\n      //  Get draggable objects, sort them, pick the top (or all) and store them somewhere\n      var draglist = [];\n\n      for (i = 0; i < currentlyOver.length; i++) {\n        gameObject = currentlyOver[i];\n\n        if (gameObject.input.draggable && gameObject.input.dragState === 0) {\n          draglist.push(gameObject);\n        }\n      }\n\n      if (draglist.length === 0) {\n        this.setDragState(pointer, 0);\n        return 0;\n      } else if (draglist.length > 1) {\n        this.sortGameObjects(draglist);\n\n        if (this.topOnly) {\n          draglist.splice(1);\n        }\n      } //  draglist now contains all potential candidates for dragging\n\n\n      this._drag[pointer.id] = draglist;\n\n      if (this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0) {\n        //  No drag criteria, so snap immediately to mode 3\n        this.setDragState(pointer, 3);\n      } else {\n        //  Check the distance / time\n        this.setDragState(pointer, 2);\n      }\n    } //  2 = Pointer being checked if meets drag criteria\n\n\n    if (this.getDragState(pointer) === 2) {\n      //  Has it moved far enough to be considered a drag?\n      if (this.dragDistanceThreshold > 0 && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= this.dragDistanceThreshold) {\n        //  Alrighty, we've got a drag going on ...\n        this.setDragState(pointer, 3);\n      } //  Held down long enough to be considered a drag?\n\n\n      if (this.dragTimeThreshold > 0 && time >= pointer.downTime + this.dragTimeThreshold) {\n        //  Alrighty, we've got a drag going on ...\n        this.setDragState(pointer, 3);\n      }\n    } //  3 = Pointer meets criteria and is freshly down, notify the draglist\n\n\n    if (this.getDragState(pointer) === 3) {\n      list = this._drag[pointer.id];\n\n      for (i = 0; i < list.length; i++) {\n        gameObject = list[i];\n        input = gameObject.input;\n        input.dragState = 2;\n        input.dragX = pointer.x - gameObject.x;\n        input.dragY = pointer.y - gameObject.y;\n        input.dragStartX = gameObject.x;\n        input.dragStartY = gameObject.y;\n        gameObject.emit(Events.GAMEOBJECT_DRAG_START, pointer, input.dragX, input.dragY);\n        this.emit(Events.DRAG_START, pointer, gameObject);\n      }\n\n      this.setDragState(pointer, 4);\n      return list.length;\n    } //  4 = Pointer actively dragging the draglist and has moved\n\n\n    if (this.getDragState(pointer) === 4 && pointer.justMoved && !pointer.justUp) {\n      var dropZones = this._tempZones;\n      list = this._drag[pointer.id];\n\n      for (i = 0; i < list.length; i++) {\n        gameObject = list[i];\n        input = gameObject.input; //  If this GO has a target then let's check it\n\n        if (input.target) {\n          var index = dropZones.indexOf(input.target); //  Got a target, are we still over it?\n\n          if (index === 0) {\n            //  We're still over it, and it's still the top of the display list, phew ...\n            gameObject.emit(Events.GAMEOBJECT_DRAG_OVER, pointer, input.target);\n            this.emit(Events.DRAG_OVER, pointer, gameObject, input.target);\n          } else if (index > 0) {\n            //  Still over it but it's no longer top of the display list (targets must always be at the top)\n            gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, input.target);\n            this.emit(Events.DRAG_LEAVE, pointer, gameObject, input.target);\n            input.target = dropZones[0];\n            gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, input.target);\n            this.emit(Events.DRAG_ENTER, pointer, gameObject, input.target);\n          } else {\n            //  Nope, we've moved on (or the target has!), leave the old target\n            gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, input.target);\n            this.emit(Events.DRAG_LEAVE, pointer, gameObject, input.target); //  Anything new to replace it?\n            //  Yup!\n\n            if (dropZones[0]) {\n              input.target = dropZones[0];\n              gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, input.target);\n              this.emit(Events.DRAG_ENTER, pointer, gameObject, input.target);\n            } else {\n              //  Nope\n              input.target = null;\n            }\n          }\n        } else if (!input.target && dropZones[0]) {\n          input.target = dropZones[0];\n          gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, input.target);\n          this.emit(Events.DRAG_ENTER, pointer, gameObject, input.target);\n        }\n\n        var dragX = pointer.x - gameObject.input.dragX;\n        var dragY = pointer.y - gameObject.input.dragY;\n        gameObject.emit(Events.GAMEOBJECT_DRAG, pointer, dragX, dragY);\n        this.emit(Events.DRAG, pointer, gameObject, dragX, dragY);\n      }\n\n      return list.length;\n    } //  5 = Pointer was actively dragging but has been released, notify draglist\n\n\n    if (this.getDragState(pointer) === 5) {\n      list = this._drag[pointer.id];\n\n      for (i = 0; i < list.length; i++) {\n        gameObject = list[i];\n        input = gameObject.input;\n\n        if (input.dragState === 2) {\n          input.dragState = 0;\n          input.dragX = input.localX - gameObject.displayOriginX;\n          input.dragY = input.localY - gameObject.displayOriginY;\n          var dropped = false;\n\n          if (input.target) {\n            gameObject.emit(Events.GAMEOBJECT_DROP, pointer, input.target);\n            this.emit(Events.DROP, pointer, gameObject, input.target);\n            input.target = null;\n            dropped = true;\n          } //  And finally the dragend event\n\n\n          gameObject.emit(Events.GAMEOBJECT_DRAG_END, pointer, input.dragX, input.dragY, dropped);\n          this.emit(Events.DRAG_END, pointer, gameObject, dropped);\n        }\n      }\n\n      this.setDragState(pointer, 0);\n      list.splice(0);\n    }\n\n    return 0;\n  },\n\n  /**\r\n   * An internal method that handles the Pointer movement event.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processMoveEvents\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_MOVE\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_MOVE\r\n   * @fires Phaser.Input.Events#POINTER_MOVE\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n   *\r\n   * @return {integer} The total number of objects interacted with.\r\n   */\n  processMoveEvents: function processMoveEvents(pointer) {\n    var total = 0;\n    var currentlyOver = this._temp;\n    var _eventData = this._eventData;\n    var _eventContainer = this._eventContainer;\n    _eventData.cancelled = false;\n    var aborted = false; //  Go through all objects the pointer was over and fire their events / callbacks\n\n    for (var i = 0; i < currentlyOver.length; i++) {\n      var gameObject = currentlyOver[i];\n\n      if (!gameObject.input) {\n        continue;\n      }\n\n      total++;\n      gameObject.emit(Events.GAMEOBJECT_POINTER_MOVE, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\n\n      if (_eventData.cancelled) {\n        aborted = true;\n        break;\n      }\n\n      this.emit(Events.GAMEOBJECT_MOVE, pointer, gameObject, _eventContainer);\n\n      if (_eventData.cancelled) {\n        aborted = true;\n        break;\n      }\n\n      if (this.topOnly) {\n        break;\n      }\n    }\n\n    if (!aborted) {\n      this.emit(Events.POINTER_MOVE, pointer, currentlyOver);\n    }\n\n    return total;\n  },\n\n  /**\r\n   * An internal method that handles the Pointer over and out events.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processOverOutEvents\r\n   * @private\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OVER\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_OVER\r\n   * @fires Phaser.Input.Events#POINTER_OVER\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OUT\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_OUT\r\n   * @fires Phaser.Input.Events#POINTER_OUT\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n   *\r\n   * @return {integer} The total number of objects interacted with.\r\n   */\n  processOverOutEvents: function processOverOutEvents(pointer) {\n    var currentlyOver = this._temp;\n    var i;\n    var gameObject;\n    var justOut = [];\n    var justOver = [];\n    var stillOver = [];\n    var previouslyOver = this._over[pointer.id];\n    var currentlyDragging = this._drag[pointer.id];\n    var manager = this.manager; //  Go through all objects the pointer was previously over, and see if it still is.\n    //  Splits the previouslyOver array into two parts: justOut and stillOver\n\n    for (i = 0; i < previouslyOver.length; i++) {\n      gameObject = previouslyOver[i];\n\n      if (currentlyOver.indexOf(gameObject) === -1 && currentlyDragging.indexOf(gameObject) === -1) {\n        //  Not in the currentlyOver array, so must be outside of this object now\n        justOut.push(gameObject);\n      } else {\n        //  In the currentlyOver array\n        stillOver.push(gameObject);\n      }\n    } //  Go through all objects the pointer is currently over (the hit test results)\n    //  and if not in the previouslyOver array we know it's a new entry, so add to justOver\n\n\n    for (i = 0; i < currentlyOver.length; i++) {\n      gameObject = currentlyOver[i]; //  Is this newly over?\n\n      if (previouslyOver.indexOf(gameObject) === -1) {\n        justOver.push(gameObject);\n      }\n    } //  By this point the arrays are filled, so now we can process what happened...\n    //  Process the Just Out objects\n\n\n    var total = justOut.length;\n    var totalInteracted = 0;\n    var _eventData = this._eventData;\n    var _eventContainer = this._eventContainer;\n    _eventData.cancelled = false;\n    var aborted = false;\n\n    if (total > 0) {\n      this.sortGameObjects(justOut); //  Call onOut for everything in the justOut array\n\n      for (i = 0; i < total; i++) {\n        gameObject = justOut[i];\n\n        if (!gameObject.input) {\n          continue;\n        }\n\n        gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);\n        manager.resetCursor(gameObject.input);\n        totalInteracted++;\n\n        if (_eventData.cancelled) {\n          aborted = true;\n          break;\n        }\n\n        this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);\n\n        if (_eventData.cancelled) {\n          aborted = true;\n          break;\n        }\n      }\n\n      if (!aborted) {\n        this.emit(Events.POINTER_OUT, pointer, justOut);\n      }\n    } //  Process the Just Over objects\n\n\n    total = justOver.length;\n    _eventData.cancelled = false;\n    aborted = false;\n\n    if (total > 0) {\n      this.sortGameObjects(justOver); //  Call onOver for everything in the justOver array\n\n      for (i = 0; i < total; i++) {\n        gameObject = justOver[i];\n\n        if (!gameObject.input) {\n          continue;\n        }\n\n        gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\n        manager.setCursor(gameObject.input);\n        totalInteracted++;\n\n        if (_eventData.cancelled) {\n          aborted = true;\n          break;\n        }\n\n        this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);\n\n        if (_eventData.cancelled) {\n          aborted = true;\n          break;\n        }\n      }\n\n      if (!aborted) {\n        this.emit(Events.POINTER_OVER, pointer, justOver);\n      }\n    } //  Add the contents of justOver to the previously over array\n\n\n    previouslyOver = stillOver.concat(justOver); //  Then sort it into display list order\n\n    this._over[pointer.id] = this.sortGameObjects(previouslyOver);\n    return totalInteracted;\n  },\n\n  /**\r\n   * An internal method that handles the Pointer up events.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processUpEvents\r\n   * @private\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_UP\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_UP\r\n   * @fires Phaser.Input.Events#POINTER_UP\r\n   * @fires Phaser.Input.Events#POINTER_UP_OUTSIDE\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n   *\r\n   * @return {integer} The total number of objects interacted with.\r\n   */\n  processUpEvents: function processUpEvents(pointer) {\n    var currentlyOver = this._temp;\n    var _eventData = this._eventData;\n    var _eventContainer = this._eventContainer;\n    _eventData.cancelled = false;\n    var aborted = false; //  Go through all objects the pointer was over and fire their events / callbacks\n\n    for (var i = 0; i < currentlyOver.length; i++) {\n      var gameObject = currentlyOver[i];\n\n      if (!gameObject.input) {\n        continue;\n      }\n\n      gameObject.emit(Events.GAMEOBJECT_POINTER_UP, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer); // Clear over and emit 'pointerout' on touch.\n\n      if (pointer.wasTouch) {\n        this._over[pointer.id] = [];\n        gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\n      }\n\n      if (_eventData.cancelled) {\n        aborted = true;\n        break;\n      }\n\n      this.emit(Events.GAMEOBJECT_UP, pointer, gameObject, _eventContainer);\n\n      if (_eventData.cancelled) {\n        aborted = true;\n        break;\n      }\n    } //  If they released outside the canvas, but pressed down inside it, we'll still dispatch the event.\n\n\n    if (!aborted) {\n      if (pointer.upElement === this.manager.game.canvas) {\n        this.emit(Events.POINTER_UP, pointer, currentlyOver);\n      } else {\n        this.emit(Events.POINTER_UP_OUTSIDE, pointer);\n      }\n    }\n\n    return currentlyOver.length;\n  },\n\n  /**\r\n   * Queues a Game Object for insertion into this Input Plugin on the next update.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#queueForInsertion\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} child - The Game Object to add.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  queueForInsertion: function queueForInsertion(child) {\n    if (this._pendingInsertion.indexOf(child) === -1 && this._list.indexOf(child) === -1) {\n      this._pendingInsertion.push(child);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Queues a Game Object for removal from this Input Plugin on the next update.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#queueForRemoval\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} child - The Game Object to remove.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  queueForRemoval: function queueForRemoval(child) {\n    this._pendingRemoval.push(child);\n\n    return this;\n  },\n\n  /**\r\n   * Sets the draggable state of the given array of Game Objects.\r\n   *\r\n   * They can either be set to be draggable, or can have their draggable state removed by passing `false`.\r\n   *\r\n   * A Game Object will not fire drag events unless it has been specifically enabled for drag.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setDraggable\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to change the draggable state on.\r\n   * @param {boolean} [value=true] - Set to `true` if the Game Objects should be made draggable, `false` if they should be unset.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setDraggable: function setDraggable(gameObjects, value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    if (!Array.isArray(gameObjects)) {\n      gameObjects = [gameObjects];\n    }\n\n    for (var i = 0; i < gameObjects.length; i++) {\n      var gameObject = gameObjects[i];\n      gameObject.input.draggable = value;\n\n      var index = this._draggable.indexOf(gameObject);\n\n      if (value && index === -1) {\n        this._draggable.push(gameObject);\n      } else if (!value && index > -1) {\n        this._draggable.splice(index, 1);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Creates a function that can be passed to `setInteractive`, `enable` or `setHitArea` that will handle\r\n   * pixel-perfect input detection on an Image or Sprite based Game Object, or any custom class that extends them.\r\n   *\r\n   * The following will create a sprite that is clickable on any pixel that has an alpha value >= 1.\r\n   *\r\n   * ```javascript\r\n   * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect());\r\n   * ```\r\n   * \r\n   * The following will create a sprite that is clickable on any pixel that has an alpha value >= 150.\r\n   *\r\n   * ```javascript\r\n   * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect(150));\r\n   * ```\r\n   *\r\n   * Once you have made an Interactive Object pixel perfect it impacts all input related events for it: down, up,\r\n   * dragstart, drag, etc.\r\n   *\r\n   * As a pointer interacts with the Game Object it will constantly poll the texture, extracting a single pixel from\r\n   * the given coordinates and checking its color values. This is an expensive process, so should only be enabled on\r\n   * Game Objects that really need it.\r\n   * \r\n   * You cannot make non-texture based Game Objects pixel perfect. So this will not work on Graphics, BitmapText,\r\n   * Render Textures, Text, Tilemaps, Containers or Particles.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#makePixelPerfect\r\n   * @since 3.10.0\r\n   *\r\n   * @param {integer} [alphaTolerance=1] - The alpha level that the pixel should be above to be included as a successful interaction.\r\n   *\r\n   * @return {function} A Pixel Perfect Handler for use as a hitArea shape callback.\r\n   */\n  makePixelPerfect: function makePixelPerfect(alphaTolerance) {\n    if (alphaTolerance === undefined) {\n      alphaTolerance = 1;\n    }\n\n    var textureManager = this.systems.textures;\n    return CreatePixelPerfectHandler(textureManager, alphaTolerance);\n  },\n\n  /**\r\n   * @typedef {object} Phaser.Input.InputConfiguration\r\n   *\r\n   * @property {any} [hitArea] - The object / shape to use as the Hit Area. If not given it will try to create a Rectangle based on the texture frame.\r\n   * @property {function} [hitAreaCallback] - The callback that determines if the pointer is within the Hit Area shape or not.\r\n   * @property {boolean} [draggable=false] - If `true` the Interactive Object will be set to be draggable and emit drag events.\r\n   * @property {boolean} [dropZone=false] - If `true` the Interactive Object will be set to be a drop zone for draggable objects.\r\n   * @property {boolean} [useHandCursor=false] - If `true` the Interactive Object will set the `pointer` hand cursor when a pointer is over it. This is a short-cut for setting `cursor: 'pointer'`.\r\n   * @property {string} [cursor] - The CSS string to be used when the cursor is over this Interactive Object.\r\n   * @property {boolean} [pixelPerfect=false] - If `true` the a pixel perfect function will be set for the hit area callback. Only works with texture based Game Objects.\r\n   * @property {integer} [alphaTolerance=1] - If `pixelPerfect` is set, this is the alpha tolerance threshold value used in the callback.\r\n   */\n\n  /**\r\n   * Sets the hit area for the given array of Game Objects.\r\n   *\r\n   * A hit area is typically one of the geometric shapes Phaser provides, such as a `Phaser.Geom.Rectangle`\r\n   * or `Phaser.Geom.Circle`. However, it can be any object as long as it works with the provided callback.\r\n   *\r\n   * If no hit area is provided a Rectangle is created based on the size of the Game Object, if possible\r\n   * to calculate.\r\n   *\r\n   * The hit area callback is the function that takes an `x` and `y` coordinate and returns a boolean if\r\n   * those values fall within the area of the shape or not. All of the Phaser geometry objects provide this,\r\n   * such as `Phaser.Geom.Rectangle.Contains`.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setHitArea\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set the hit area on.\r\n   * @param {(Phaser.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n   * @param {HitAreaCallback} [callback] - The 'contains' function to invoke to check if the pointer is within the hit area.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setHitArea: function setHitArea(gameObjects, shape, callback) {\n    if (shape === undefined) {\n      return this.setHitAreaFromTexture(gameObjects);\n    }\n\n    if (!Array.isArray(gameObjects)) {\n      gameObjects = [gameObjects];\n    }\n\n    var draggable = false;\n    var dropZone = false;\n    var cursor = false;\n    var useHandCursor = false; //  Config object?\n\n    if (IsPlainObject(shape)) {\n      var config = shape;\n      shape = GetFastValue(config, 'hitArea', null);\n      callback = GetFastValue(config, 'hitAreaCallback', null);\n      draggable = GetFastValue(config, 'draggable', false);\n      dropZone = GetFastValue(config, 'dropZone', false);\n      cursor = GetFastValue(config, 'cursor', false);\n      useHandCursor = GetFastValue(config, 'useHandCursor', false);\n      var pixelPerfect = GetFastValue(config, 'pixelPerfect', false);\n      var alphaTolerance = GetFastValue(config, 'alphaTolerance', 1);\n\n      if (pixelPerfect) {\n        shape = {};\n        callback = this.makePixelPerfect(alphaTolerance);\n      } //  Still no hitArea or callback?\n\n\n      if (!shape || !callback) {\n        this.setHitAreaFromTexture(gameObjects);\n      }\n    } else if (typeof shape === 'function' && !callback) {\n      callback = shape;\n      shape = {};\n    }\n\n    for (var i = 0; i < gameObjects.length; i++) {\n      var gameObject = gameObjects[i];\n      var io = !gameObject.input ? CreateInteractiveObject(gameObject, shape, callback) : gameObject.input;\n      io.dropZone = dropZone;\n      io.cursor = useHandCursor ? 'pointer' : cursor;\n      gameObject.input = io;\n\n      if (draggable) {\n        this.setDraggable(gameObject);\n      }\n\n      this.queueForInsertion(gameObject);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Circle` shape, using\r\n   * the given coordinates and radius to control its position and size.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setHitAreaCircle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a circle hit area.\r\n   * @param {number} x - The center of the circle.\r\n   * @param {number} y - The center of the circle.\r\n   * @param {number} radius - The radius of the circle.\r\n   * @param {HitAreaCallback} [callback] - The hit area callback. If undefined it uses Circle.Contains.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setHitAreaCircle: function setHitAreaCircle(gameObjects, x, y, radius, callback) {\n    if (callback === undefined) {\n      callback = CircleContains;\n    }\n\n    var shape = new Circle(x, y, radius);\n    return this.setHitArea(gameObjects, shape, callback);\n  },\n\n  /**\r\n   * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Ellipse` shape, using\r\n   * the given coordinates and dimensions to control its position and size.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setHitAreaEllipse\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n   * @param {number} x - The center of the ellipse.\r\n   * @param {number} y - The center of the ellipse.\r\n   * @param {number} width - The width of the ellipse.\r\n   * @param {number} height - The height of the ellipse.\r\n   * @param {HitAreaCallback} [callback] - The hit area callback. If undefined it uses Ellipse.Contains.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setHitAreaEllipse: function setHitAreaEllipse(gameObjects, x, y, width, height, callback) {\n    if (callback === undefined) {\n      callback = EllipseContains;\n    }\n\n    var shape = new Ellipse(x, y, width, height);\n    return this.setHitArea(gameObjects, shape, callback);\n  },\n\n  /**\r\n   * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using\r\n   * the Game Objects texture frame to define the position and size of the hit area.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setHitAreaFromTexture\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n   * @param {HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setHitAreaFromTexture: function setHitAreaFromTexture(gameObjects, callback) {\n    if (callback === undefined) {\n      callback = RectangleContains;\n    }\n\n    if (!Array.isArray(gameObjects)) {\n      gameObjects = [gameObjects];\n    }\n\n    for (var i = 0; i < gameObjects.length; i++) {\n      var gameObject = gameObjects[i];\n      var frame = gameObject.frame;\n      var width = 0;\n      var height = 0;\n\n      if (gameObject.width) {\n        width = gameObject.width;\n        height = gameObject.height;\n      } else if (frame) {\n        width = frame.realWidth;\n        height = frame.realHeight;\n      }\n\n      if (gameObject.type === 'Container' && (width === 0 || height === 0)) {\n        console.warn('Container.setInteractive must specify a Shape or call setSize() first');\n        continue;\n      }\n\n      if (width !== 0 && height !== 0) {\n        gameObject.input = CreateInteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback);\n        this.queueForInsertion(gameObject);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using\r\n   * the given coordinates and dimensions to control its position and size.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setHitAreaRectangle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a rectangular hit area.\r\n   * @param {number} x - The top-left of the rectangle.\r\n   * @param {number} y - The top-left of the rectangle.\r\n   * @param {number} width - The width of the rectangle.\r\n   * @param {number} height - The height of the rectangle.\r\n   * @param {HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setHitAreaRectangle: function setHitAreaRectangle(gameObjects, x, y, width, height, callback) {\n    if (callback === undefined) {\n      callback = RectangleContains;\n    }\n\n    var shape = new Rectangle(x, y, width, height);\n    return this.setHitArea(gameObjects, shape, callback);\n  },\n\n  /**\r\n   * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Triangle` shape, using\r\n   * the given coordinates to control the position of its points.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setHitAreaTriangle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a  triangular hit area.\r\n   * @param {number} x1 - The x coordinate of the first point of the triangle.\r\n   * @param {number} y1 - The y coordinate of the first point of the triangle.\r\n   * @param {number} x2 - The x coordinate of the second point of the triangle.\r\n   * @param {number} y2 - The y coordinate of the second point of the triangle.\r\n   * @param {number} x3 - The x coordinate of the third point of the triangle.\r\n   * @param {number} y3 - The y coordinate of the third point of the triangle.\r\n   * @param {HitAreaCallback} [callback] - The hit area callback. If undefined it uses Triangle.Contains.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setHitAreaTriangle: function setHitAreaTriangle(gameObjects, x1, y1, x2, y2, x3, y3, callback) {\n    if (callback === undefined) {\n      callback = TriangleContains;\n    }\n\n    var shape = new Triangle(x1, y1, x2, y2, x3, y3);\n    return this.setHitArea(gameObjects, shape, callback);\n  },\n\n  /**\r\n   * Sets the Pointers to always poll.\r\n   * \r\n   * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,\r\n   * or being interacted with it, regardless if the Pointer has actually moved or not.\r\n   *\r\n   * You should enable this if you want objects in your game to fire over / out events, and the objects\r\n   * are constantly moving, but the pointer may not have. Polling every frame has additional computation\r\n   * costs, especially if there are a large number of interactive objects in your game.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setPollAlways\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setPollAlways: function setPollAlways() {\n    this.pollRate = 0;\n    this._pollTimer = 0;\n    return this;\n  },\n\n  /**\r\n   * Sets the Pointers to only poll when they are moved or updated.\r\n   * \r\n   * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,\r\n   * or being interacted with it.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setPollOnMove\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setPollOnMove: function setPollOnMove() {\n    this.pollRate = -1;\n    this._pollTimer = 0;\n    return this;\n  },\n\n  /**\r\n   * Sets the poll rate value. This is the amount of time that should have elapsed before a pointer\r\n   * will be polled again. See the `setPollAlways` and `setPollOnMove` methods.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setPollRate\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The amount of time, in ms, that should elapsed before re-polling the pointers.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setPollRate: function setPollRate(value) {\n    this.pollRate = value;\n    this._pollTimer = 0;\n    return this;\n  },\n\n  /**\r\n   * When set to `true` the global Input Manager will emulate DOM behavior by only emitting events from\r\n   * the top-most Game Objects in the Display List.\r\n   *\r\n   * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setGlobalTopOnly\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - `true` to only include the top-most Game Object, or `false` to include all Game Objects in a hit test.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setGlobalTopOnly: function setGlobalTopOnly(value) {\n    this.manager.globalTopOnly = value;\n    return this;\n  },\n\n  /**\r\n   * When set to `true` this Input Plugin will emulate DOM behavior by only emitting events from\r\n   * the top-most Game Objects in the Display List.\r\n   *\r\n   * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setTopOnly\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - `true` to only include the top-most Game Object, or `false` to include all Game Objects in a hit test.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setTopOnly: function setTopOnly(value) {\n    this.topOnly = value;\n    return this;\n  },\n\n  /**\r\n   * Given an array of Game Objects, sort the array and return it, so that the objects are in depth index order\r\n   * with the lowest at the bottom.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#sortGameObjects\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject[]} gameObjects - An array of Game Objects to be sorted.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject[]} The sorted array of Game Objects.\r\n   */\n  sortGameObjects: function sortGameObjects(gameObjects) {\n    if (gameObjects.length < 2) {\n      return gameObjects;\n    }\n\n    this.scene.sys.depthSort();\n    return gameObjects.sort(this.sortHandlerGO.bind(this));\n  },\n\n  /**\r\n   * Return the child lowest down the display list (with the smallest index)\r\n   * Will iterate through all parent containers, if present.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#sortHandlerGO\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} childA - The first Game Object to compare.\r\n   * @param {Phaser.GameObjects.GameObject} childB - The second Game Object to compare.\r\n   *\r\n   * @return {integer} Returns either a negative or positive integer, or zero if they match.\r\n   */\n  sortHandlerGO: function sortHandlerGO(childA, childB) {\n    if (!childA.parentContainer && !childB.parentContainer) {\n      //  Quick bail out when neither child has a container\n      return this.displayList.getIndex(childB) - this.displayList.getIndex(childA);\n    } else if (childA.parentContainer === childB.parentContainer) {\n      //  Quick bail out when both children have the same container\n      return childB.parentContainer.getIndex(childB) - childA.parentContainer.getIndex(childA);\n    } else if (childA.parentContainer === childB) {\n      //  Quick bail out when childA is a child of childB\n      return -1;\n    } else if (childB.parentContainer === childA) {\n      //  Quick bail out when childA is a child of childB\n      return 1;\n    } else {\n      //  Container index check\n      var listA = childA.getIndexList();\n      var listB = childB.getIndexList();\n      var len = Math.min(listA.length, listB.length);\n\n      for (var i = 0; i < len; i++) {\n        var indexA = listA[i];\n        var indexB = listB[i];\n\n        if (indexA === indexB) {\n          //  Go to the next level down\n          continue;\n        } else {\n          //  Non-matching parents, so return\n          return indexB - indexA;\n        }\n      }\n    } //  Technically this shouldn't happen, but ...\n\n\n    return 0;\n  },\n\n  /**\r\n   * Causes the Input Manager to stop emitting any events for the remainder of this game step.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#stopPropagation\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  stopPropagation: function stopPropagation() {\n    if (this.manager.globalTopOnly) {\n      this.manager.ignoreEvents = true;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * **Note:** As of Phaser 3.16 this method is no longer required _unless_ you have set `input.queue = true`\r\n   * in your game config, to force it to use the legacy event queue system. This method is deprecated and\r\n   * will be removed in a future version.\r\n   * \r\n   * Adds a callback to be invoked whenever the native DOM `mouseup` or `touchend` events are received.\r\n   * By setting the `isOnce` argument you can control if the callback is called once,\r\n   * or every time the DOM event occurs.\r\n   *\r\n   * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,\r\n   * within the scope of the DOM event handler. Therefore, they are considered as 'native'\r\n   * from the perspective of the browser. This means they can be used for tasks such as\r\n   * opening new browser windows, or anything which explicitly requires user input to activate.\r\n   * However, as a result of this, they come with their own risks, and as such should not be used\r\n   * for general game input, but instead be reserved for special circumstances.\r\n   *\r\n   * If all you're trying to do is execute a callback when a pointer is released, then\r\n   * please use the internal Input event system instead.\r\n   *\r\n   * Please understand that these callbacks are invoked when the browser feels like doing so,\r\n   * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep\r\n   * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,\r\n   * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating\r\n   * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind\r\n   * solve.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#addUpCallback\r\n   * @deprecated\r\n   * @since 3.10.0\r\n   *\r\n   * @param {function} callback - The callback to be invoked on this DOM event.\r\n   * @param {boolean} [isOnce=true] - `true` if the callback will only be invoked once, `false` to call every time this event happens.\r\n   *\r\n   * @return {this} The Input Plugin.\r\n   */\n  addUpCallback: function addUpCallback(callback, isOnce) {\n    this.manager.addUpCallback(callback, isOnce);\n    return this;\n  },\n\n  /**\r\n   * **Note:** As of Phaser 3.16 this method is no longer required _unless_ you have set `input.queue = true`\r\n   * in your game config, to force it to use the legacy event queue system. This method is deprecated and\r\n   * will be removed in a future version.\r\n   * \r\n   * Adds a callback to be invoked whenever the native DOM `mousedown` or `touchstart` events are received.\r\n   * By setting the `isOnce` argument you can control if the callback is called once,\r\n   * or every time the DOM event occurs.\r\n   *\r\n   * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,\r\n   * within the scope of the DOM event handler. Therefore, they are considered as 'native'\r\n   * from the perspective of the browser. This means they can be used for tasks such as\r\n   * opening new browser windows, or anything which explicitly requires user input to activate.\r\n   * However, as a result of this, they come with their own risks, and as such should not be used\r\n   * for general game input, but instead be reserved for special circumstances.\r\n   *\r\n   * If all you're trying to do is execute a callback when a pointer is down, then\r\n   * please use the internal Input event system instead.\r\n   *\r\n   * Please understand that these callbacks are invoked when the browser feels like doing so,\r\n   * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep\r\n   * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,\r\n   * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating\r\n   * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind\r\n   * solve.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#addDownCallback\r\n   * @deprecated\r\n   * @since 3.10.0\r\n   *\r\n   * @param {function} callback - The callback to be invoked on this dom event.\r\n   * @param {boolean} [isOnce=true] - `true` if the callback will only be invoked once, `false` to call every time this event happens.\r\n   *\r\n   * @return {this} The Input Plugin.\r\n   */\n  addDownCallback: function addDownCallback(callback, isOnce) {\n    this.manager.addDownCallback(callback, isOnce);\n    return this;\n  },\n\n  /**\r\n   * **Note:** As of Phaser 3.16 this method is no longer required _unless_ you have set `input.queue = true`\r\n   * in your game config, to force it to use the legacy event queue system. This method is deprecated and\r\n   * will be removed in a future version.\r\n   * \r\n   * Adds a callback to be invoked whenever the native DOM `mousemove` or `touchmove` events are received.\r\n   * By setting the `isOnce` argument you can control if the callback is called once,\r\n   * or every time the DOM event occurs.\r\n   *\r\n   * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,\r\n   * within the scope of the DOM event handler. Therefore, they are considered as 'native'\r\n   * from the perspective of the browser. This means they can be used for tasks such as\r\n   * opening new browser windows, or anything which explicitly requires user input to activate.\r\n   * However, as a result of this, they come with their own risks, and as such should not be used\r\n   * for general game input, but instead be reserved for special circumstances.\r\n   *\r\n   * If all you're trying to do is execute a callback when a pointer is moved, then\r\n   * please use the internal Input event system instead.\r\n   *\r\n   * Please understand that these callbacks are invoked when the browser feels like doing so,\r\n   * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep\r\n   * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,\r\n   * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating\r\n   * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind\r\n   * solve.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#addMoveCallback\r\n   * @deprecated\r\n   * @since 3.10.0\r\n   *\r\n   * @param {function} callback - The callback to be invoked on this dom event.\r\n   * @param {boolean} [isOnce=false] - `true` if the callback will only be invoked once, `false` to call every time this event happens.\r\n   *\r\n   * @return {this} The Input Plugin.\r\n   */\n  addMoveCallback: function addMoveCallback(callback, isOnce) {\n    this.manager.addMoveCallback(callback, isOnce);\n    return this;\n  },\n\n  /**\r\n   * Adds new Pointer objects to the Input Manager.\r\n   *\r\n   * By default Phaser creates 2 pointer objects: `mousePointer` and `pointer1`.\r\n   *\r\n   * You can create more either by calling this method, or by setting the `input.activePointers` property\r\n   * in the Game Config, up to a maximum of 10 pointers.\r\n   *\r\n   * The first 10 pointers are available via the `InputPlugin.pointerX` properties, once they have been added\r\n   * via this method.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#addPointer\r\n   * @since 3.10.0\r\n   * \r\n   * @param {integer} [quantity=1] The number of new Pointers to create. A maximum of 10 is allowed in total.\r\n   *\r\n   * @return {Phaser.Input.Pointer[]} An array containing all of the new Pointer objects that were created.\r\n   */\n  addPointer: function addPointer(quantity) {\n    return this.manager.addPointer(quantity);\n  },\n\n  /**\r\n   * Tells the Input system to set a custom cursor.\r\n   * \r\n   * This cursor will be the default cursor used when interacting with the game canvas.\r\n   *\r\n   * If an Interactive Object also sets a custom cursor, this is the cursor that is reset after its use.\r\n   *\r\n   * Any valid CSS cursor value is allowed, including paths to image files, i.e.:\r\n   *\r\n   * ```javascript\r\n   * this.input.setDefaultCursor('url(assets/cursors/sword.cur), pointer');\r\n   * ```\r\n   * \r\n   * Please read about the differences between browsers when it comes to the file formats and sizes they support:\r\n   *\r\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\r\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_User_Interface/Using_URL_values_for_the_cursor_property\r\n   *\r\n   * It's up to you to pick a suitable cursor format that works across the range of browsers you need to support.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setDefaultCursor\r\n   * @since 3.10.0\r\n   * \r\n   * @param {string} cursor - The CSS to be used when setting the default cursor.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This Input instance.\r\n   */\n  setDefaultCursor: function setDefaultCursor(cursor) {\n    this.manager.setDefaultCursor(cursor);\n    return this;\n  },\n\n  /**\r\n   * The Scene that owns this plugin is transitioning in.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#transitionIn\r\n   * @private\r\n   * @since 3.5.0\r\n   */\n  transitionIn: function transitionIn() {\n    this.enabled = this.settings.transitionAllowInput;\n  },\n\n  /**\r\n   * The Scene that owns this plugin has finished transitioning in.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#transitionComplete\r\n   * @private\r\n   * @since 3.5.0\r\n   */\n  transitionComplete: function transitionComplete() {\n    if (!this.settings.transitionAllowInput) {\n      this.enabled = true;\n    }\n  },\n\n  /**\r\n   * The Scene that owns this plugin is transitioning out.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#transitionOut\r\n   * @private\r\n   * @since 3.5.0\r\n   */\n  transitionOut: function transitionOut() {\n    this.enabled = this.settings.transitionAllowInput;\n  },\n\n  /**\r\n   * The Scene that owns this plugin is shutting down.\r\n   * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#shutdown\r\n   * @fires Phaser.Input.Events#SHUTDOWN\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  shutdown: function shutdown() {\n    //  Registered input plugins listen for this\n    this.pluginEvents.emit(Events.SHUTDOWN);\n    this._temp.length = 0;\n    this._list.length = 0;\n    this._draggable.length = 0;\n    this._pendingRemoval.length = 0;\n    this._pendingInsertion.length = 0;\n    this._dragState.length = 0;\n\n    for (var i = 0; i < 10; i++) {\n      this._drag[i] = [];\n      this._over[i] = [];\n    }\n\n    this.removeAllListeners();\n    var eventEmitter = this.systems.events;\n    eventEmitter.off(SceneEvents.TRANSITION_START, this.transitionIn, this);\n    eventEmitter.off(SceneEvents.TRANSITION_OUT, this.transitionOut, this);\n    eventEmitter.off(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);\n    eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);\n\n    if (this.manager.useQueue) {\n      eventEmitter.off(SceneEvents.UPDATE, this.update, this);\n    }\n\n    this.manager.events.off(Events.GAME_OUT, this.onGameOut, this);\n    this.manager.events.off(Events.GAME_OVER, this.onGameOver, this);\n    eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\n  },\n\n  /**\r\n   * The Scene that owns this plugin is being destroyed.     \r\n   * We need to shutdown and then kill off all external references.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#destroy\r\n   * @fires Phaser.Input.Events#DESTROY\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    this.shutdown(); //  Registered input plugins listen for this\n\n    this.pluginEvents.emit(Events.DESTROY);\n    this.pluginEvents.removeAllListeners();\n    this.scene.sys.events.off(SceneEvents.START, this.start, this);\n    this.scene = null;\n    this.cameras = null;\n    this.manager = null;\n    this.events = null;\n    this.mouse = null;\n  },\n\n  /**\r\n   * The x coordinates of the ActivePointer based on the first camera in the camera list.\r\n   * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#x\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  x: {\n    get: function get() {\n      return this.manager.activePointer.x;\n    }\n  },\n\n  /**\r\n   * The y coordinates of the ActivePointer based on the first camera in the camera list.\r\n   * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#y\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  y: {\n    get: function get() {\n      return this.manager.activePointer.y;\n    }\n  },\n\n  /**\r\n   * Are any mouse or touch pointers currently over the game canvas?\r\n   *\r\n   * @name Phaser.Input.InputPlugin#isOver\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  isOver: {\n    get: function get() {\n      return this.manager.isOver;\n    }\n  },\n\n  /**\r\n   * The mouse has its own unique Pointer object, which you can reference directly if making a _desktop specific game_.\r\n   * If you are supporting both desktop and touch devices then do not use this property, instead use `activePointer`\r\n   * which will always map to the most recently interacted pointer.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#mousePointer\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  mousePointer: {\n    get: function get() {\n      return this.manager.mousePointer;\n    }\n  },\n\n  /**\r\n   * The current active input Pointer.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#activePointer\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  activePointer: {\n    get: function get() {\n      return this.manager.activePointer;\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer1\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer1: {\n    get: function get() {\n      return this.manager.pointers[1];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer2\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer2: {\n    get: function get() {\n      return this.manager.pointers[2];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer3\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer3: {\n    get: function get() {\n      return this.manager.pointers[3];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer4\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer4: {\n    get: function get() {\n      return this.manager.pointers[4];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer5\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer5: {\n    get: function get() {\n      return this.manager.pointers[5];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer6\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer6: {\n    get: function get() {\n      return this.manager.pointers[6];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer7\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer7: {\n    get: function get() {\n      return this.manager.pointers[7];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer8\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer8: {\n    get: function get() {\n      return this.manager.pointers[8];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer9\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer9: {\n    get: function get() {\n      return this.manager.pointers[9];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer10\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer10: {\n    get: function get() {\n      return this.manager.pointers[10];\n    }\n  }\n});\nPluginCache.register('InputPlugin', InputPlugin, 'input');\nmodule.exports = InputPlugin;","map":null,"metadata":{},"sourceType":"script"}