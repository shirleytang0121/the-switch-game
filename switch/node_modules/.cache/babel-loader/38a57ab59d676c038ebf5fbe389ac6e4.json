{"ast":null,"code":"/**\r\n * @author       Stefan Hedman <schteppe@gmail.com> (http://steffe.se)\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\n//  v0.3.0\nmodule.exports = {\n  decomp: polygonDecomp,\n  quickDecomp: polygonQuickDecomp,\n  isSimple: polygonIsSimple,\n  removeCollinearPoints: polygonRemoveCollinearPoints,\n  removeDuplicatePoints: polygonRemoveDuplicatePoints,\n  makeCCW: polygonMakeCCW\n};\n/**\r\n * Compute the intersection between two lines.\r\n * @static\r\n * @method lineInt\r\n * @param  {Array}  l1          Line vector 1\r\n * @param  {Array}  l2          Line vector 2\r\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\r\n * @return {Array}              The intersection point.\r\n */\n\nfunction lineInt(l1, l2, precision) {\n  precision = precision || 0;\n  var i = [0, 0]; // point\n\n  var a1, b1, c1, a2, b2, c2, det; // scalars\n\n  a1 = l1[1][1] - l1[0][1];\n  b1 = l1[0][0] - l1[1][0];\n  c1 = a1 * l1[0][0] + b1 * l1[0][1];\n  a2 = l2[1][1] - l2[0][1];\n  b2 = l2[0][0] - l2[1][0];\n  c2 = a2 * l2[0][0] + b2 * l2[0][1];\n  det = a1 * b2 - a2 * b1;\n\n  if (!scalar_eq(det, 0, precision)) {\n    // lines are not parallel\n    i[0] = (b2 * c1 - b1 * c2) / det;\n    i[1] = (a1 * c2 - a2 * c1) / det;\n  }\n\n  return i;\n}\n/**\r\n * Checks if two line segments intersects.\r\n * @method segmentsIntersect\r\n * @param {Array} p1 The start vertex of the first line segment.\r\n * @param {Array} p2 The end vertex of the first line segment.\r\n * @param {Array} q1 The start vertex of the second line segment.\r\n * @param {Array} q2 The end vertex of the second line segment.\r\n * @return {Boolean} True if the two line segments intersect\r\n */\n\n\nfunction lineSegmentsIntersect(p1, p2, q1, q2) {\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var da = q2[0] - q1[0];\n  var db = q2[1] - q1[1]; // segments are parallel\n\n  if (da * dy - db * dx === 0) {\n    return false;\n  }\n\n  var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n  var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n  return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n}\n/**\r\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\r\n * @static\r\n * @method area\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Array} c\r\n * @return {Number}\r\n */\n\n\nfunction triangleArea(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);\n}\n\nfunction isLeft(a, b, c) {\n  return triangleArea(a, b, c) > 0;\n}\n\nfunction isLeftOn(a, b, c) {\n  return triangleArea(a, b, c) >= 0;\n}\n\nfunction isRight(a, b, c) {\n  return triangleArea(a, b, c) < 0;\n}\n\nfunction isRightOn(a, b, c) {\n  return triangleArea(a, b, c) <= 0;\n}\n\nvar tmpPoint1 = [],\n    tmpPoint2 = [];\n/**\r\n * Check if three points are collinear\r\n * @method collinear\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Array} c\r\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\r\n * @return {Boolean}\r\n */\n\nfunction collinear(a, b, c, thresholdAngle) {\n  if (!thresholdAngle) {\n    return triangleArea(a, b, c) === 0;\n  } else {\n    var ab = tmpPoint1,\n        bc = tmpPoint2;\n    ab[0] = b[0] - a[0];\n    ab[1] = b[1] - a[1];\n    bc[0] = c[0] - b[0];\n    bc[1] = c[1] - b[1];\n    var dot = ab[0] * bc[0] + ab[1] * bc[1],\n        magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]),\n        magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]),\n        angle = Math.acos(dot / (magA * magB));\n    return angle < thresholdAngle;\n  }\n}\n\nfunction sqdist(a, b) {\n  var dx = b[0] - a[0];\n  var dy = b[1] - a[1];\n  return dx * dx + dy * dy;\n}\n/**\r\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\r\n * @method at\r\n * @param  {Number} i\r\n * @return {Array}\r\n */\n\n\nfunction polygonAt(polygon, i) {\n  var s = polygon.length;\n  return polygon[i < 0 ? i % s + s : i % s];\n}\n/**\r\n * Clear the polygon data\r\n * @method clear\r\n * @return {Array}\r\n */\n\n\nfunction polygonClear(polygon) {\n  polygon.length = 0;\n}\n/**\r\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\r\n * @method append\r\n * @param {Polygon} poly The polygon to get points from.\r\n * @param {Number}  from The vertex index in \"poly\".\r\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\r\n * @return {Array}\r\n */\n\n\nfunction polygonAppend(polygon, poly, from, to) {\n  for (var i = from; i < to; i++) {\n    polygon.push(poly[i]);\n  }\n}\n/**\r\n * Make sure that the polygon vertices are ordered counter-clockwise.\r\n * @method makeCCW\r\n */\n\n\nfunction polygonMakeCCW(polygon) {\n  var br = 0,\n      v = polygon; // find bottom right point\n\n  for (var i = 1; i < polygon.length; ++i) {\n    if (v[i][1] < v[br][1] || v[i][1] === v[br][1] && v[i][0] > v[br][0]) {\n      br = i;\n    }\n  } // reverse poly if clockwise\n\n\n  if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n    polygonReverse(polygon);\n    return true;\n  } else {\n    return false;\n  }\n}\n/**\r\n * Reverse the vertices in the polygon\r\n * @method reverse\r\n */\n\n\nfunction polygonReverse(polygon) {\n  var tmp = [];\n  var N = polygon.length;\n\n  for (var i = 0; i !== N; i++) {\n    tmp.push(polygon.pop());\n  }\n\n  for (var i = 0; i !== N; i++) {\n    polygon[i] = tmp[i];\n  }\n}\n/**\r\n * Check if a point in the polygon is a reflex point\r\n * @method isReflex\r\n * @param  {Number}  i\r\n * @return {Boolean}\r\n */\n\n\nfunction polygonIsReflex(polygon, i) {\n  return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\n\nvar tmpLine1 = [],\n    tmpLine2 = [];\n/**\r\n * Check if two vertices in the polygon can see each other\r\n * @method canSee\r\n * @param  {Number} a Vertex index 1\r\n * @param  {Number} b Vertex index 2\r\n * @return {Boolean}\r\n */\n\nfunction polygonCanSee(polygon, a, b) {\n  var p,\n      dist,\n      l1 = tmpLine1,\n      l2 = tmpLine2;\n\n  if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n    return false;\n  }\n\n  dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n\n  for (var i = 0; i !== polygon.length; ++i) {\n    // for each edge\n    if ((i + 1) % polygon.length === a || i === a) {\n      // ignore incident edges\n      continue;\n    }\n\n    if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) {\n      // if diag intersects an edge\n      l1[0] = polygonAt(polygon, a);\n      l1[1] = polygonAt(polygon, b);\n      l2[0] = polygonAt(polygon, i);\n      l2[1] = polygonAt(polygon, i + 1);\n      p = lineInt(l1, l2);\n\n      if (sqdist(polygonAt(polygon, a), p) < dist) {\n        // if edge is blocking visibility to b\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\r\n * Check if two vertices in the polygon can see each other\r\n * @method canSee2\r\n * @param  {Number} a Vertex index 1\r\n * @param  {Number} b Vertex index 2\r\n * @return {Boolean}\r\n */\n\n\nfunction polygonCanSee2(polygon, a, b) {\n  // for each edge\n  for (var i = 0; i !== polygon.length; ++i) {\n    // ignore incident edges\n    if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) {\n      continue;\n    }\n\n    if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\r\n * Copy the polygon from vertex i to vertex j.\r\n * @method copy\r\n * @param  {Number} i\r\n * @param  {Number} j\r\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\r\n * @return {Polygon}                The resulting copy.\r\n */\n\n\nfunction polygonCopy(polygon, i, j, targetPoly) {\n  var p = targetPoly || [];\n  polygonClear(p);\n\n  if (i < j) {\n    // Insert all vertices from i to j\n    for (var k = i; k <= j; k++) {\n      p.push(polygon[k]);\n    }\n  } else {\n    // Insert vertices 0 to j\n    for (var k = 0; k <= j; k++) {\n      p.push(polygon[k]);\n    } // Insert vertices i to end\n\n\n    for (var k = i; k < polygon.length; k++) {\n      p.push(polygon[k]);\n    }\n  }\n\n  return p;\n}\n/**\r\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\r\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\r\n * @method getCutEdges\r\n * @return {Array}\r\n */\n\n\nfunction polygonGetCutEdges(polygon) {\n  var min = [],\n      tmp1 = [],\n      tmp2 = [],\n      tmpPoly = [];\n  var nDiags = Number.MAX_VALUE;\n\n  for (var i = 0; i < polygon.length; ++i) {\n    if (polygonIsReflex(polygon, i)) {\n      for (var j = 0; j < polygon.length; ++j) {\n        if (polygonCanSee(polygon, i, j)) {\n          tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n          tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n\n          for (var k = 0; k < tmp2.length; k++) {\n            tmp1.push(tmp2[k]);\n          }\n\n          if (tmp1.length < nDiags) {\n            min = tmp1;\n            nDiags = tmp1.length;\n            min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\n          }\n        }\n      }\n    }\n  }\n\n  return min;\n}\n/**\r\n * Decomposes the polygon into one or more convex sub-Polygons.\r\n * @method decomp\r\n * @return {Array} An array or Polygon objects.\r\n */\n\n\nfunction polygonDecomp(polygon) {\n  var edges = polygonGetCutEdges(polygon);\n\n  if (edges.length > 0) {\n    return polygonSlice(polygon, edges);\n  } else {\n    return [polygon];\n  }\n}\n/**\r\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\r\n * @method slice\r\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\r\n * @return {Array}\r\n */\n\n\nfunction polygonSlice(polygon, cutEdges) {\n  if (cutEdges.length === 0) {\n    return [polygon];\n  }\n\n  if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {\n    var polys = [polygon];\n\n    for (var i = 0; i < cutEdges.length; i++) {\n      var cutEdge = cutEdges[i]; // Cut all polys\n\n      for (var j = 0; j < polys.length; j++) {\n        var poly = polys[j];\n        var result = polygonSlice(poly, cutEdge);\n\n        if (result) {\n          // Found poly! Cut and quit\n          polys.splice(j, 1);\n          polys.push(result[0], result[1]);\n          break;\n        }\n      }\n    }\n\n    return polys;\n  } else {\n    // Was given one edge\n    var cutEdge = cutEdges;\n    var i = polygon.indexOf(cutEdge[0]);\n    var j = polygon.indexOf(cutEdge[1]);\n\n    if (i !== -1 && j !== -1) {\n      return [polygonCopy(polygon, i, j), polygonCopy(polygon, j, i)];\n    } else {\n      return false;\n    }\n  }\n}\n/**\r\n * Checks that the line segments of this polygon do not intersect each other.\r\n * @method isSimple\r\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\r\n * @return {Boolean}\r\n * @todo Should it check all segments with all others?\r\n */\n\n\nfunction polygonIsSimple(polygon) {\n  var path = polygon,\n      i; // Check\n\n  for (i = 0; i < path.length - 1; i++) {\n    for (var j = 0; j < i - 1; j++) {\n      if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {\n        return false;\n      }\n    }\n  } // Check the segment between the last and the first point to all others\n\n\n  for (i = 1; i < path.length - 2; i++) {\n    if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getIntersectionPoint(p1, p2, q1, q2, delta) {\n  delta = delta || 0;\n  var a1 = p2[1] - p1[1];\n  var b1 = p1[0] - p2[0];\n  var c1 = a1 * p1[0] + b1 * p1[1];\n  var a2 = q2[1] - q1[1];\n  var b2 = q1[0] - q2[0];\n  var c2 = a2 * q1[0] + b2 * q1[1];\n  var det = a1 * b2 - a2 * b1;\n\n  if (!scalar_eq(det, 0, delta)) {\n    return [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];\n  } else {\n    return [0, 0];\n  }\n}\n/**\r\n * Quickly decompose the Polygon into convex sub-polygons.\r\n * @method quickDecomp\r\n * @param  {Array} result\r\n * @param  {Array} [reflexVertices]\r\n * @param  {Array} [steinerPoints]\r\n * @param  {Number} [delta]\r\n * @param  {Number} [maxlevel]\r\n * @param  {Number} [level]\r\n * @return {Array}\r\n */\n\n\nfunction polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {\n  maxlevel = maxlevel || 100;\n  level = level || 0;\n  delta = delta || 25;\n  result = typeof result !== \"undefined\" ? result : [];\n  reflexVertices = reflexVertices || [];\n  steinerPoints = steinerPoints || [];\n  var upperInt = [0, 0],\n      lowerInt = [0, 0],\n      p = [0, 0]; // Points\n\n  var upperDist = 0,\n      lowerDist = 0,\n      d = 0,\n      closestDist = 0; // scalars\n\n  var upperIndex = 0,\n      lowerIndex = 0,\n      closestIndex = 0; // Integers\n\n  var lowerPoly = [],\n      upperPoly = []; // polygons\n\n  var poly = polygon,\n      v = polygon;\n\n  if (v.length < 3) {\n    return result;\n  }\n\n  level++;\n\n  if (level > maxlevel) {\n    console.warn(\"quickDecomp: max level (\" + maxlevel + \") reached.\");\n    return result;\n  }\n\n  for (var i = 0; i < polygon.length; ++i) {\n    if (polygonIsReflex(poly, i)) {\n      reflexVertices.push(poly[i]);\n      upperDist = lowerDist = Number.MAX_VALUE;\n\n      for (var j = 0; j < polygon.length; ++j) {\n        if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) {\n          // if line intersects with an edge\n          p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n\n          if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) {\n            // make sure it's inside the poly\n            d = sqdist(poly[i], p);\n\n            if (d < lowerDist) {\n              // keep only the closest intersection\n              lowerDist = d;\n              lowerInt = p;\n              lowerIndex = j;\n            }\n          }\n        }\n\n        if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n          p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n\n          if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n            d = sqdist(poly[i], p);\n\n            if (d < upperDist) {\n              upperDist = d;\n              upperInt = p;\n              upperIndex = j;\n            }\n          }\n        }\n      } // if there are no vertices to connect to, choose a point in the middle\n\n\n      if (lowerIndex === (upperIndex + 1) % polygon.length) {\n        //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\n        p[0] = (lowerInt[0] + upperInt[0]) / 2;\n        p[1] = (lowerInt[1] + upperInt[1]) / 2;\n        steinerPoints.push(p);\n\n        if (i < upperIndex) {\n          //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n          polygonAppend(lowerPoly, poly, i, upperIndex + 1);\n          lowerPoly.push(p);\n          upperPoly.push(p);\n\n          if (lowerIndex !== 0) {\n            //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n            polygonAppend(upperPoly, poly, lowerIndex, poly.length);\n          } //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n\n\n          polygonAppend(upperPoly, poly, 0, i + 1);\n        } else {\n          if (i !== 0) {\n            //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n            polygonAppend(lowerPoly, poly, i, poly.length);\n          } //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n\n\n          polygonAppend(lowerPoly, poly, 0, upperIndex + 1);\n          lowerPoly.push(p);\n          upperPoly.push(p); //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n\n          polygonAppend(upperPoly, poly, lowerIndex, i + 1);\n        }\n      } else {\n        // connect to the closest point within the triangle\n        //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\n        if (lowerIndex > upperIndex) {\n          upperIndex += polygon.length;\n        }\n\n        closestDist = Number.MAX_VALUE;\n\n        if (upperIndex < lowerIndex) {\n          return result;\n        }\n\n        for (var j = lowerIndex; j <= upperIndex; ++j) {\n          if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n            d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n\n            if (d < closestDist && polygonCanSee2(poly, i, j)) {\n              closestDist = d;\n              closestIndex = j % polygon.length;\n            }\n          }\n        }\n\n        if (i < closestIndex) {\n          polygonAppend(lowerPoly, poly, i, closestIndex + 1);\n\n          if (closestIndex !== 0) {\n            polygonAppend(upperPoly, poly, closestIndex, v.length);\n          }\n\n          polygonAppend(upperPoly, poly, 0, i + 1);\n        } else {\n          if (i !== 0) {\n            polygonAppend(lowerPoly, poly, i, v.length);\n          }\n\n          polygonAppend(lowerPoly, poly, 0, closestIndex + 1);\n          polygonAppend(upperPoly, poly, closestIndex, i + 1);\n        }\n      } // solve smallest poly first\n\n\n      if (lowerPoly.length < upperPoly.length) {\n        polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n        polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n      } else {\n        polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n        polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n      }\n\n      return result;\n    }\n  }\n\n  result.push(polygon);\n  return result;\n}\n/**\r\n * Remove collinear points in the polygon.\r\n * @method removeCollinearPoints\r\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\r\n * @return {Number}           The number of points removed\r\n */\n\n\nfunction polygonRemoveCollinearPoints(polygon, precision) {\n  var num = 0;\n\n  for (var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i) {\n    if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {\n      // Remove the middle point\n      polygon.splice(i % polygon.length, 1);\n      num++;\n    }\n  }\n\n  return num;\n}\n/**\r\n * Remove duplicate points in the polygon.\r\n * @method removeDuplicatePoints\r\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\r\n */\n\n\nfunction polygonRemoveDuplicatePoints(polygon, precision) {\n  for (var i = polygon.length - 1; i >= 1; --i) {\n    var pi = polygon[i];\n\n    for (var j = i - 1; j >= 0; --j) {\n      if (points_eq(pi, polygon[j], precision)) {\n        polygon.splice(i, 1);\n        continue;\n      }\n    }\n  }\n}\n/**\r\n * Check if two scalars are equal\r\n * @static\r\n * @method eq\r\n * @param  {Number} a\r\n * @param  {Number} b\r\n * @param  {Number} [precision]\r\n * @return {Boolean}\r\n */\n\n\nfunction scalar_eq(a, b, precision) {\n  precision = precision || 0;\n  return Math.abs(a - b) <= precision;\n}\n/**\r\n * Check if two points are equal\r\n * @static\r\n * @method points_eq\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Number} [precision]\r\n * @return {Boolean}\r\n */\n\n\nfunction points_eq(a, b, precision) {\n  return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision);\n}","map":null,"metadata":{},"sourceType":"script"}