{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\nvar Class = require('../utils/Class');\n\nvar Vector3 = require('./Vector3');\n\nvar Matrix3 = require('./Matrix3');\n\nvar EPSILON = 0.000001; //  Some shared 'private' arrays\n\nvar siNext = new Int8Array([1, 2, 0]);\nvar tmp = new Float32Array([0, 0, 0]);\nvar xUnitVec3 = new Vector3(1, 0, 0);\nvar yUnitVec3 = new Vector3(0, 1, 0);\nvar tmpvec = new Vector3();\nvar tmpMat3 = new Matrix3();\n/**\r\n * @classdesc\r\n * A quaternion.\r\n *\r\n * @class Quaternion\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x] - The x component.\r\n * @param {number} [y] - The y component.\r\n * @param {number} [z] - The z component.\r\n * @param {number} [w] - The w component.\r\n */\n\nvar Quaternion = new Class({\n  initialize: function Quaternion(x, y, z, w) {\n    /**\r\n     * The x component of this Quaternion.\r\n     *\r\n     * @name Phaser.Math.Quaternion#x\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    /**\r\n     * The y component of this Quaternion.\r\n     *\r\n     * @name Phaser.Math.Quaternion#y\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    /**\r\n     * The z component of this Quaternion.\r\n     *\r\n     * @name Phaser.Math.Quaternion#z\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    /**\r\n     * The w component of this Quaternion.\r\n     *\r\n     * @name Phaser.Math.Quaternion#w\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n    if (typeof x === 'object') {\n      this.x = x.x || 0;\n      this.y = x.y || 0;\n      this.z = x.z || 0;\n      this.w = x.w || 0;\n    } else {\n      this.x = x || 0;\n      this.y = y || 0;\n      this.z = z || 0;\n      this.w = w || 0;\n    }\n  },\n\n  /**\r\n   * Copy the components of a given Quaternion or Vector into this Quaternion.\r\n   *\r\n   * @method Phaser.Math.Quaternion#copy\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} src - The Quaternion or Vector to copy the components from.\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  copy: function copy(src) {\n    this.x = src.x;\n    this.y = src.y;\n    this.z = src.z;\n    this.w = src.w;\n    return this;\n  },\n\n  /**\r\n   * Set the components of this Quaternion.\r\n   *\r\n   * @method Phaser.Math.Quaternion#set\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(number|object)} [x=0] - The x component, or an object containing x, y, z, and w components.\r\n   * @param {number} [y=0] - The y component.\r\n   * @param {number} [z=0] - The z component.\r\n   * @param {number} [w=0] - The w component.\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  set: function set(x, y, z, w) {\n    if (typeof x === 'object') {\n      this.x = x.x || 0;\n      this.y = x.y || 0;\n      this.z = x.z || 0;\n      this.w = x.w || 0;\n    } else {\n      this.x = x || 0;\n      this.y = y || 0;\n      this.z = z || 0;\n      this.w = w || 0;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Add a given Quaternion or Vector to this Quaternion. Addition is component-wise.\r\n   *\r\n   * @method Phaser.Math.Quaternion#add\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to add to this Quaternion.\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  add: function add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    this.w += v.w;\n    return this;\n  },\n\n  /**\r\n   * Subtract a given Quaternion or Vector from this Quaternion. Subtraction is component-wise.\r\n   *\r\n   * @method Phaser.Math.Quaternion#subtract\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to subtract from this Quaternion.\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  subtract: function subtract(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    this.w -= v.w;\n    return this;\n  },\n\n  /**\r\n   * Scale this Quaternion by the given value.\r\n   *\r\n   * @method Phaser.Math.Quaternion#scale\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} scale - The value to scale this Quaternion by.\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  scale: function scale(_scale) {\n    this.x *= _scale;\n    this.y *= _scale;\n    this.z *= _scale;\n    this.w *= _scale;\n    return this;\n  },\n\n  /**\r\n   * Calculate the length of this Quaternion.\r\n   *\r\n   * @method Phaser.Math.Quaternion#length\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The length of this Quaternion.\r\n   */\n  length: function length() {\n    var x = this.x;\n    var y = this.y;\n    var z = this.z;\n    var w = this.w;\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n  },\n\n  /**\r\n   * Calculate the length of this Quaternion squared.\r\n   *\r\n   * @method Phaser.Math.Quaternion#lengthSq\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The length of this Quaternion, squared.\r\n   */\n  lengthSq: function lengthSq() {\n    var x = this.x;\n    var y = this.y;\n    var z = this.z;\n    var w = this.w;\n    return x * x + y * y + z * z + w * w;\n  },\n\n  /**\r\n   * Normalize this Quaternion.\r\n   *\r\n   * @method Phaser.Math.Quaternion#normalize\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  normalize: function normalize() {\n    var x = this.x;\n    var y = this.y;\n    var z = this.z;\n    var w = this.w;\n    var len = x * x + y * y + z * z + w * w;\n\n    if (len > 0) {\n      len = 1 / Math.sqrt(len);\n      this.x = x * len;\n      this.y = y * len;\n      this.z = z * len;\n      this.w = w * len;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Calculate the dot product of this Quaternion and the given Quaternion or Vector.\r\n   *\r\n   * @method Phaser.Math.Quaternion#dot\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to dot product with this Quaternion.\r\n   *\r\n   * @return {number} The dot product of this Quaternion and the given Quaternion or Vector.\r\n   */\n  dot: function dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n  },\n\n  /**\r\n   * Linearly interpolate this Quaternion towards the given Quaternion or Vector.\r\n   *\r\n   * @method Phaser.Math.Quaternion#lerp\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to interpolate towards.\r\n   * @param {number} [t=0] - The percentage of interpolation.\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  lerp: function lerp(v, t) {\n    if (t === undefined) {\n      t = 0;\n    }\n\n    var ax = this.x;\n    var ay = this.y;\n    var az = this.z;\n    var aw = this.w;\n    this.x = ax + t * (v.x - ax);\n    this.y = ay + t * (v.y - ay);\n    this.z = az + t * (v.z - az);\n    this.w = aw + t * (v.w - aw);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Math.Quaternion#rotationTo\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector3} a - [description]\r\n   * @param {Phaser.Math.Vector3} b - [description]\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  rotationTo: function rotationTo(a, b) {\n    var dot = a.x * b.x + a.y * b.y + a.z * b.z;\n\n    if (dot < -0.999999) {\n      if (tmpvec.copy(xUnitVec3).cross(a).length() < EPSILON) {\n        tmpvec.copy(yUnitVec3).cross(a);\n      }\n\n      tmpvec.normalize();\n      return this.setAxisAngle(tmpvec, Math.PI);\n    } else if (dot > 0.999999) {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n      this.w = 1;\n      return this;\n    } else {\n      tmpvec.copy(a).cross(b);\n      this.x = tmpvec.x;\n      this.y = tmpvec.y;\n      this.z = tmpvec.z;\n      this.w = 1 + dot;\n      return this.normalize();\n    }\n  },\n\n  /**\r\n   * Set the axes of this Quaternion.\r\n   *\r\n   * @method Phaser.Math.Quaternion#setAxes\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector3} view - The view axis.\r\n   * @param {Phaser.Math.Vector3} right - The right axis.\r\n   * @param {Phaser.Math.Vector3} up - The upwards axis.\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  setAxes: function setAxes(view, right, up) {\n    var m = tmpMat3.val;\n    m[0] = right.x;\n    m[3] = right.y;\n    m[6] = right.z;\n    m[1] = up.x;\n    m[4] = up.y;\n    m[7] = up.z;\n    m[2] = -view.x;\n    m[5] = -view.y;\n    m[8] = -view.z;\n    return this.fromMat3(tmpMat3).normalize();\n  },\n\n  /**\r\n   * Reset this Matrix to an identity (default) Quaternion.\r\n   *\r\n   * @method Phaser.Math.Quaternion#identity\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  identity: function identity() {\n    this.x = 0;\n    this.y = 0;\n    this.z = 0;\n    this.w = 1;\n    return this;\n  },\n\n  /**\r\n   * Set the axis angle of this Quaternion.\r\n   *\r\n   * @method Phaser.Math.Quaternion#setAxisAngle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector3} axis - The axis.\r\n   * @param {number} rad - The angle in radians.\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  setAxisAngle: function setAxisAngle(axis, rad) {\n    rad = rad * 0.5;\n    var s = Math.sin(rad);\n    this.x = s * axis.x;\n    this.y = s * axis.y;\n    this.z = s * axis.z;\n    this.w = Math.cos(rad);\n    return this;\n  },\n\n  /**\r\n   * Multiply this Quaternion by the given Quaternion or Vector.\r\n   *\r\n   * @method Phaser.Math.Quaternion#multiply\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} b - The Quaternion or Vector to multiply this Quaternion by.\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  multiply: function multiply(b) {\n    var ax = this.x;\n    var ay = this.y;\n    var az = this.z;\n    var aw = this.w;\n    var bx = b.x;\n    var by = b.y;\n    var bz = b.z;\n    var bw = b.w;\n    this.x = ax * bw + aw * bx + ay * bz - az * by;\n    this.y = ay * bw + aw * by + az * bx - ax * bz;\n    this.z = az * bw + aw * bz + ax * by - ay * bx;\n    this.w = aw * bw - ax * bx - ay * by - az * bz;\n    return this;\n  },\n\n  /**\r\n   * Smoothly linearly interpolate this Quaternion towards the given Quaternion or Vector.\r\n   *\r\n   * @method Phaser.Math.Quaternion#slerp\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} b - The Quaternion or Vector to interpolate towards.\r\n   * @param {number} t - The percentage of interpolation.\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  slerp: function slerp(b, t) {\n    // benchmarks: http://jsperf.com/quaternion-slerp-implementations\n    var ax = this.x;\n    var ay = this.y;\n    var az = this.z;\n    var aw = this.w;\n    var bx = b.x;\n    var by = b.y;\n    var bz = b.z;\n    var bw = b.w; // calc cosine\n\n    var cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n    if (cosom < 0) {\n      cosom = -cosom;\n      bx = -bx;\n      by = -by;\n      bz = -bz;\n      bw = -bw;\n    } // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n\n\n    var scale0 = 1 - t;\n    var scale1 = t; // calculate coefficients\n\n    if (1 - cosom > EPSILON) {\n      // standard case (slerp)\n      var omega = Math.acos(cosom);\n      var sinom = Math.sin(omega);\n      scale0 = Math.sin((1.0 - t) * omega) / sinom;\n      scale1 = Math.sin(t * omega) / sinom;\n    } // calculate final values\n\n\n    this.x = scale0 * ax + scale1 * bx;\n    this.y = scale0 * ay + scale1 * by;\n    this.z = scale0 * az + scale1 * bz;\n    this.w = scale0 * aw + scale1 * bw;\n    return this;\n  },\n\n  /**\r\n   * Invert this Quaternion.\r\n   *\r\n   * @method Phaser.Math.Quaternion#invert\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  invert: function invert() {\n    var a0 = this.x;\n    var a1 = this.y;\n    var a2 = this.z;\n    var a3 = this.w;\n    var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    var invDot = dot ? 1 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n    this.x = -a0 * invDot;\n    this.y = -a1 * invDot;\n    this.z = -a2 * invDot;\n    this.w = a3 * invDot;\n    return this;\n  },\n\n  /**\r\n   * Convert this Quaternion into its conjugate.\r\n   *\r\n   * Sets the x, y and z components.\r\n   *\r\n   * @method Phaser.Math.Quaternion#conjugate\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  conjugate: function conjugate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  },\n\n  /**\r\n   * Rotate this Quaternion on the X axis.\r\n   *\r\n   * @method Phaser.Math.Quaternion#rotateX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} rad - The rotation angle in radians.\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  rotateX: function rotateX(rad) {\n    rad *= 0.5;\n    var ax = this.x;\n    var ay = this.y;\n    var az = this.z;\n    var aw = this.w;\n    var bx = Math.sin(rad);\n    var bw = Math.cos(rad);\n    this.x = ax * bw + aw * bx;\n    this.y = ay * bw + az * bx;\n    this.z = az * bw - ay * bx;\n    this.w = aw * bw - ax * bx;\n    return this;\n  },\n\n  /**\r\n   * Rotate this Quaternion on the Y axis.\r\n   *\r\n   * @method Phaser.Math.Quaternion#rotateY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} rad - The rotation angle in radians.\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  rotateY: function rotateY(rad) {\n    rad *= 0.5;\n    var ax = this.x;\n    var ay = this.y;\n    var az = this.z;\n    var aw = this.w;\n    var by = Math.sin(rad);\n    var bw = Math.cos(rad);\n    this.x = ax * bw - az * by;\n    this.y = ay * bw + aw * by;\n    this.z = az * bw + ax * by;\n    this.w = aw * bw - ay * by;\n    return this;\n  },\n\n  /**\r\n   * Rotate this Quaternion on the Z axis.\r\n   *\r\n   * @method Phaser.Math.Quaternion#rotateZ\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} rad - The rotation angle in radians.\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  rotateZ: function rotateZ(rad) {\n    rad *= 0.5;\n    var ax = this.x;\n    var ay = this.y;\n    var az = this.z;\n    var aw = this.w;\n    var bz = Math.sin(rad);\n    var bw = Math.cos(rad);\n    this.x = ax * bw + ay * bz;\n    this.y = ay * bw - ax * bz;\n    this.z = az * bw + aw * bz;\n    this.w = aw * bw - az * bz;\n    return this;\n  },\n\n  /**\r\n   * Create a unit (or rotation) Quaternion from its x, y, and z components.\r\n   *\r\n   * Sets the w component.\r\n   *\r\n   * @method Phaser.Math.Quaternion#calculateW\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  calculateW: function calculateW() {\n    var x = this.x;\n    var y = this.y;\n    var z = this.z;\n    this.w = -Math.sqrt(1.0 - x * x - y * y - z * z);\n    return this;\n  },\n\n  /**\r\n   * Convert the given Matrix into this Quaternion.\r\n   *\r\n   * @method Phaser.Math.Quaternion#fromMat3\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Matrix3} mat - The Matrix to convert from.\r\n   *\r\n   * @return {Phaser.Math.Quaternion} This Quaternion.\r\n   */\n  fromMat3: function fromMat3(mat) {\n    // benchmarks:\n    //    http://jsperf.com/typed-array-access-speed\n    //    http://jsperf.com/conversion-of-3x3-matrix-to-quaternion\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    var m = mat.val;\n    var fTrace = m[0] + m[4] + m[8];\n    var fRoot;\n\n    if (fTrace > 0) {\n      // |w| > 1/2, may as well choose w > 1/2\n      fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n      this.w = 0.5 * fRoot;\n      fRoot = 0.5 / fRoot; // 1/(4w)\n\n      this.x = (m[7] - m[5]) * fRoot;\n      this.y = (m[2] - m[6]) * fRoot;\n      this.z = (m[3] - m[1]) * fRoot;\n    } else {\n      // |w| <= 1/2\n      var i = 0;\n\n      if (m[4] > m[0]) {\n        i = 1;\n      }\n\n      if (m[8] > m[i * 3 + i]) {\n        i = 2;\n      }\n\n      var j = siNext[i];\n      var k = siNext[j]; //  This isn't quite as clean without array access\n\n      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);\n      tmp[i] = 0.5 * fRoot;\n      fRoot = 0.5 / fRoot;\n      tmp[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n      tmp[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n      this.x = tmp[0];\n      this.y = tmp[1];\n      this.z = tmp[2];\n      this.w = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;\n    }\n\n    return this;\n  }\n});\nmodule.exports = Quaternion;","map":null,"metadata":{},"sourceType":"script"}