{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Body = require('./Body');\n\nvar Class = require('../../utils/Class');\n\nvar COLLIDES = require('./COLLIDES');\n\nvar CollisionMap = require('./CollisionMap');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar GetFastValue = require('../../utils/object/GetFastValue');\n\nvar HasValue = require('../../utils/object/HasValue');\n\nvar Set = require('../../structs/Set');\n\nvar Solver = require('./Solver');\n\nvar TILEMAP_FORMATS = require('../../tilemaps/Formats');\n\nvar TYPE = require('./TYPE');\n/**\r\n * @typedef {object} Phaser.Physics.Impact.WorldConfig\r\n *\r\n * @property {number} [gravity=0] - Sets {@link Phaser.Physics.Impact.World#gravity}\r\n * @property {number} [cellSize=64] - The size of the cells used for the broadphase pass. Increase this value if you have lots of large objects in the world.\r\n * @property {number} [timeScale=1] - A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.\r\n * @property {number} [maxStep=0.05] - [description]\r\n * @property {boolean} [debug=false] - Sets {@link Phaser.Physics.Impact.World#debug}.\r\n * @property {number} [maxVelocity=100] - The maximum velocity a body can move.\r\n * @property {boolean} [debugShowBody=true] - Whether the Body's boundary is drawn to the debug display.\r\n * @property {boolean} [debugShowVelocity=true] - Whether the Body's velocity is drawn to the debug display.\r\n * @property {number} [debugBodyColor=0xff00ff] - The color of this Body on the debug display.\r\n * @property {number} [debugVelocityColor=0x00ff00] - The color of the Body's velocity on the debug display.\r\n * @property {number} [maxVelocityX=maxVelocity] - Maximum X velocity objects can move.\r\n * @property {number} [maxVelocityY=maxVelocity] - Maximum Y velocity objects can move.\r\n * @property {number} [minBounceVelocity=40] - The minimum velocity an object can be moving at to be considered for bounce.\r\n * @property {number} [gravityFactor=1] - Gravity multiplier. Set to 0 for no gravity.\r\n * @property {number} [bounciness=0] - The default bounce, or restitution, of bodies in the world.\r\n * @property {(object|boolean)} [setBounds] - Should the world have bounds enabled by default?\r\n * @property {number} [setBounds.x=0] - The x coordinate of the world bounds.\r\n * @property {number} [setBounds.y=0] - The y coordinate of the world bounds.\r\n * @property {number} [setBounds.width] - The width of the world bounds.\r\n * @property {number} [setBounds.height] - The height of the world bounds.\r\n * @property {number} [setBounds.thickness=64] - The thickness of the walls of the world bounds.\r\n * @property {boolean} [setBounds.left=true] - Should the left-side world bounds wall be created?\r\n * @property {boolean} [setBounds.right=true] - Should the right-side world bounds wall be created?\r\n * @property {boolean} [setBounds.top=true] - Should the top world bounds wall be created?\r\n * @property {boolean} [setBounds.bottom=true] - Should the bottom world bounds wall be created?\r\n */\n\n/**\r\n * An object containing the 4 wall bodies that bound the physics world.\r\n * \r\n * @typedef {object} Phaser.Physics.Impact.WorldDefaults\r\n *\r\n * @property {boolean} debugShowBody - Whether the Body's boundary is drawn to the debug display.\r\n * @property {boolean} debugShowVelocity - Whether the Body's velocity is drawn to the debug display.\r\n * @property {number} bodyDebugColor - The color of this Body on the debug display.\r\n * @property {number} velocityDebugColor - The color of the Body's velocity on the debug display.\r\n * @property {number} maxVelocityX - Maximum X velocity objects can move.\r\n * @property {number} maxVelocityY - Maximum Y velocity objects can move.\r\n * @property {number} minBounceVelocity - The minimum velocity an object can be moving at to be considered for bounce.\r\n * @property {number} gravityFactor - Gravity multiplier. Set to 0 for no gravity.\r\n * @property {number} bounciness - The default bounce, or restitution, of bodies in the world.\r\n */\n\n/**\r\n * @typedef {object} Phaser.Physics.Impact.WorldWalls\r\n *\r\n * @property {?Phaser.Physics.Impact.Body} left - The left-side wall of the world bounds.\r\n * @property {?Phaser.Physics.Impact.Body} right - The right-side wall of the world bounds.\r\n * @property {?Phaser.Physics.Impact.Body} top - The top wall of the world bounds.\r\n * @property {?Phaser.Physics.Impact.Body} bottom - The bottom wall of the world bounds.\r\n */\n\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Impact World instance belongs.\r\n * @param {Phaser.Physics.Impact.WorldConfig} config - [description]\r\n */\n\n\nvar World = new Class({\n  Extends: EventEmitter,\n  initialize: function World(scene, config) {\n    EventEmitter.call(this);\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n\n    this.scene = scene;\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#bodies\r\n     * @type {Phaser.Structs.Set.<Phaser.Physics.Impact.Body>}\r\n     * @since 3.0.0\r\n     */\n\n    this.bodies = new Set();\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#gravity\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.gravity = GetFastValue(config, 'gravity', 0);\n    /**\r\n     * Spatial hash cell dimensions\r\n     *\r\n     * @name Phaser.Physics.Impact.World#cellSize\r\n     * @type {integer}\r\n     * @default 64\r\n     * @since 3.0.0\r\n     */\n\n    this.cellSize = GetFastValue(config, 'cellSize', 64);\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#collisionMap\r\n     * @type {Phaser.Physics.Impact.CollisionMap}\r\n     * @since 3.0.0\r\n     */\n\n    this.collisionMap = new CollisionMap();\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#timeScale\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\n\n    this.timeScale = GetFastValue(config, 'timeScale', 1);\n    /**\r\n     * Impacts maximum time step is 20 fps.\r\n     *\r\n     * @name Phaser.Physics.Impact.World#maxStep\r\n     * @type {number}\r\n     * @default 0.05\r\n     * @since 3.0.0\r\n     */\n\n    this.maxStep = GetFastValue(config, 'maxStep', 0.05);\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#enabled\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.enabled = true;\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#drawDebug\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.drawDebug = GetFastValue(config, 'debug', false);\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#debugGraphic\r\n     * @type {Phaser.GameObjects.Graphics}\r\n     * @since 3.0.0\r\n     */\n\n    this.debugGraphic;\n\n    var _maxVelocity = GetFastValue(config, 'maxVelocity', 100);\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#defaults\r\n     * @type {Phaser.Physics.Impact.WorldDefaults}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.defaults = {\n      debugShowBody: GetFastValue(config, 'debugShowBody', true),\n      debugShowVelocity: GetFastValue(config, 'debugShowVelocity', true),\n      bodyDebugColor: GetFastValue(config, 'debugBodyColor', 0xff00ff),\n      velocityDebugColor: GetFastValue(config, 'debugVelocityColor', 0x00ff00),\n      maxVelocityX: GetFastValue(config, 'maxVelocityX', _maxVelocity),\n      maxVelocityY: GetFastValue(config, 'maxVelocityY', _maxVelocity),\n      minBounceVelocity: GetFastValue(config, 'minBounceVelocity', 40),\n      gravityFactor: GetFastValue(config, 'gravityFactor', 1),\n      bounciness: GetFastValue(config, 'bounciness', 0)\n    };\n    /**\r\n     * An object containing the 4 wall bodies that bound the physics world.\r\n     *\r\n     * @name Phaser.Physics.Impact.World#walls\r\n     * @type {Phaser.Physics.Impact.WorldWalls}\r\n     * @since 3.0.0\r\n     */\n\n    this.walls = {\n      left: null,\n      right: null,\n      top: null,\n      bottom: null\n    };\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#delta\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.delta = 0;\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#_lastId\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this._lastId = 0;\n\n    if (GetFastValue(config, 'setBounds', false)) {\n      var boundsConfig = config['setBounds'];\n\n      if (typeof boundsConfig === 'boolean') {\n        this.setBounds();\n      } else {\n        var x = GetFastValue(boundsConfig, 'x', 0);\n        var y = GetFastValue(boundsConfig, 'y', 0);\n        var width = GetFastValue(boundsConfig, 'width', scene.sys.scale.width);\n        var height = GetFastValue(boundsConfig, 'height', scene.sys.scale.height);\n        var thickness = GetFastValue(boundsConfig, 'thickness', 64);\n        var left = GetFastValue(boundsConfig, 'left', true);\n        var right = GetFastValue(boundsConfig, 'right', true);\n        var top = GetFastValue(boundsConfig, 'top', true);\n        var bottom = GetFastValue(boundsConfig, 'bottom', true);\n        this.setBounds(x, y, width, height, thickness, left, right, top, bottom);\n      }\n    }\n\n    if (this.drawDebug) {\n      this.createDebugGraphic();\n    }\n  },\n\n  /**\r\n   * Sets the collision map for the world either from a Weltmeister JSON level in the cache or from\r\n   * a 2D array. If loading from a Weltmeister level, the map must have a layer called \"collision\".\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setCollisionMap\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|integer[][])} key - Either a string key that corresponds to a Weltmeister level\r\n   * in the cache, or a 2D array of collision IDs.\r\n   * @param {integer} tileSize - The size of a tile. This is optional if loading from a Weltmeister\r\n   * level in the cache.\r\n   *\r\n   * @return {?Phaser.Physics.Impact.CollisionMap} The newly created CollisionMap, or null if the method failed to\r\n   * create the CollisionMap.\r\n   */\n  setCollisionMap: function setCollisionMap(key, tileSize) {\n    if (typeof key === 'string') {\n      var tilemapData = this.scene.cache.tilemap.get(key);\n\n      if (!tilemapData || tilemapData.format !== TILEMAP_FORMATS.WELTMEISTER) {\n        console.warn('The specified key does not correspond to a Weltmeister tilemap: ' + key);\n        return null;\n      }\n\n      var layers = tilemapData.data.layer;\n      var collisionLayer;\n\n      for (var i = 0; i < layers.length; i++) {\n        if (layers[i].name === 'collision') {\n          collisionLayer = layers[i];\n          break;\n        }\n      }\n\n      if (tileSize === undefined) {\n        tileSize = collisionLayer.tilesize;\n      }\n\n      this.collisionMap = new CollisionMap(tileSize, collisionLayer.data);\n    } else if (Array.isArray(key)) {\n      this.collisionMap = new CollisionMap(tileSize, key);\n    } else {\n      console.warn('Invalid Weltmeister collision map data: ' + key);\n    }\n\n    return this.collisionMap;\n  },\n\n  /**\r\n   * @typedef {object} CollisionOptions\r\n   * \r\n   * @property {string} [slopeTileProperty=null] - Slope IDs can be stored on tiles directly\r\n   * using Impacts tileset editor. If a tile has a property with the given slopeTileProperty string\r\n   * name, the value of that property for the tile will be used for its slope mapping. E.g. a 45\r\n   * degree slope upward could be given a \"slope\" property with a value of 2.\r\n   * @property {object} [slopeMap=null] - A tile index to slope definition map.\r\n   * @property {integer} [defaultCollidingSlope=null] - If specified, the default slope ID to\r\n   * assign to a colliding tile. If not specified, the tile's index is used.\r\n   * @property {integer} [defaultNonCollidingSlope=0] - The default slope ID to assign to a\r\n   * non-colliding tile.\r\n   */\n\n  /**\r\n   * Sets the collision map for the world from a tilemap layer. Only tiles that are marked as\r\n   * colliding will be used. You can specify the mapping from tiles to slope IDs in a couple of\r\n   * ways. The easiest is to use Tiled and the slopeTileProperty option. Alternatively, you can\r\n   * manually create a slopeMap that stores the mapping between tile indices and slope IDs.\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setCollisionMapFromTilemapLayer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The tilemap layer to use.\r\n   * @param {CollisionOptions} [options] - Options for controlling the mapping from tiles to slope IDs.\r\n   *\r\n   * @return {Phaser.Physics.Impact.CollisionMap} The newly created CollisionMap.\r\n   */\n  setCollisionMapFromTilemapLayer: function setCollisionMapFromTilemapLayer(tilemapLayer, options) {\n    if (options === undefined) {\n      options = {};\n    }\n\n    var slopeProperty = GetFastValue(options, 'slopeProperty', null);\n    var slopeMap = GetFastValue(options, 'slopeMap', null);\n    var collidingSlope = GetFastValue(options, 'defaultCollidingSlope', null);\n    var nonCollidingSlope = GetFastValue(options, 'defaultNonCollidingSlope', 0);\n    var layerData = tilemapLayer.layer;\n    var tileSize = layerData.baseTileWidth;\n    var collisionData = [];\n\n    for (var ty = 0; ty < layerData.height; ty++) {\n      collisionData[ty] = [];\n\n      for (var tx = 0; tx < layerData.width; tx++) {\n        var tile = layerData.data[ty][tx];\n\n        if (tile && tile.collides) {\n          if (slopeProperty !== null && HasValue(tile.properties, slopeProperty)) {\n            collisionData[ty][tx] = parseInt(tile.properties[slopeProperty], 10);\n          } else if (slopeMap !== null && HasValue(slopeMap, tile.index)) {\n            collisionData[ty][tx] = slopeMap[tile.index];\n          } else if (collidingSlope !== null) {\n            collisionData[ty][tx] = collidingSlope;\n          } else {\n            collisionData[ty][tx] = tile.index;\n          }\n        } else {\n          collisionData[ty][tx] = nonCollidingSlope;\n        }\n      }\n    }\n\n    this.collisionMap = new CollisionMap(tileSize, collisionData);\n    return this.collisionMap;\n  },\n\n  /**\r\n   * Sets the bounds of the Physics world to match the given world pixel dimensions.\r\n   * You can optionally set which 'walls' to create: left, right, top or bottom.\r\n   * If none of the walls are given it will default to use the walls settings it had previously.\r\n   * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size\r\n   * the newly created bounds will also not have the left and right walls.\r\n   * Explicitly state them in the parameters to override this.\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [x] - The x coordinate of the top-left corner of the bounds.\r\n   * @param {number} [y] - The y coordinate of the top-left corner of the bounds.\r\n   * @param {number} [width] - The width of the bounds.\r\n   * @param {number} [height] - The height of the bounds.\r\n   * @param {number} [thickness=64] - [description]\r\n   * @param {boolean} [left=true] - If true will create the left bounds wall.\r\n   * @param {boolean} [right=true] - If true will create the right bounds wall.\r\n   * @param {boolean} [top=true] - If true will create the top bounds wall.\r\n   * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setBounds: function setBounds(x, y, width, height, thickness, left, right, top, bottom) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = this.scene.sys.scale.width;\n    }\n\n    if (height === undefined) {\n      height = this.scene.sys.scale.height;\n    }\n\n    if (thickness === undefined) {\n      thickness = 64;\n    }\n\n    if (left === undefined) {\n      left = true;\n    }\n\n    if (right === undefined) {\n      right = true;\n    }\n\n    if (top === undefined) {\n      top = true;\n    }\n\n    if (bottom === undefined) {\n      bottom = true;\n    }\n\n    this.updateWall(left, 'left', x - thickness, y, thickness, height);\n    this.updateWall(right, 'right', x + width, y, thickness, height);\n    this.updateWall(top, 'top', x, y - thickness, width, thickness);\n    this.updateWall(bottom, 'bottom', x, y + height, width, thickness);\n    return this;\n  },\n\n  /**\r\n   * position = 'left', 'right', 'top' or 'bottom'\r\n   *\r\n   * @method Phaser.Physics.Impact.World#updateWall\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} add - [description]\r\n   * @param {string} position - [description]\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   * @param {number} width - [description]\r\n   * @param {number} height - [description]\r\n   */\n  updateWall: function updateWall(add, position, x, y, width, height) {\n    var wall = this.walls[position];\n\n    if (add) {\n      if (wall) {\n        wall.resetSize(x, y, width, height);\n      } else {\n        this.walls[position] = this.create(x, y, width, height);\n        this.walls[position].name = position;\n        this.walls[position].gravityFactor = 0;\n        this.walls[position].collides = COLLIDES.FIXED;\n      }\n    } else {\n      if (wall) {\n        this.bodies.remove(wall);\n      }\n\n      this.walls[position] = null;\n    }\n  },\n\n  /**\r\n   * Creates a Graphics Game Object used for debug display and enables the world for debug drawing.\r\n   *\r\n   * @method Phaser.Physics.Impact.World#createDebugGraphic\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.GameObjects.Graphics} The Graphics object created that will have the debug visuals drawn to it.\r\n   */\n  createDebugGraphic: function createDebugGraphic() {\n    var graphic = this.scene.sys.add.graphics({\n      x: 0,\n      y: 0\n    });\n    graphic.setDepth(Number.MAX_VALUE);\n    this.debugGraphic = graphic;\n    this.drawDebug = true;\n    return graphic;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#getNextID\r\n   * @since 3.0.0\r\n   *\r\n   * @return {integer} [description]\r\n   */\n  getNextID: function getNextID() {\n    return this._lastId++;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#create\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   * @param {number} sizeX - [description]\r\n   * @param {number} sizeY - [description]\r\n   *\r\n   * @return {Phaser.Physics.Impact.Body} The Body that was added to this World.\r\n   */\n  create: function create(x, y, sizeX, sizeY) {\n    var body = new Body(this, x, y, sizeX, sizeY);\n    this.bodies.set(body);\n    return body;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#remove\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body} object - The Body to remove from this World.\r\n   */\n  remove: function remove(object) {\n    this.bodies.delete(object);\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#pause\r\n   * @fires Phaser.Physics.Impact.Events#PAUSE\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  pause: function pause() {\n    this.enabled = false;\n    this.emit(Events.PAUSE);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#resume\r\n   * @fires Phaser.Physics.Impact.Events#RESUME\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  resume: function resume() {\n    this.enabled = true;\n    this.emit(Events.RESUME);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#update\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n   * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n   */\n  update: function update(time, delta) {\n    if (!this.enabled || this.bodies.size === 0) {\n      return;\n    } //  Impact uses a divided delta value that is clamped to the maxStep (20fps) maximum\n\n\n    var clampedDelta = Math.min(delta / 1000, this.maxStep) * this.timeScale;\n    this.delta = clampedDelta; //  Update all active bodies\n\n    var i;\n    var body;\n    var bodies = this.bodies.entries;\n    var len = bodies.length;\n    var hash = {};\n    var size = this.cellSize;\n\n    for (i = 0; i < len; i++) {\n      body = bodies[i];\n\n      if (body.enabled) {\n        body.update(clampedDelta);\n      }\n    } //  Run collision against them all now they're in the new positions from the update\n\n\n    for (i = 0; i < len; i++) {\n      body = bodies[i];\n\n      if (body && !body.skipHash()) {\n        this.checkHash(body, hash, size);\n      }\n    }\n\n    if (this.drawDebug) {\n      var graphics = this.debugGraphic;\n      graphics.clear();\n\n      for (i = 0; i < len; i++) {\n        body = bodies[i];\n\n        if (body && body.willDrawDebug()) {\n          body.drawDebug(graphics);\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Check the body against the spatial hash.\r\n   *\r\n   * @method Phaser.Physics.Impact.World#checkHash\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body} body - [description]\r\n   * @param {object} hash - [description]\r\n   * @param {number} size - [description]\r\n   */\n  checkHash: function checkHash(body, hash, size) {\n    var checked = {};\n    var xmin = Math.floor(body.pos.x / size);\n    var ymin = Math.floor(body.pos.y / size);\n    var xmax = Math.floor((body.pos.x + body.size.x) / size) + 1;\n    var ymax = Math.floor((body.pos.y + body.size.y) / size) + 1;\n\n    for (var x = xmin; x < xmax; x++) {\n      for (var y = ymin; y < ymax; y++) {\n        if (!hash[x]) {\n          hash[x] = {};\n          hash[x][y] = [body];\n        } else if (!hash[x][y]) {\n          hash[x][y] = [body];\n        } else {\n          var cell = hash[x][y];\n\n          for (var c = 0; c < cell.length; c++) {\n            if (body.touches(cell[c]) && !checked[cell[c].id]) {\n              checked[cell[c].id] = true;\n              this.checkBodies(body, cell[c]);\n            }\n          }\n\n          cell.push(body);\n        }\n      }\n    }\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#checkBodies\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body} bodyA - [description]\r\n   * @param {Phaser.Physics.Impact.Body} bodyB - [description]\r\n   */\n  checkBodies: function checkBodies(bodyA, bodyB) {\n    //  2 fixed bodies won't do anything\n    if (bodyA.collides === COLLIDES.FIXED && bodyB.collides === COLLIDES.FIXED) {\n      return;\n    } //  bitwise checks\n\n\n    if (bodyA.checkAgainst & bodyB.type) {\n      bodyA.check(bodyB);\n    }\n\n    if (bodyB.checkAgainst & bodyA.type) {\n      bodyB.check(bodyA);\n    }\n\n    if (bodyA.collides && bodyB.collides && bodyA.collides + bodyB.collides > COLLIDES.ACTIVE) {\n      Solver(this, bodyA, bodyB);\n    }\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setCollidesNever\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setCollidesNever: function setCollidesNever(bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].collides = COLLIDES.NEVER;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setLite\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setLite: function setLite(bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].collides = COLLIDES.LITE;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setPassive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setPassive: function setPassive(bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].collides = COLLIDES.PASSIVE;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setActive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setActive: function setActive(bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].collides = COLLIDES.ACTIVE;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setFixed\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setFixed: function setFixed(bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].collides = COLLIDES.FIXED;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setTypeNone\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setTypeNone: function setTypeNone(bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].type = TYPE.NONE;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setTypeA\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setTypeA: function setTypeA(bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].type = TYPE.A;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setTypeB\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setTypeB: function setTypeB(bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].type = TYPE.B;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setAvsB\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setAvsB: function setAvsB(bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].type = TYPE.A;\n      bodies[i].checkAgainst = TYPE.B;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setBvsA\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setBvsA: function setBvsA(bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].type = TYPE.B;\n      bodies[i].checkAgainst = TYPE.A;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setCheckAgainstNone\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setCheckAgainstNone: function setCheckAgainstNone(bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].checkAgainst = TYPE.NONE;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setCheckAgainstA\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setCheckAgainstA: function setCheckAgainstA(bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].checkAgainst = TYPE.A;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setCheckAgainstB\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setCheckAgainstB: function setCheckAgainstB(bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].checkAgainst = TYPE.B;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#shutdown\r\n   * @since 3.0.0\r\n   */\n  shutdown: function shutdown() {\n    this.removeAllListeners();\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    this.removeAllListeners();\n    this.scene = null;\n    this.bodies.clear();\n    this.bodies = null;\n    this.collisionMap = null;\n  }\n});\nmodule.exports = World;","map":null,"metadata":{},"sourceType":"script"}