{"ast":null,"code":"/**\r\n* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.\r\n*\r\n* @class Detector\r\n*/\n// TODO: speculative contacts\nvar Detector = {};\nmodule.exports = Detector;\n\nvar SAT = require('./SAT');\n\nvar Pair = require('./Pair');\n\nvar Bounds = require('../geometry/Bounds');\n\n(function () {\n  /**\r\n   * Finds all collisions given a list of pairs.\r\n   * @method collisions\r\n   * @param {pair[]} broadphasePairs\r\n   * @param {engine} engine\r\n   * @return {array} collisions\r\n   */\n  Detector.collisions = function (broadphasePairs, engine) {\n    var collisions = [],\n        pairsTable = engine.pairs.table; // @if DEBUG\n\n    var metrics = engine.metrics; // @endif\n\n    for (var i = 0; i < broadphasePairs.length; i++) {\n      var bodyA = broadphasePairs[i][0],\n          bodyB = broadphasePairs[i][1];\n      if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping)) continue;\n      if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter)) continue; // @if DEBUG\n\n      metrics.midphaseTests += 1; // @endif\n      // mid phase\n\n      if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {\n        for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {\n          var partA = bodyA.parts[j];\n\n          for (var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++) {\n            var partB = bodyB.parts[k];\n\n            if (partA === bodyA && partB === bodyB || Bounds.overlaps(partA.bounds, partB.bounds)) {\n              // find a previous collision we could reuse\n              var pairId = Pair.id(partA, partB),\n                  pair = pairsTable[pairId],\n                  previousCollision;\n\n              if (pair && pair.isActive) {\n                previousCollision = pair.collision;\n              } else {\n                previousCollision = null;\n              } // narrow phase\n\n\n              var collision = SAT.collides(partA, partB, previousCollision); // @if DEBUG\n\n              metrics.narrowphaseTests += 1;\n              if (collision.reused) metrics.narrowReuseCount += 1; // @endif\n\n              if (collision.collided) {\n                collisions.push(collision); // @if DEBUG\n\n                metrics.narrowDetections += 1; // @endif\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return collisions;\n  };\n  /**\r\n   * Returns `true` if both supplied collision filters will allow a collision to occur.\r\n   * See `body.collisionFilter` for more information.\r\n   * @method canCollide\r\n   * @param {} filterA\r\n   * @param {} filterB\r\n   * @return {bool} `true` if collision can occur\r\n   */\n\n\n  Detector.canCollide = function (filterA, filterB) {\n    if (filterA.group === filterB.group && filterA.group !== 0) return filterA.group > 0;\n    return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}