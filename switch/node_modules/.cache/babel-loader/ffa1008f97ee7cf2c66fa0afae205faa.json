{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar CanvasPool = require('../../display/canvas/CanvasPool');\n\nvar Class = require('../../utils/Class');\n\nvar Components = require('../components');\n\nvar CONST = require('../../const');\n\nvar GameObject = require('../GameObject');\n\nvar GetPowerOfTwo = require('../../math/pow2/GetPowerOfTwo');\n\nvar Smoothing = require('../../display/canvas/Smoothing');\n\nvar TileSpriteRender = require('./TileSpriteRender');\n\nvar Vector2 = require('../../math/Vector2'); //  bitmask flag for GameObject.renderMask\n\n\nvar _FLAG = 8; // 1000\n\n/**\r\n * @classdesc\r\n * A TileSprite is a Sprite that has a repeating texture.\r\n *\r\n * The texture can be scrolled and scaled independently of the TileSprite itself. Textures will automatically wrap and\r\n * are designed so that you can create game backdrops using seamless textures as a source.\r\n *\r\n * You shouldn't ever create a TileSprite any larger than your actual canvas size. If you want to create a large repeating background\r\n * that scrolls across the whole map of your game, then you create a TileSprite that fits the canvas size and then use the `tilePosition`\r\n * property to scroll the texture as the player moves. If you create a TileSprite that is thousands of pixels in size then it will \r\n * consume huge amounts of memory and cause performance issues. Remember: use `tilePosition` to scroll your texture and `tileScale` to\r\n * adjust the scale of the texture - don't resize the sprite itself or make it larger than it needs.\r\n * \r\n * An important note about Tile Sprites and NPOT textures: Internally, TileSprite textures use GL_REPEAT to provide\r\n * seamless repeating of the textures. This, combined with the way in which the textures are handled in WebGL, means\r\n * they need to be POT (power-of-two) sizes in order to wrap. If you provide a NPOT (non power-of-two) texture to a\r\n * TileSprite it will generate a POT sized canvas and draw your texture to it, scaled up to the POT size. It's then\r\n * scaled back down again during rendering to the original dimensions. While this works, in that it allows you to use\r\n * any size texture for a Tile Sprite, it does mean that NPOT textures are going to appear anti-aliased when rendered,\r\n * due to the interpolation that took place when it was resized into a POT texture. This is especially visible in\r\n * pixel art graphics. If you notice it and it becomes an issue, the only way to avoid it is to ensure that you\r\n * provide POT textures for Tile Sprites.\r\n *\r\n * @class TileSprite\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Crop\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {integer} width - The width of the Game Object. If zero it will use the size of the texture frame.\r\n * @param {integer} height - The height of the Game Object. If zero it will use the size of the texture frame.\r\n * @param {string} textureKey - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frameKey] - An optional frame from the Texture this Game Object is rendering with.\r\n */\n\nvar TileSprite = new Class({\n  Extends: GameObject,\n  Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Crop, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScaleMode, Components.ScrollFactor, Components.Tint, Components.Transform, Components.Visible, TileSpriteRender],\n  initialize: function TileSprite(scene, x, y, width, height, textureKey, frameKey) {\n    var renderer = scene.sys.game.renderer;\n    GameObject.call(this, scene, 'TileSprite');\n    var displayTexture = scene.sys.textures.get(textureKey);\n    var displayFrame = displayTexture.get(frameKey);\n\n    if (!width || !height) {\n      width = displayFrame.width;\n      height = displayFrame.height;\n    } else {\n      width = Math.floor(width);\n      height = Math.floor(height);\n    }\n    /**\r\n     * Internal tile position vector.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#_tilePosition\r\n     * @type {Phaser.Math.Vector2}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n\n    this._tilePosition = new Vector2();\n    /**\r\n     * Internal tile scale vector.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#_tileScale\r\n     * @type {Phaser.Math.Vector2}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._tileScale = new Vector2(1, 1);\n    /**\r\n     * Whether the Tile Sprite has changed in some way, requiring an re-render of its tile texture.\r\n     *\r\n     * Such changes include the texture frame and scroll position of the Tile Sprite.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#dirty\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.dirty = false;\n    /**\r\n     * The renderer in use by this Tile Sprite.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#renderer\r\n     * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n     * @since 3.0.0\r\n     */\n\n    this.renderer = renderer;\n    /**\r\n     * The Canvas element that the TileSprite renders its fill pattern in to.\r\n     * Only used in Canvas mode.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#canvas\r\n     * @type {?HTMLCanvasElement}\r\n     * @since 3.12.0\r\n     */\n\n    this.canvas = CanvasPool.create(this, width, height);\n    /**\r\n     * The Context of the Canvas element that the TileSprite renders its fill pattern in to.\r\n     * Only used in Canvas mode.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#context\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.12.0\r\n     */\n\n    this.context = this.canvas.getContext('2d');\n    /**\r\n     * The Texture the TileSprite is using as its fill pattern.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#displayTexture\r\n     * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this.displayTexture = displayTexture;\n    /**\r\n     * The Frame the TileSprite is using as its fill pattern.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#displayFrame\r\n     * @type {Phaser.Textures.Frame}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this.displayFrame = displayFrame;\n    /**\r\n     * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#_crop\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._crop = this.resetCropObject();\n    /**\r\n     * The Texture this Game Object is using to render with.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#texture\r\n     * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}\r\n     * @since 3.0.0\r\n     */\n\n    this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);\n    /**\r\n     * The Texture Frame this Game Object is using to render with.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#frame\r\n     * @type {Phaser.Textures.Frame}\r\n     * @since 3.0.0\r\n     */\n\n    this.frame = this.texture.get();\n    /**\r\n     * The next power of two value from the width of the Fill Pattern frame.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#potWidth\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.potWidth = GetPowerOfTwo(displayFrame.width);\n    /**\r\n     * The next power of two value from the height of the Fill Pattern frame.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#potHeight\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.potHeight = GetPowerOfTwo(displayFrame.height);\n    /**\r\n     * The Canvas that the TileSprites texture is rendered to.\r\n     * This is used to create a WebGL texture from.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#fillCanvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.12.0\r\n     */\n\n    this.fillCanvas = CanvasPool.create2D(this, this.potWidth, this.potHeight);\n    /**\r\n     * The Canvas Context used to render the TileSprites texture.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#fillContext\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.12.0\r\n     */\n\n    this.fillContext = this.fillCanvas.getContext('2d');\n    /**\r\n     * The texture that the Tile Sprite is rendered to, which is then rendered to a Scene.\r\n     * In WebGL this is a WebGLTexture. In Canvas it's a Canvas Fill Pattern.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#fillPattern\r\n     * @type {?(WebGLTexture|CanvasPattern)}\r\n     * @since 3.12.0\r\n     */\n\n    this.fillPattern = null;\n    this.setPosition(x, y);\n    this.setSize(width, height);\n    this.setFrame(frameKey);\n    this.setOriginFromFrame();\n    this.initPipeline();\n\n    if (scene.sys.game.config.renderType === CONST.WEBGL) {\n      scene.sys.game.renderer.onContextRestored(function (renderer) {\n        var gl = renderer.gl;\n        this.dirty = true;\n        this.fillPattern = null;\n        this.fillPattern = renderer.createTexture2D(0, gl.LINEAR, gl.LINEAR, gl.REPEAT, gl.REPEAT, gl.RGBA, this.fillCanvas, this.potWidth, this.potHeight);\n      }, this);\n    }\n  },\n\n  /**\r\n   * Sets the texture and frame this Game Object will use to render with.\r\n   *\r\n   * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n   *\r\n   * @method Phaser.GameObjects.TileSprite#setTexture\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n   * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setTexture: function setTexture(key, frame) {\n    this.displayTexture = this.scene.sys.textures.get(key);\n    return this.setFrame(frame);\n  },\n\n  /**\r\n   * Sets the frame this Game Object will use to render with.\r\n   *\r\n   * The Frame has to belong to the current Texture being used.\r\n   *\r\n   * It can be either a string or an index.\r\n   *\r\n   * @method Phaser.GameObjects.TileSprite#setFrame\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|integer)} frame - The name or index of the frame within the Texture.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setFrame: function setFrame(frame) {\n    this.displayFrame = this.displayTexture.get(frame);\n\n    if (!this.displayFrame.cutWidth || !this.displayFrame.cutHeight) {\n      this.renderFlags &= ~_FLAG;\n    } else {\n      this.renderFlags |= _FLAG;\n    }\n\n    this.dirty = true;\n    this.updateTileTexture();\n    return this;\n  },\n\n  /**\r\n   * Sets {@link Phaser.GameObjects.TileSprite#tilePositionX} and {@link Phaser.GameObjects.TileSprite#tilePositionY}.\r\n   *\r\n   * @method Phaser.GameObjects.TileSprite#setTilePosition\r\n   * @since 3.3.0\r\n   *\r\n   * @param {number} [x] - The x position of this sprite's tiling texture.\r\n   * @param {number} [y] - The y position of this sprite's tiling texture.\r\n   *\r\n   * @return {this} This Tile Sprite instance.\r\n   */\n  setTilePosition: function setTilePosition(x, y) {\n    if (x !== undefined) {\n      this.tilePositionX = x;\n    }\n\n    if (y !== undefined) {\n      this.tilePositionY = y;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets {@link Phaser.GameObjects.TileSprite#tileScaleX} and {@link Phaser.GameObjects.TileSprite#tileScaleY}.\r\n   *\r\n   * @method Phaser.GameObjects.TileSprite#setTileScale\r\n   * @since 3.12.0\r\n   *\r\n   * @param {number} [x] - The horizontal scale of the tiling texture. If not given it will use the current `tileScaleX` value.\r\n   * @param {number} [y=x] - The vertical scale of the tiling texture. If not given it will use the `x` value.\r\n   *\r\n   * @return {this} This Tile Sprite instance.\r\n   */\n  setTileScale: function setTileScale(x, y) {\n    if (x === undefined) {\n      x = this.tileScaleX;\n    }\n\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.tileScaleX = x;\n    this.tileScaleY = y;\n    return this;\n  },\n\n  /**\r\n   * Render the tile texture if it is dirty, or if the frame has changed.\r\n   *\r\n   * @method Phaser.GameObjects.TileSprite#updateTileTexture\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  updateTileTexture: function updateTileTexture() {\n    if (!this.dirty || !this.renderer) {\n      return;\n    } //  Draw the displayTexture to our fillCanvas\n\n\n    var frame = this.displayFrame;\n    var ctx = this.fillContext;\n    var canvas = this.fillCanvas;\n    var fw = this.potWidth;\n    var fh = this.potHeight;\n\n    if (!this.renderer.gl) {\n      fw = frame.cutWidth;\n      fh = frame.cutHeight;\n    }\n\n    ctx.clearRect(0, 0, fw, fh);\n    canvas.width = fw;\n    canvas.height = fh;\n    ctx.drawImage(frame.source.image, frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight, 0, 0, fw, fh);\n\n    if (this.renderer.gl) {\n      this.fillPattern = this.renderer.canvasToTexture(canvas, this.fillPattern);\n    } else {\n      this.fillPattern = ctx.createPattern(canvas, 'repeat');\n    }\n\n    this.updateCanvas();\n    this.dirty = false;\n  },\n\n  /**\r\n   * Draw the fill pattern to the internal canvas.\r\n   *\r\n   * @method Phaser.GameObjects.TileSprite#updateCanvas\r\n   * @private\r\n   * @since 3.12.0\r\n   */\n  updateCanvas: function updateCanvas() {\n    var canvas = this.canvas;\n\n    if (canvas.width !== this.width || canvas.height !== this.height) {\n      canvas.width = this.width;\n      canvas.height = this.height;\n      this.frame.setSize(this.width, this.height);\n      this.updateDisplayOrigin();\n      this.dirty = true;\n    }\n\n    if (!this.dirty || this.renderer && this.renderer.gl) {\n      this.dirty = false;\n      return;\n    }\n\n    var ctx = this.context;\n\n    if (!this.scene.sys.game.config.antialias) {\n      Smoothing.disable(ctx);\n    }\n\n    var scaleX = this._tileScale.x;\n    var scaleY = this._tileScale.y;\n    var positionX = this._tilePosition.x;\n    var positionY = this._tilePosition.y;\n    ctx.clearRect(0, 0, this.width, this.height);\n    ctx.save();\n    ctx.scale(scaleX, scaleY);\n    ctx.translate(-positionX, -positionY);\n    ctx.fillStyle = this.fillPattern;\n    ctx.fillRect(positionX, positionY, this.width / scaleX, this.height / scaleY);\n    ctx.restore();\n    this.dirty = false;\n  },\n\n  /**\r\n   * Internal destroy handler, called as part of the destroy process.\r\n   *\r\n   * @method Phaser.GameObjects.TileSprite#preDestroy\r\n   * @protected\r\n   * @since 3.9.0\r\n   */\n  preDestroy: function preDestroy() {\n    if (this.renderer && this.renderer.gl) {\n      this.renderer.deleteTexture(this.fillPattern);\n    }\n\n    CanvasPool.remove(this.canvas);\n    CanvasPool.remove(this.fillCanvas);\n    this.fillPattern = null;\n    this.fillContext = null;\n    this.fillCanvas = null;\n    this.displayTexture = null;\n    this.displayFrame = null;\n    this.texture.destroy();\n    this.renderer = null;\n  },\n\n  /**\r\n   * The horizontal scroll position of the Tile Sprite.\r\n   *\r\n   * @name Phaser.GameObjects.TileSprite#tilePositionX\r\n   * @type {number}\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n  tilePositionX: {\n    get: function get() {\n      return this._tilePosition.x;\n    },\n    set: function set(value) {\n      this._tilePosition.x = value;\n      this.dirty = true;\n    }\n  },\n\n  /**\r\n   * The vertical scroll position of the Tile Sprite.\r\n   *\r\n   * @name Phaser.GameObjects.TileSprite#tilePositionY\r\n   * @type {number}\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n  tilePositionY: {\n    get: function get() {\n      return this._tilePosition.y;\n    },\n    set: function set(value) {\n      this._tilePosition.y = value;\n      this.dirty = true;\n    }\n  },\n\n  /**\r\n   * The horizontal scale of the Tile Sprite texture.\r\n   *\r\n   * @name Phaser.GameObjects.TileSprite#tileScaleX\r\n   * @type {number}\r\n   * @default 1\r\n   * @since 3.11.0\r\n   */\n  tileScaleX: {\n    get: function get() {\n      return this._tileScale.x;\n    },\n    set: function set(value) {\n      this._tileScale.x = value;\n      this.dirty = true;\n    }\n  },\n\n  /**\r\n   * The vertical scale of the Tile Sprite texture.\r\n   *\r\n   * @name Phaser.GameObjects.TileSprite#tileScaleY\r\n   * @type {number}\r\n   * @default 1\r\n   * @since 3.11.0\r\n   */\n  tileScaleY: {\n    get: function get() {\n      return this._tileScale.y;\n    },\n    set: function set(value) {\n      this._tileScale.y = value;\n      this.dirty = true;\n    }\n  }\n});\nmodule.exports = TileSprite;","map":null,"metadata":{},"sourceType":"script"}