{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Utils = require('../../../renderer/webgl/Utils');\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.DynamicBitmapText#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.DynamicBitmapText} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\n\n\nvar DynamicBitmapTextWebGLRenderer = function DynamicBitmapTextWebGLRenderer(renderer, src, interpolationPercentage, camera, parentMatrix) {\n  var text = src.text;\n  var textLength = text.length;\n\n  if (textLength === 0) {\n    return;\n  }\n\n  var pipeline = this.pipeline;\n  renderer.setPipeline(pipeline, src);\n  var crop = src.cropWidth > 0 || src.cropHeight > 0;\n\n  if (crop) {\n    pipeline.flush();\n    renderer.pushScissor(src.x, src.y, src.cropWidth * src.scaleX, src.cropHeight * src.scaleY);\n  }\n\n  var camMatrix = pipeline._tempMatrix1;\n  var spriteMatrix = pipeline._tempMatrix2;\n  var calcMatrix = pipeline._tempMatrix3;\n  var fontMatrix = pipeline._tempMatrix4;\n  spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\n  camMatrix.copyFrom(camera.matrix);\n\n  if (parentMatrix) {\n    //  Multiply the camera by the parent matrix\n    camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY); //  Undo the camera scroll\n\n    spriteMatrix.e = src.x;\n    spriteMatrix.f = src.y; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n    camMatrix.multiply(spriteMatrix, calcMatrix);\n  } else {\n    spriteMatrix.e -= camera.scrollX * src.scrollFactorX;\n    spriteMatrix.f -= camera.scrollY * src.scrollFactorY; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n    camMatrix.multiply(spriteMatrix, calcMatrix);\n  }\n\n  var frame = src.frame;\n  var texture = frame.glTexture;\n  var textureX = frame.cutX;\n  var textureY = frame.cutY;\n  var textureWidth = texture.width;\n  var textureHeight = texture.height;\n  var tintEffect = src._isTinted && src.tintFill;\n  var tintTL = Utils.getTintAppendFloatAlpha(src._tintTL, camera.alpha * src._alphaTL);\n  var tintTR = Utils.getTintAppendFloatAlpha(src._tintTR, camera.alpha * src._alphaTR);\n  var tintBL = Utils.getTintAppendFloatAlpha(src._tintBL, camera.alpha * src._alphaBL);\n  var tintBR = Utils.getTintAppendFloatAlpha(src._tintBR, camera.alpha * src._alphaBR);\n  pipeline.setTexture2D(texture, 0);\n  var xAdvance = 0;\n  var yAdvance = 0;\n  var charCode = 0;\n  var lastCharCode = 0;\n  var letterSpacing = src.letterSpacing;\n  var glyph;\n  var glyphX = 0;\n  var glyphY = 0;\n  var glyphW = 0;\n  var glyphH = 0;\n  var lastGlyph;\n  var scrollX = src.scrollX;\n  var scrollY = src.scrollY;\n  var fontData = src.fontData;\n  var chars = fontData.chars;\n  var lineHeight = fontData.lineHeight;\n  var scale = src.fontSize / fontData.size;\n  var rotation = 0;\n  var align = src._align;\n  var currentLine = 0;\n  var lineOffsetX = 0; //  Update the bounds - skipped internally if not dirty\n\n  src.getTextBounds(false);\n  var lineData = src._bounds.lines;\n\n  if (align === 1) {\n    lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;\n  } else if (align === 2) {\n    lineOffsetX = lineData.longest - lineData.lengths[0];\n  }\n\n  var roundPixels = camera.roundPixels;\n  var displayCallback = src.displayCallback;\n  var callbackData = src.callbackData;\n\n  for (var i = 0; i < textLength; i++) {\n    charCode = text.charCodeAt(i); //  Carriage-return\n\n    if (charCode === 10) {\n      currentLine++;\n\n      if (align === 1) {\n        lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;\n      } else if (align === 2) {\n        lineOffsetX = lineData.longest - lineData.lengths[currentLine];\n      }\n\n      xAdvance = 0;\n      yAdvance += lineHeight;\n      lastGlyph = null;\n      continue;\n    }\n\n    glyph = chars[charCode];\n\n    if (!glyph) {\n      continue;\n    }\n\n    glyphX = textureX + glyph.x;\n    glyphY = textureY + glyph.y;\n    glyphW = glyph.width;\n    glyphH = glyph.height;\n    var x = glyph.xOffset + xAdvance - scrollX;\n    var y = glyph.yOffset + yAdvance - scrollY;\n\n    if (lastGlyph !== null) {\n      var kerningOffset = glyph.kerning[lastCharCode];\n      x += kerningOffset !== undefined ? kerningOffset : 0;\n    }\n\n    xAdvance += glyph.xAdvance + letterSpacing;\n    lastGlyph = glyph;\n    lastCharCode = charCode; //  Nothing to render or a space? Then skip to the next glyph\n\n    if (glyphW === 0 || glyphH === 0 || charCode === 32) {\n      continue;\n    }\n\n    scale = src.fontSize / src.fontData.size;\n    rotation = 0;\n\n    if (displayCallback) {\n      callbackData.color = 0;\n      callbackData.tint.topLeft = tintTL;\n      callbackData.tint.topRight = tintTR;\n      callbackData.tint.bottomLeft = tintBL;\n      callbackData.tint.bottomRight = tintBR;\n      callbackData.index = i;\n      callbackData.charCode = charCode;\n      callbackData.x = x;\n      callbackData.y = y;\n      callbackData.scale = scale;\n      callbackData.rotation = rotation;\n      callbackData.data = glyph.data;\n      var output = displayCallback(callbackData);\n      x = output.x;\n      y = output.y;\n      scale = output.scale;\n      rotation = output.rotation;\n\n      if (output.color) {\n        tintTL = output.color;\n        tintTR = output.color;\n        tintBL = output.color;\n        tintBR = output.color;\n      } else {\n        tintTL = output.tint.topLeft;\n        tintTR = output.tint.topRight;\n        tintBL = output.tint.bottomLeft;\n        tintBR = output.tint.bottomRight;\n      }\n\n      tintTL = Utils.getTintAppendFloatAlpha(tintTL, camera.alpha * src._alphaTL);\n      tintTR = Utils.getTintAppendFloatAlpha(tintTR, camera.alpha * src._alphaTR);\n      tintBL = Utils.getTintAppendFloatAlpha(tintBL, camera.alpha * src._alphaBL);\n      tintBR = Utils.getTintAppendFloatAlpha(tintBR, camera.alpha * src._alphaBR);\n    }\n\n    x *= scale;\n    y *= scale;\n    x -= src.displayOriginX;\n    y -= src.displayOriginY;\n    x += lineOffsetX;\n    fontMatrix.applyITRS(x, y, rotation, scale, scale);\n    calcMatrix.multiply(fontMatrix, spriteMatrix);\n    var u0 = glyphX / textureWidth;\n    var v0 = glyphY / textureHeight;\n    var u1 = (glyphX + glyphW) / textureWidth;\n    var v1 = (glyphY + glyphH) / textureHeight;\n    var xw = glyphW;\n    var yh = glyphH;\n    var tx0 = spriteMatrix.e;\n    var ty0 = spriteMatrix.f;\n    var tx1 = yh * spriteMatrix.c + spriteMatrix.e;\n    var ty1 = yh * spriteMatrix.d + spriteMatrix.f;\n    var tx2 = xw * spriteMatrix.a + yh * spriteMatrix.c + spriteMatrix.e;\n    var ty2 = xw * spriteMatrix.b + yh * spriteMatrix.d + spriteMatrix.f;\n    var tx3 = xw * spriteMatrix.a + spriteMatrix.e;\n    var ty3 = xw * spriteMatrix.b + spriteMatrix.f;\n\n    if (roundPixels) {\n      tx0 = Math.round(tx0);\n      ty0 = Math.round(ty0);\n      tx1 = Math.round(tx1);\n      ty1 = Math.round(ty1);\n      tx2 = Math.round(tx2);\n      ty2 = Math.round(ty2);\n      tx3 = Math.round(tx3);\n      ty3 = Math.round(ty3);\n    }\n\n    pipeline.batchQuad(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, 0);\n  }\n\n  if (crop) {\n    pipeline.flush();\n    renderer.popScissor();\n  }\n};\n\nmodule.exports = DynamicBitmapTextWebGLRenderer;","map":null,"metadata":{},"sourceType":"script"}