{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Bodies = require('./lib/factory/Bodies');\n\nvar Class = require('../../utils/Class');\n\nvar Common = require('./lib/core/Common');\n\nvar Composite = require('./lib/body/Composite');\n\nvar Engine = require('./lib/core/Engine');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar GetFastValue = require('../../utils/object/GetFastValue');\n\nvar GetValue = require('../../utils/object/GetValue');\n\nvar MatterBody = require('./lib/body/Body');\n\nvar MatterEvents = require('./lib/core/Events');\n\nvar MatterTileBody = require('./MatterTileBody');\n\nvar MatterWorld = require('./lib/body/World');\n\nvar Vector = require('./lib/geometry/Vector');\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Matter World instance belongs.\r\n * @param {object} config - [description]\r\n */\n\n\nvar World = new Class({\n  Extends: EventEmitter,\n  initialize: function World(scene, config) {\n    EventEmitter.call(this);\n    /**\r\n     * The Scene to which this Matter World instance belongs.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n\n    this.scene = scene;\n    /**\r\n     * An instance of the MatterJS Engine.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#engine\r\n     * @type {MatterJS.Engine}\r\n     * @since 3.0.0\r\n     */\n\n    this.engine = Engine.create(config);\n    /**\r\n     * A `World` composite object that will contain all simulated bodies and constraints.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#localWorld\r\n     * @type {MatterJS.World}\r\n     * @since 3.0.0\r\n     */\n\n    this.localWorld = this.engine.world;\n    var gravity = GetValue(config, 'gravity', null);\n\n    if (gravity) {\n      this.setGravity(gravity.x, gravity.y, gravity.scale);\n    }\n    /**\r\n     * An object containing the 4 wall bodies that bound the physics world.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#walls\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.walls = {\n      left: null,\n      right: null,\n      top: null,\n      bottom: null\n    };\n\n    if (GetFastValue(config, 'setBounds', false)) {\n      var boundsConfig = config['setBounds'];\n\n      if (typeof boundsConfig === 'boolean') {\n        this.setBounds();\n      } else {\n        var x = GetFastValue(boundsConfig, 'x', 0);\n        var y = GetFastValue(boundsConfig, 'y', 0);\n        var width = GetFastValue(boundsConfig, 'width', scene.sys.scale.width);\n        var height = GetFastValue(boundsConfig, 'height', scene.sys.scale.height);\n        var thickness = GetFastValue(boundsConfig, 'thickness', 64);\n        var left = GetFastValue(boundsConfig, 'left', true);\n        var right = GetFastValue(boundsConfig, 'right', true);\n        var top = GetFastValue(boundsConfig, 'top', true);\n        var bottom = GetFastValue(boundsConfig, 'bottom', true);\n        this.setBounds(x, y, width, height, thickness, left, right, top, bottom);\n      }\n    }\n    /**\r\n     * A flag that toggles if the world is enabled or not.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#enabled\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n\n    this.enabled = GetValue(config, 'enabled', true);\n    /**\r\n     * The correction argument is an optional Number that specifies the time correction factor to apply to the update.\r\n     * This can help improve the accuracy of the simulation in cases where delta is changing between updates.\r\n     * The value of correction is defined as delta / lastDelta, i.e. the percentage change of delta over the last step.\r\n     * Therefore the value is always 1 (no correction) when delta constant (or when no correction is desired, which is the default).\r\n     * See the paper on Time Corrected Verlet for more information.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#correction\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.4.0\r\n     */\n\n    this.correction = GetValue(config, 'correction', 1);\n    /**\r\n     * This function is called every time the core game loop steps, which is bound to the\r\n     * Request Animation Frame frequency unless otherwise modified.\r\n     * \r\n     * The function is passed two values: `time` and `delta`, both of which come from the game step values.\r\n     * \r\n     * It must return a number. This number is used as the delta value passed to Matter.Engine.update.\r\n     * \r\n     * You can override this function with your own to define your own timestep.\r\n     * \r\n     * If you need to update the Engine multiple times in a single game step then call\r\n     * `World.update` as many times as required. Each call will trigger the `getDelta` function.\r\n     * If you wish to have full control over when the Engine updates then see the property `autoUpdate`.\r\n     *\r\n     * You can also adjust the number of iterations that Engine.update performs.\r\n     * Use the Scene Matter Physics config object to set the following properties:\r\n     *\r\n     * positionIterations (defaults to 6)\r\n     * velocityIterations (defaults to 4)\r\n     * constraintIterations (defaults to 2)\r\n     *\r\n     * Adjusting these values can help performance in certain situations, depending on the physics requirements\r\n     * of your game.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#getDelta\r\n     * @type {function}\r\n     * @since 3.4.0\r\n     */\n\n    this.getDelta = GetValue(config, 'getDelta', this.update60Hz);\n    /**\r\n     * Automatically call Engine.update every time the game steps.\r\n     * If you disable this then you are responsible for calling `World.step` directly from your game.\r\n     * If you call `set60Hz` or `set30Hz` then `autoUpdate` is reset to `true`.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#autoUpdate\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.4.0\r\n     */\n\n    this.autoUpdate = GetValue(config, 'autoUpdate', true);\n    /**\r\n     * A flag that controls if the debug graphics will be drawn to or not.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#drawDebug\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.drawDebug = GetValue(config, 'debug', false);\n    /**\r\n     * An instance of the Graphics object the debug bodies are drawn to, if enabled.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#debugGraphic\r\n     * @type {Phaser.GameObjects.Graphics}\r\n     * @since 3.0.0\r\n     */\n\n    this.debugGraphic;\n    /**\r\n     * The default configuration values.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#defaults\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.defaults = {\n      debugShowBody: GetFastValue(config, 'debugShowBody', true),\n      debugShowStaticBody: GetFastValue(config, 'debugShowStaticBody', true),\n      debugShowVelocity: GetFastValue(config, 'debugShowVelocity', true),\n      bodyDebugColor: GetFastValue(config, 'debugBodyColor', 0xff00ff),\n      bodyDebugFillColor: GetFastValue(config, 'bodyDebugFillColor', 0xe3a7e3),\n      staticBodyDebugColor: GetFastValue(config, 'debugBodyColor', 0x0000ff),\n      velocityDebugColor: GetFastValue(config, 'debugVelocityColor', 0x00ff00),\n      debugShowJoint: GetFastValue(config, 'debugShowJoint', true),\n      jointDebugColor: GetFastValue(config, 'debugJointColor', 0x000000),\n      debugWireframes: GetFastValue(config, 'debugWireframes', true),\n      debugShowInternalEdges: GetFastValue(config, 'debugShowInternalEdges', false),\n      debugShowConvexHulls: GetFastValue(config, 'debugShowConvexHulls', false),\n      debugConvexHullColor: GetFastValue(config, 'debugConvexHullColor', 0xaaaaaa),\n      debugShowSleeping: GetFastValue(config, 'debugShowSleeping', false)\n    };\n\n    if (this.drawDebug) {\n      this.createDebugGraphic();\n    }\n\n    this.setEventsProxy();\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Matter.World#setEventsProxy\r\n   * @since 3.0.0\r\n   */\n  setEventsProxy: function setEventsProxy() {\n    var _this = this;\n\n    var engine = this.engine;\n    MatterEvents.on(engine, 'beforeUpdate', function (event) {\n      _this.emit(Events.BEFORE_UPDATE, event);\n    });\n    MatterEvents.on(engine, 'afterUpdate', function (event) {\n      _this.emit(Events.AFTER_UPDATE, event);\n    });\n    MatterEvents.on(engine, 'collisionStart', function (event) {\n      var pairs = event.pairs;\n      var bodyA;\n      var bodyB;\n\n      if (pairs.length > 0) {\n        bodyA = pairs[0].bodyA;\n        bodyB = pairs[0].bodyB;\n      }\n\n      _this.emit(Events.COLLISION_START, event, bodyA, bodyB);\n    });\n    MatterEvents.on(engine, 'collisionActive', function (event) {\n      var pairs = event.pairs;\n      var bodyA;\n      var bodyB;\n\n      if (pairs.length > 0) {\n        bodyA = pairs[0].bodyA;\n        bodyB = pairs[0].bodyB;\n      }\n\n      _this.emit(Events.COLLISION_ACTIVE, event, bodyA, bodyB);\n    });\n    MatterEvents.on(engine, 'collisionEnd', function (event) {\n      var pairs = event.pairs;\n      var bodyA;\n      var bodyB;\n\n      if (pairs.length > 0) {\n        bodyA = pairs[0].bodyA;\n        bodyB = pairs[0].bodyB;\n      }\n\n      _this.emit(Events.COLLISION_END, event, bodyA, bodyB);\n    });\n  },\n\n  /**\r\n   * Sets the bounds of the Physics world to match the given world pixel dimensions.\r\n   * You can optionally set which 'walls' to create: left, right, top or bottom.\r\n   * If none of the walls are given it will default to use the walls settings it had previously.\r\n   * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size\r\n   * the newly created bounds will also not have the left and right walls.\r\n   * Explicitly state them in the parameters to override this.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#setBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [x=0] - The x coordinate of the top-left corner of the bounds.\r\n   * @param {number} [y=0] - The y coordinate of the top-left corner of the bounds.\r\n   * @param {number} [width] - The width of the bounds.\r\n   * @param {number} [height] - The height of the bounds.\r\n   * @param {number} [thickness=128] - The thickness of each wall, in pixels.\r\n   * @param {boolean} [left=true] - If true will create the left bounds wall.\r\n   * @param {boolean} [right=true] - If true will create the right bounds wall.\r\n   * @param {boolean} [top=true] - If true will create the top bounds wall.\r\n   * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.\r\n   *\r\n   * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n   */\n  setBounds: function setBounds(x, y, width, height, thickness, left, right, top, bottom) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = this.scene.sys.scale.width;\n    }\n\n    if (height === undefined) {\n      height = this.scene.sys.scale.height;\n    }\n\n    if (thickness === undefined) {\n      thickness = 128;\n    }\n\n    if (left === undefined) {\n      left = true;\n    }\n\n    if (right === undefined) {\n      right = true;\n    }\n\n    if (top === undefined) {\n      top = true;\n    }\n\n    if (bottom === undefined) {\n      bottom = true;\n    }\n\n    this.updateWall(left, 'left', x - thickness, y - thickness, thickness, height + thickness * 2);\n    this.updateWall(right, 'right', x + width, y - thickness, thickness, height + thickness * 2);\n    this.updateWall(top, 'top', x, y - thickness, width, thickness);\n    this.updateWall(bottom, 'bottom', x, y + height, width, thickness);\n    return this;\n  },\n  //  position = 'left', 'right', 'top' or 'bottom'\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Matter.World#updateWall\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} add - [description]\r\n   * @param {string} position - [description]\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   * @param {number} width - [description]\r\n   * @param {number} height - [description]\r\n   */\n  updateWall: function updateWall(add, position, x, y, width, height) {\n    var wall = this.walls[position];\n\n    if (add) {\n      if (wall) {\n        MatterWorld.remove(this.localWorld, wall);\n      } //  adjust center\n\n\n      x += width / 2;\n      y += height / 2;\n      this.walls[position] = this.create(x, y, width, height, {\n        isStatic: true,\n        friction: 0,\n        frictionStatic: 0\n      });\n    } else {\n      if (wall) {\n        MatterWorld.remove(this.localWorld, wall);\n      }\n\n      this.walls[position] = null;\n    }\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Matter.World#createDebugGraphic\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.GameObjects.Graphics} [description]\r\n   */\n  createDebugGraphic: function createDebugGraphic() {\n    var graphic = this.scene.sys.add.graphics({\n      x: 0,\n      y: 0\n    });\n    graphic.setDepth(Number.MAX_VALUE);\n    this.debugGraphic = graphic;\n    this.drawDebug = true;\n    return graphic;\n  },\n\n  /**\r\n   * Sets the world's gravity and gravity scale to 0.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#disableGravity\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n   */\n  disableGravity: function disableGravity() {\n    this.localWorld.gravity.x = 0;\n    this.localWorld.gravity.y = 0;\n    this.localWorld.gravity.scale = 0;\n    return this;\n  },\n\n  /**\r\n   * Sets the world's gravity\r\n   *\r\n   * @method Phaser.Physics.Matter.World#setGravity\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [x=0] - The world gravity x component.\r\n   * @param {number} [y=1] - The world gravity y component.\r\n   * @param {number} [scale] - [description]\r\n   *\r\n   * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n   */\n  setGravity: function setGravity(x, y, scale) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 1;\n    }\n\n    this.localWorld.gravity.x = x;\n    this.localWorld.gravity.y = y;\n\n    if (scale !== undefined) {\n      this.localWorld.gravity.scale = scale;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Creates a rectangle Matter body and adds it to the world.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#create\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal position of the body in the world.\r\n   * @param {number} y - The vertical position of the body in the world.\r\n   * @param {number} width - The width of the body.\r\n   * @param {number} height - The height of the body.\r\n   * @param {object} options - Optional Matter configuration object.\r\n   *\r\n   * @return {MatterJS.Body} The Matter.js body that was created.\r\n   */\n  create: function create(x, y, width, height, options) {\n    var body = Bodies.rectangle(x, y, width, height, options);\n    MatterWorld.add(this.localWorld, body);\n    return body;\n  },\n\n  /**\r\n   * Adds an object to the world.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#add\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(object|object[])} object - Can be single or an array, and can be a body, composite or constraint\r\n   *\r\n   * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n   */\n  add: function add(object) {\n    MatterWorld.add(this.localWorld, object);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Matter.World#remove\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} object - The object to be removed from the world.\r\n   * @param {boolean} deep - [description]\r\n   *\r\n   * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n   */\n  remove: function remove(object, deep) {\n    var body = object.body ? object.body : object;\n    Composite.remove(this.localWorld, body, deep);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Matter.World#removeConstraint\r\n   * @since 3.0.0\r\n   *\r\n   * @param {MatterJS.Constraint} constraint - [description]\r\n   * @param {boolean} deep - [description]\r\n   *\r\n   * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n   */\n  removeConstraint: function removeConstraint(constraint, deep) {\n    Composite.remove(this.localWorld, constraint, deep);\n    return this;\n  },\n\n  /**\r\n   * Adds MatterTileBody instances for all the colliding tiles within the given tilemap layer. Set\r\n   * the appropriate tiles in your layer to collide before calling this method!\r\n   *\r\n   * @method Phaser.Physics.Matter.World#convertTilemapLayer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer -\r\n   * An array of tiles.\r\n   * @param {object} [options] - Options to be passed to the MatterTileBody constructor. {@ee Phaser.Physics.Matter.TileBody}\r\n   *\r\n   * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n   */\n  convertTilemapLayer: function convertTilemapLayer(tilemapLayer, options) {\n    var layerData = tilemapLayer.layer;\n    var tiles = tilemapLayer.getTilesWithin(0, 0, layerData.width, layerData.height, {\n      isColliding: true\n    });\n    this.convertTiles(tiles, options);\n    return this;\n  },\n\n  /**\r\n   * Adds MatterTileBody instances for the given tiles. This adds bodies regardless of whether the\r\n   * tiles are set to collide or not.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#convertTiles\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Tilemaps.Tile[]} tiles - An array of tiles.\r\n   * @param {object} [options] - Options to be passed to the MatterTileBody constructor. {@see Phaser.Physics.Matter.TileBody}\r\n   *\r\n   * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n   */\n  convertTiles: function convertTiles(tiles, options) {\n    if (tiles.length === 0) {\n      return this;\n    }\n\n    for (var i = 0; i < tiles.length; i++) {\n      new MatterTileBody(this, tiles[i], options);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Matter.World#nextGroup\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} isNonColliding - [description]\r\n   *\r\n   * @return {number} [description]\r\n   */\n  nextGroup: function nextGroup(isNonColliding) {\n    return MatterBody.nextGroup(isNonColliding);\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Matter.World#nextCategory\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} Returns the next unique category bitfield.\r\n   */\n  nextCategory: function nextCategory() {\n    return MatterBody.nextCategory();\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Matter.World#pause\r\n   * @fires Phaser.Physics.Matter.Events#PAUSE\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n   */\n  pause: function pause() {\n    this.enabled = false;\n    this.emit(Events.PAUSE);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Matter.World#resume\r\n   * @fires Phaser.Physics.Matter.Events#RESUME\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n   */\n  resume: function resume() {\n    this.enabled = true;\n    this.emit(Events.RESUME);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Matter.World#update\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n   * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n   */\n  update: function update(time, delta) {\n    if (this.enabled && this.autoUpdate) {\n      Engine.update(this.engine, this.getDelta(time, delta), this.correction);\n    }\n  },\n\n  /**\r\n   * Manually advances the physics simulation by one iteration.\r\n   * \r\n   * You can optionally pass in the `delta` and `correction` values to be used by Engine.update.\r\n   * If undefined they use the Matter defaults of 60Hz and no correction.\r\n   * \r\n   * Calling `step` directly bypasses any checks of `enabled` or `autoUpdate`.\r\n   * \r\n   * It also ignores any custom `getDelta` functions, as you should be passing the delta\r\n   * value in to this call.\r\n   *\r\n   * You can adjust the number of iterations that Engine.update performs internally.\r\n   * Use the Scene Matter Physics config object to set the following properties:\r\n   *\r\n   * positionIterations (defaults to 6)\r\n   * velocityIterations (defaults to 4)\r\n   * constraintIterations (defaults to 2)\r\n   *\r\n   * Adjusting these values can help performance in certain situations, depending on the physics requirements\r\n   * of your game.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#step\r\n   * @since 3.4.0\r\n   *\r\n   * @param {number} [delta=16.666] - [description]\r\n   * @param {number} [correction=1] - [description]\r\n   */\n  step: function step(delta, correction) {\n    Engine.update(this.engine, delta, correction);\n  },\n\n  /**\r\n   * Runs the Matter Engine.update at a fixed timestep of 60Hz.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#update60Hz\r\n   * @since 3.4.0\r\n   *\r\n   * @return {number} The delta value to be passed to Engine.update.\r\n   */\n  update60Hz: function update60Hz() {\n    return 1000 / 60;\n  },\n\n  /**\r\n   * Runs the Matter Engine.update at a fixed timestep of 30Hz.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#update30Hz\r\n   * @since 3.4.0\r\n   *\r\n   * @return {number} The delta value to be passed to Engine.update.\r\n   */\n  update30Hz: function update30Hz() {\n    return 1000 / 30;\n  },\n\n  /**\r\n   * Handles the rendering of bodies and debug information to the debug Graphics object, if enabled.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#postUpdate\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  postUpdate: function postUpdate() {\n    if (!this.drawDebug) {\n      return;\n    }\n\n    this.debugGraphic.clear();\n    var bodies = Composite.allBodies(this.localWorld);\n\n    if (this.defaults.debugWireframes) {\n      if (this.defaults.debugShowConvexHulls) {\n        this.renderConvexHulls(bodies);\n      }\n\n      this.renderWireframes(bodies);\n    } else {\n      this.renderBodies(bodies);\n    }\n\n    if (this.defaults.debugShowJoint) {\n      this.renderJoints();\n    }\n  },\n\n  /**\r\n   * Renders the debug convex hulls from the given array of bodies.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#renderConvexHulls\r\n   * @private\r\n   * @since 3.14.0\r\n   * \r\n   * @param {array} bodies - An array of bodies from the localWorld.\r\n   */\n  renderConvexHulls: function renderConvexHulls(bodies) {\n    var graphics = this.debugGraphic;\n    graphics.lineStyle(1, this.defaults.debugConvexHullColor);\n    graphics.beginPath();\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i];\n\n      if (!body.render.visible || body.parts.length === 1) {\n        continue;\n      }\n\n      graphics.moveTo(body.vertices[0].x, body.vertices[0].y);\n\n      for (var j = 1; j < body.vertices.length; j++) {\n        graphics.lineTo(body.vertices[j].x, body.vertices[j].y);\n      }\n\n      graphics.lineTo(body.vertices[0].x, body.vertices[0].y);\n    }\n\n    graphics.strokePath();\n  },\n\n  /**\r\n   * Renders the wireframes of the given array of bodies.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#renderWireframes\r\n   * @private\r\n   * @since 3.14.0\r\n   * \r\n   * @param {array} bodies - An array of bodies from the localWorld.\r\n   */\n  renderWireframes: function renderWireframes(bodies) {\n    var graphics = this.debugGraphic;\n    var showInternalEdges = this.defaults.debugShowInternalEdges;\n    graphics.lineStyle(1, this.defaults.bodyDebugColor);\n    graphics.beginPath();\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i];\n\n      if (!body.render.visible) {\n        continue;\n      }\n\n      for (var k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n        var part = body.parts[k];\n        var vertLength = part.vertices.length;\n        graphics.moveTo(part.vertices[0].x, part.vertices[0].y);\n\n        for (var j = 1; j < vertLength; j++) {\n          if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n            graphics.lineTo(part.vertices[j].x, part.vertices[j].y);\n          } else {\n            graphics.moveTo(part.vertices[j].x, part.vertices[j].y);\n          }\n\n          if (part.vertices[j].isInternal && !showInternalEdges) {\n            graphics.moveTo(part.vertices[(j + 1) % vertLength].x, part.vertices[(j + 1) % vertLength].y);\n          }\n        }\n\n        graphics.lineTo(part.vertices[0].x, part.vertices[0].y);\n      }\n    }\n\n    graphics.strokePath();\n  },\n\n  /**\r\n   * Renders the array of bodies.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#renderBodies\r\n   * @private\r\n   * @since 3.14.0\r\n   * \r\n   * @param {array} bodies - An array of bodies from the localWorld.\r\n   */\n  renderBodies: function renderBodies(bodies) {\n    var graphics = this.debugGraphic;\n    var showInternalEdges = this.defaults.debugShowInternalEdges || !this.defaults.debugWireframes;\n    var showSleeping = this.defaults.debugShowSleeping;\n    var wireframes = this.defaults.debugWireframes;\n    var body;\n    var part;\n    var i;\n    var k;\n\n    for (i = 0; i < bodies.length; i++) {\n      body = bodies[i];\n\n      if (!body.render.visible) {\n        continue;\n      } //  Handle compound parts\n\n\n      for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n        part = body.parts[k];\n\n        if (!part.render.visible) {\n          continue;\n        }\n\n        if (showSleeping && body.isSleeping) {\n          graphics.lineStyle(1, this.defaults.bodyDebugColor, 0.5 * part.render.opacity);\n          graphics.fillStyle(this.defaults.bodyDebugColor, 0.5 * part.render.opacity);\n        } else {\n          graphics.lineStyle(1, this.defaults.bodyDebugColor, part.render.opacity);\n          graphics.fillStyle(this.defaults.bodyDebugColor, part.render.opacity);\n        } //  Part polygon\n\n\n        if (part.circleRadius) {\n          graphics.beginPath();\n          graphics.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);\n        } else {\n          graphics.beginPath();\n          graphics.moveTo(part.vertices[0].x, part.vertices[0].y);\n          var vertLength = part.vertices.length;\n\n          for (var j = 1; j < vertLength; j++) {\n            if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n              graphics.lineTo(part.vertices[j].x, part.vertices[j].y);\n            } else {\n              graphics.moveTo(part.vertices[j].x, part.vertices[j].y);\n            }\n\n            if (part.vertices[j].isInternal && !showInternalEdges) {\n              graphics.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\n            }\n          }\n\n          graphics.lineTo(part.vertices[0].x, part.vertices[0].y);\n          graphics.closePath();\n        }\n\n        if (!wireframes) {\n          graphics.fillPath();\n        } else {\n          graphics.strokePath();\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Renders world constraints.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#renderJoints\r\n   * @private\r\n   * @since 3.14.0\r\n   */\n  renderJoints: function renderJoints() {\n    var graphics = this.debugGraphic;\n    graphics.lineStyle(2, this.defaults.jointDebugColor); // Render constraints \n\n    var constraints = Composite.allConstraints(this.localWorld);\n\n    for (var i = 0; i < constraints.length; i++) {\n      var constraint = constraints[i];\n\n      if (!constraint.render.visible || !constraint.pointA || !constraint.pointB) {\n        continue;\n      }\n\n      if (constraint.render.lineWidth) {\n        graphics.lineStyle(constraint.render.lineWidth, Common.colorToNumber(constraint.render.strokeStyle));\n      }\n\n      var bodyA = constraint.bodyA;\n      var bodyB = constraint.bodyB;\n      var start;\n      var end;\n\n      if (bodyA) {\n        start = Vector.add(bodyA.position, constraint.pointA);\n      } else {\n        start = constraint.pointA;\n      }\n\n      if (constraint.render.type === 'pin') {\n        graphics.beginPath();\n        graphics.arc(start.x, start.y, 3, 0, 2 * Math.PI);\n        graphics.closePath();\n      } else {\n        if (bodyB) {\n          end = Vector.add(bodyB.position, constraint.pointB);\n        } else {\n          end = constraint.pointB;\n        }\n\n        graphics.beginPath();\n        graphics.moveTo(start.x, start.y);\n\n        if (constraint.render.type === 'spring') {\n          var delta = Vector.sub(end, start);\n          var normal = Vector.perp(Vector.normalise(delta));\n          var coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20));\n          var offset;\n\n          for (var j = 1; j < coils; j += 1) {\n            offset = j % 2 === 0 ? 1 : -1;\n            graphics.lineTo(start.x + delta.x * (j / coils) + normal.x * offset * 4, start.y + delta.y * (j / coils) + normal.y * offset * 4);\n          }\n        }\n\n        graphics.lineTo(end.x, end.y);\n      }\n\n      if (constraint.render.lineWidth) {\n        graphics.strokePath();\n      }\n\n      if (constraint.render.anchors) {\n        graphics.fillStyle(Common.colorToNumber(constraint.render.strokeStyle));\n        graphics.beginPath();\n        graphics.arc(start.x, start.y, 6, 0, 2 * Math.PI);\n        graphics.arc(end.x, end.y, 6, 0, 2 * Math.PI);\n        graphics.closePath();\n        graphics.fillPath();\n      }\n    }\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Matter.World#fromPath\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} path - [description]\r\n   * @param {array} points - [description]\r\n   *\r\n   * @return {array} [description]\r\n   */\n  fromPath: function fromPath(path, points) {\n    if (points === undefined) {\n      points = [];\n    } // var pathPattern = /L?\\s*([-\\d.e]+)[\\s,]*([-\\d.e]+)*/ig;\n    // eslint-disable-next-line no-useless-escape\n\n\n    var pathPattern = /L?\\s*([\\-\\d\\.e]+)[\\s,]*([\\-\\d\\.e]+)*/ig;\n    path.replace(pathPattern, function (match, x, y) {\n      points.push({\n        x: parseFloat(x),\n        y: parseFloat(y)\n      });\n    });\n    return points;\n  },\n\n  /**\r\n   * Will remove all Matter physics event listeners and clear the matter physics world,\r\n   * engine and any debug graphics, if any.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#shutdown\r\n   * @since 3.0.0\r\n   */\n  shutdown: function shutdown() {\n    MatterEvents.off(this.engine);\n    this.removeAllListeners();\n    MatterWorld.clear(this.localWorld, false);\n    Engine.clear(this.engine);\n\n    if (this.drawDebug) {\n      this.debugGraphic.destroy();\n    }\n  },\n\n  /**\r\n   * Will remove all Matter physics event listeners and clear the matter physics world,\r\n   * engine and any debug graphics, if any.\r\n   *\r\n   * After destroying the world it cannot be re-used again.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    this.shutdown();\n  }\n});\nmodule.exports = World;","map":null,"metadata":{},"sourceType":"script"}