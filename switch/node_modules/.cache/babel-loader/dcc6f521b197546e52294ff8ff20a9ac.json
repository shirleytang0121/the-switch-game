{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\n//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\nvar Class = require('../utils/Class');\n\nvar Curve = require('./Curve');\n\nvar DegToRad = require('../math/DegToRad');\n\nvar GetValue = require('../utils/object/GetValue');\n\nvar RadToDeg = require('../math/RadToDeg');\n\nvar Vector2 = require('../math/Vector2');\n/**\r\n * @typedef {object} JSONEllipseCurve\r\n *\r\n * @property {string} type - The of the curve.\r\n * @property {number} x - The x coordinate of the ellipse.\r\n * @property {number} y - The y coordinate of the ellipse.\r\n * @property {number} xRadius - The horizontal radius of ellipse.\r\n * @property {number} yRadius - The vertical radius of ellipse.\r\n * @property {integer} startAngle - The start angle of the ellipse, in degrees.\r\n * @property {integer} endAngle - The end angle of the ellipse, in degrees.\r\n * @property {boolean} clockwise - Sets if the the ellipse rotation is clockwise (true) or anti-clockwise (false)\r\n * @property {integer} rotation - The rotation of ellipse, in degrees.\r\n */\n\n/**\r\n * @typedef {object} EllipseCurveConfig\r\n *\r\n * @property {number} [x=0] - The x coordinate of the ellipse.\r\n * @property {number} [y=0] - The y coordinate of the ellipse.\r\n * @property {number} [xRadius=0] - The horizontal radius of the ellipse.\r\n * @property {number} [yRadius=0] - The vertical radius of the ellipse.\r\n * @property {integer} [startAngle=0] - The start angle of the ellipse, in degrees.\r\n * @property {integer} [endAngle=360] - The end angle of the ellipse, in degrees.\r\n * @property {boolean} [clockwise=false] - Sets if the the ellipse rotation is clockwise (true) or anti-clockwise (false)\r\n * @property {integer} [rotation=0] - The rotation of the ellipse, in degrees.\r\n  */\n\n/**\r\n * @classdesc\r\n * An Elliptical Curve derived from the Base Curve class.\r\n * \r\n * See https://en.wikipedia.org/wiki/Elliptic_curve for more details.\r\n *\r\n * @class Ellipse\r\n * @extends Phaser.Curves.Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(number|EllipseCurveConfig)} [x=0] - The x coordinate of the ellipse, or an Ellipse Curve configuration object.\r\n * @param {number} [y=0] - The y coordinate of the ellipse.\r\n * @param {number} [xRadius=0] - The horizontal radius of ellipse.\r\n * @param {number} [yRadius=0] - The vertical radius of ellipse.\r\n * @param {integer} [startAngle=0] - The start angle of the ellipse, in degrees.\r\n * @param {integer} [endAngle=360] - The end angle of the ellipse, in degrees.\r\n * @param {boolean} [clockwise=false] - Sets if the the ellipse rotation is clockwise (true) or anti-clockwise (false)\r\n * @param {integer} [rotation=0] - The rotation of the ellipse, in degrees.\r\n */\n\n\nvar EllipseCurve = new Class({\n  Extends: Curve,\n  initialize: function EllipseCurve(x, y, xRadius, yRadius, startAngle, endAngle, clockwise, rotation) {\n    if (typeof x === 'object') {\n      var config = x;\n      x = GetValue(config, 'x', 0);\n      y = GetValue(config, 'y', 0);\n      xRadius = GetValue(config, 'xRadius', 0);\n      yRadius = GetValue(config, 'yRadius', xRadius);\n      startAngle = GetValue(config, 'startAngle', 0);\n      endAngle = GetValue(config, 'endAngle', 360);\n      clockwise = GetValue(config, 'clockwise', false);\n      rotation = GetValue(config, 'rotation', 0);\n    } else {\n      if (yRadius === undefined) {\n        yRadius = xRadius;\n      }\n\n      if (startAngle === undefined) {\n        startAngle = 0;\n      }\n\n      if (endAngle === undefined) {\n        endAngle = 360;\n      }\n\n      if (clockwise === undefined) {\n        clockwise = false;\n      }\n\n      if (rotation === undefined) {\n        rotation = 0;\n      }\n    }\n\n    Curve.call(this, 'EllipseCurve'); //  Center point\n\n    /**\r\n     * The center point of the ellipse. Used for calculating rotation.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#p0\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.p0 = new Vector2(x, y);\n    /**\r\n     * The horizontal radius of the ellipse.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#_xRadius\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._xRadius = xRadius;\n    /**\r\n     * The vertical radius of the ellipse.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#_yRadius\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._yRadius = yRadius; //  Radians\n\n    /**\r\n     * The starting angle of the ellipse in radians.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#_startAngle\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._startAngle = DegToRad(startAngle);\n    /**\r\n     * The end angle of the ellipse in radians.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#_endAngle\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._endAngle = DegToRad(endAngle);\n    /**\r\n     * Anti-clockwise direction.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#_clockwise\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._clockwise = clockwise;\n    /**\r\n     * The rotation of the arc.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#_rotation\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._rotation = DegToRad(rotation);\n  },\n\n  /**\r\n   * Gets the starting point on the curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#getStartPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n   */\n  getStartPoint: function getStartPoint(out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    return this.getPoint(0, out);\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Ellipse#getResolution\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} divisions - [description]\r\n   *\r\n   * @return {number} [description]\r\n   */\n  getResolution: function getResolution(divisions) {\n    return divisions * 2;\n  },\n\n  /**\r\n   * Get point at relative position in curve according to length.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#getPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n   * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n   */\n  getPoint: function getPoint(t, out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    var twoPi = Math.PI * 2;\n    var deltaAngle = this._endAngle - this._startAngle;\n    var samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI\n\n    while (deltaAngle < 0) {\n      deltaAngle += twoPi;\n    }\n\n    while (deltaAngle > twoPi) {\n      deltaAngle -= twoPi;\n    }\n\n    if (deltaAngle < Number.EPSILON) {\n      if (samePoints) {\n        deltaAngle = 0;\n      } else {\n        deltaAngle = twoPi;\n      }\n    }\n\n    if (this._clockwise && !samePoints) {\n      if (deltaAngle === twoPi) {\n        deltaAngle = -twoPi;\n      } else {\n        deltaAngle = deltaAngle - twoPi;\n      }\n    }\n\n    var angle = this._startAngle + t * deltaAngle;\n    var x = this.p0.x + this._xRadius * Math.cos(angle);\n    var y = this.p0.y + this._yRadius * Math.sin(angle);\n\n    if (this._rotation !== 0) {\n      var cos = Math.cos(this._rotation);\n      var sin = Math.sin(this._rotation);\n      var tx = x - this.p0.x;\n      var ty = y - this.p0.y; // Rotate the point about the center of the ellipse.\n\n      x = tx * cos - ty * sin + this.p0.x;\n      y = tx * sin + ty * cos + this.p0.y;\n    }\n\n    return out.set(x, y);\n  },\n\n  /**\r\n   * Sets the horizontal radius of this curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setXRadius\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The horizontal radius of this curve.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setXRadius: function setXRadius(value) {\n    this.xRadius = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the vertical radius of this curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setYRadius\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The vertical radius of this curve.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setYRadius: function setYRadius(value) {\n    this.yRadius = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the width of this curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setWidth\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The width of this curve.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setWidth: function setWidth(value) {\n    this.xRadius = value * 2;\n    return this;\n  },\n\n  /**\r\n   * Sets the height of this curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setHeight\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The height of this curve.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setHeight: function setHeight(value) {\n    this.yRadius = value * 2;\n    return this;\n  },\n\n  /**\r\n   * Sets the start angle of this curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setStartAngle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The start angle of this curve, in radians.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setStartAngle: function setStartAngle(value) {\n    this.startAngle = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the end angle of this curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setEndAngle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The end angle of this curve, in radians.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setEndAngle: function setEndAngle(value) {\n    this.endAngle = value;\n    return this;\n  },\n\n  /**\r\n   * Sets if this curve extends clockwise or anti-clockwise.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setClockwise\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - The clockwise state of this curve.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setClockwise: function setClockwise(value) {\n    this.clockwise = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the rotation of this curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setRotation\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The rotation of this curve, in radians.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setRotation: function setRotation(value) {\n    this.rotation = value;\n    return this;\n  },\n\n  /**\r\n   * The x coordinate of the center of the ellipse.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#x\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  x: {\n    get: function get() {\n      return this.p0.x;\n    },\n    set: function set(value) {\n      this.p0.x = value;\n    }\n  },\n\n  /**\r\n   * The y coordinate of the center of the ellipse.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#y\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  y: {\n    get: function get() {\n      return this.p0.y;\n    },\n    set: function set(value) {\n      this.p0.y = value;\n    }\n  },\n\n  /**\r\n   * The horizontal radius of the ellipse.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#xRadius\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  xRadius: {\n    get: function get() {\n      return this._xRadius;\n    },\n    set: function set(value) {\n      this._xRadius = value;\n    }\n  },\n\n  /**\r\n   * The vertical radius of the ellipse.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#yRadius\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  yRadius: {\n    get: function get() {\n      return this._yRadius;\n    },\n    set: function set(value) {\n      this._yRadius = value;\n    }\n  },\n\n  /**\r\n   * The start angle of the ellipse in degrees.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#startAngle\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  startAngle: {\n    get: function get() {\n      return RadToDeg(this._startAngle);\n    },\n    set: function set(value) {\n      this._startAngle = DegToRad(value);\n    }\n  },\n\n  /**\r\n   * The end angle of the ellipse in degrees.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#endAngle\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  endAngle: {\n    get: function get() {\n      return RadToDeg(this._endAngle);\n    },\n    set: function set(value) {\n      this._endAngle = DegToRad(value);\n    }\n  },\n\n  /**\r\n   * `true` if the ellipse rotation is clockwise or `false` if anti-clockwise.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#clockwise\r\n   * @type {boolean}\r\n   * @since 3.0.0\r\n   */\n  clockwise: {\n    get: function get() {\n      return this._clockwise;\n    },\n    set: function set(value) {\n      this._clockwise = value;\n    }\n  },\n\n  /**\r\n   * The rotation of the ellipse, relative to the center, in degrees.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#angle\r\n   * @type {number}\r\n   * @since 3.14.0\r\n   */\n  angle: {\n    get: function get() {\n      return RadToDeg(this._rotation);\n    },\n    set: function set(value) {\n      this._rotation = DegToRad(value);\n    }\n  },\n\n  /**\r\n   * The rotation of the ellipse, relative to the center, in radians.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#rotation\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  rotation: {\n    get: function get() {\n      return this._rotation;\n    },\n    set: function set(value) {\n      this._rotation = value;\n    }\n  },\n\n  /**\r\n   * JSON serialization of the curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#toJSON\r\n   * @since 3.0.0\r\n   *\r\n   * @return {JSONEllipseCurve} The JSON object containing this curve data.\r\n   */\n  toJSON: function toJSON() {\n    return {\n      type: this.type,\n      x: this.p0.x,\n      y: this.p0.y,\n      xRadius: this._xRadius,\n      yRadius: this._yRadius,\n      startAngle: RadToDeg(this._startAngle),\n      endAngle: RadToDeg(this._endAngle),\n      clockwise: this._clockwise,\n      rotation: RadToDeg(this._rotation)\n    };\n  }\n});\n/**\r\n * Creates a curve from the provided Ellipse Curve Configuration object.\r\n *\r\n * @function Phaser.Curves.Ellipse.fromJSON\r\n * @since 3.0.0\r\n *\r\n * @param {JSONEllipseCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.Ellipse} The ellipse curve constructed from the configuration object.\r\n */\n\nEllipseCurve.fromJSON = function (data) {\n  return new EllipseCurve(data);\n};\n\nmodule.exports = EllipseCurve;","map":null,"metadata":{},"sourceType":"script"}