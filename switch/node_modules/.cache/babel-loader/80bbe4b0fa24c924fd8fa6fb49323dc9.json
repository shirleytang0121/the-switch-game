{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Bounds = require('./lib/geometry/Bounds');\n\nvar Class = require('../../utils/Class');\n\nvar Composite = require('./lib/body/Composite');\n\nvar Constraint = require('./lib/constraint/Constraint');\n\nvar Detector = require('./lib/collision/Detector');\n\nvar Events = require('./events');\n\nvar InputEvents = require('../../input/events');\n\nvar Merge = require('../../utils/object/Merge');\n\nvar Sleeping = require('./lib/core/Sleeping');\n\nvar Vector2 = require('../../math/Vector2');\n\nvar Vertices = require('./lib/geometry/Vertices');\n/**\r\n * @classdesc\r\n * A Pointer Constraint is a special type of constraint that allows you to click\r\n * and drag bodies in a Matter World. It monitors the active Pointers in a Scene,\r\n * and when one is pressed down it checks to see if that hit any part of any active\r\n * body in the world. If it did, and the body has input enabled, it will begin to\r\n * drag it until either released, or you stop it via the `stopDrag` method.\r\n * \r\n * You can adjust the stiffness, length and other properties of the constraint via\r\n * the `options` object on creation.\r\n *\r\n * @class PointerConstraint\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene to which this Pointer Constraint belongs.\r\n * @param {Phaser.Physics.Matter.World} world - A reference to the Matter World instance to which this Constraint belongs.\r\n * @param {object} [options] - A Constraint configuration object.\r\n */\n\n\nvar PointerConstraint = new Class({\n  initialize: function PointerConstraint(scene, world, options) {\n    if (options === undefined) {\n      options = {};\n    } //  Defaults\n\n\n    var defaults = {\n      label: 'Pointer Constraint',\n      pointA: {\n        x: 0,\n        y: 0\n      },\n      pointB: {\n        x: 0,\n        y: 0\n      },\n      damping: 0,\n      length: 0.01,\n      stiffness: 0.1,\n      angularStiffness: 1,\n      collisionFilter: {\n        category: 0x0001,\n        mask: 0xFFFFFFFF,\n        group: 0\n      }\n    };\n    /**\r\n     * A reference to the Scene to which this Pointer Constraint belongs.\r\n     * This is the same Scene as the Matter World instance.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n\n    this.scene = scene;\n    /**\r\n     * A reference to the Matter World instance to which this Constraint belongs.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#world\r\n     * @type {Phaser.Physics.Matter.World}\r\n     * @since 3.0.0\r\n     */\n\n    this.world = world;\n    /**\r\n     * The Camera the Pointer was interacting with when the input\r\n     * down event was processed.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#camera\r\n     * @type {Phaser.Cameras.Scene2D.Camera}\r\n     * @since 3.0.0\r\n     */\n\n    this.camera = null;\n    /**\r\n     * A reference to the Input Pointer that activated this Constraint.\r\n     * This is set in the `onDown` handler.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#pointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.pointer = null;\n    /**\r\n     * Is this Constraint active or not?\r\n     * \r\n     * An active constraint will be processed each update. An inactive one will be skipped.\r\n     * Use this to toggle a Pointer Constraint on and off.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#active\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.active = true;\n    /**\r\n     * The internal transformed position.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#position\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.position = new Vector2();\n    /**\r\n     * The body that is currently being dragged, if any.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#body\r\n     * @type {?MatterJS.Body}\r\n     * @since 3.16.2\r\n     */\n\n    this.body = null;\n    /**\r\n     * The part of the body that was clicked on to start the drag.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#part\r\n     * @type {?MatterJS.Body}\r\n     * @since 3.16.2\r\n     */\n\n    this.part = null;\n    /**\r\n     * The native Matter Constraint that is used to attach to bodies.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#constraint\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.constraint = Constraint.create(Merge(options, defaults));\n    this.world.on(Events.BEFORE_UPDATE, this.update, this);\n    scene.sys.input.on(InputEvents.POINTER_DOWN, this.onDown, this);\n  },\n\n  /**\r\n   * A Pointer has been pressed down onto the Scene.\r\n   * \r\n   * If this Constraint doesn't have an active Pointer then a hit test is\r\n   * run against all active bodies in the world. If one is found it is bound\r\n   * to this constraint and the drag begins.\r\n   *\r\n   * @method Phaser.Physics.Matter.PointerConstraint#onDown\r\n   * @fires Phaser.Physics.Matter.Events#DRAG_START\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - A reference to the Pointer that was pressed.\r\n   */\n  onDown: function onDown(pointer) {\n    if (!this.pointer) {\n      if (this.getBody(pointer)) {\n        this.pointer = pointer;\n        this.camera = pointer.camera;\n      }\n    }\n  },\n\n  /**\r\n   * Scans all active bodies in the current Matter World to see if any of them\r\n   * are hit by the Pointer. The _first one_ found to hit is set as the active contraint\r\n   * body.\r\n   *\r\n   * @method Phaser.Physics.Matter.PointerConstraint#getBody\r\n   * @since 3.16.2\r\n   * \r\n   * @return {boolean} `true` if a body was found and set, otherwise `false`.\r\n   */\n  getBody: function getBody(pointer) {\n    var pos = this.position;\n    var constraint = this.constraint;\n    pointer.camera.getWorldPoint(pointer.x, pointer.y, pos);\n    var bodies = Composite.allBodies(this.world.localWorld);\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i];\n\n      if (!body.ignorePointer && Bounds.contains(body.bounds, pos) && Detector.canCollide(body.collisionFilter, constraint.collisionFilter)) {\n        if (this.hitTestBody(body, pos)) {\n          this.world.emit(Events.DRAG_START, this.body, this.part, this);\n          return true;\n        }\n      }\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Scans the current body to determine if a part of it was clicked on.\r\n   * If a part is found the body is set as the `constraint.bodyB` property,\r\n   * as well as the `body` property of this class. The part is also set.\r\n   *\r\n   * @method Phaser.Physics.Matter.PointerConstraint#hitTestBody\r\n   * @since 3.16.2\r\n   *\r\n   * @param {MatterJS.Body} body - The Matter Body to check.\r\n   * @param {Phaser.Math.Vector2} position - A translated hit test position.\r\n   *\r\n   * @return {boolean} `true` if a part of the body was hit, otherwise `false`.\r\n   */\n  hitTestBody: function hitTestBody(body, position) {\n    var constraint = this.constraint;\n    var start = body.parts.length > 1 ? 1 : 0;\n\n    for (var i = start; i < body.parts.length; i++) {\n      var part = body.parts[i];\n\n      if (Vertices.contains(part.vertices, position)) {\n        constraint.bodyB = body;\n        constraint.pointA.x = position.x;\n        constraint.pointA.y = position.y;\n        constraint.pointB.x = position.x - body.position.x;\n        constraint.pointB.y = position.y - body.position.y;\n        constraint.angleB = body.angle;\n        Sleeping.set(body, false);\n        this.part = part;\n        this.body = body;\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Internal update handler. Called in the Matter BEFORE_UPDATE step.\r\n   *\r\n   * @method Phaser.Physics.Matter.PointerConstraint#update\r\n   * @fires Phaser.Physics.Matter.Events#DRAG\r\n   * @since 3.0.0\r\n   */\n  update: function update() {\n    var body = this.body;\n    var pointer = this.pointer;\n\n    if (!this.active || !pointer || !body) {\n      return;\n    }\n\n    if (pointer.isDown) {\n      var pos = this.position;\n      var constraint = this.constraint;\n      this.camera.getWorldPoint(pointer.x, pointer.y, pos);\n      Sleeping.set(body, false);\n      constraint.pointA.x = pos.x;\n      constraint.pointA.y = pos.y;\n      this.world.emit(Events.DRAG, body, this);\n    } else {\n      //  Pointer has been released since the last world step\n      this.stopDrag();\n    }\n  },\n\n  /**\r\n   * Stops the Pointer Constraint from dragging the body any further.\r\n   * \r\n   * This is called automatically if the Pointer is released while actively\r\n   * dragging a body. Or, you can call it manually to release a body from a\r\n   * constraint without having to first release the pointer.\r\n   *\r\n   * @method Phaser.Physics.Matter.PointerConstraint#stopDrag\r\n   * @fires Phaser.Physics.Matter.Events#DRAG_END\r\n   * @since 3.16.2\r\n   */\n  stopDrag: function stopDrag() {\n    var body = this.body;\n    var constraint = this.constraint;\n\n    if (body) {\n      this.world.emit(Events.DRAG_END, body, this);\n      this.pointer = null;\n      this.body = null;\n      this.part = null;\n      constraint.bodyB = null;\n    }\n  },\n\n  /**\r\n   * Destroys this Pointer Constraint instance and all of its references.\r\n   *\r\n   * @method Phaser.Physics.Matter.PointerConstraint#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    this.world.removeConstraint(this.constraint);\n    this.pointer = null;\n    this.constraint = null;\n    this.body = null;\n    this.part = null;\n    this.world.off(Events.BEFORE_UPDATE, this.update);\n    this.scene.sys.input.off(InputEvents.POINTER_DOWN, this.onDown, this);\n  }\n});\nmodule.exports = PointerConstraint;","map":null,"metadata":{},"sourceType":"script"}