{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Tile = require('../Tile');\n\nvar IsInLayerBounds = require('./IsInLayerBounds');\n\nvar CalculateFacesAt = require('./CalculateFacesAt');\n\nvar SetTileCollision = require('./SetTileCollision');\n/**\r\n * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n * location. If you pass in an index, only the index at the specified location will be changed.\r\n * Collision information will be recalculated at the specified location.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTileAt\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was created or added to this map.\r\n */\n\n\nvar PutTileAt = function PutTileAt(tile, tileX, tileY, recalculateFaces, layer) {\n  if (!IsInLayerBounds(tileX, tileY, layer)) {\n    return null;\n  }\n\n  if (recalculateFaces === undefined) {\n    recalculateFaces = true;\n  }\n\n  var oldTile = layer.data[tileY][tileX];\n  var oldTileCollides = oldTile && oldTile.collides;\n\n  if (tile instanceof Tile) {\n    if (layer.data[tileY][tileX] === null) {\n      layer.data[tileY][tileX] = new Tile(layer, tile.index, tileX, tileY, tile.width, tile.height);\n    }\n\n    layer.data[tileY][tileX].copy(tile);\n  } else {\n    var index = tile;\n\n    if (layer.data[tileY][tileX] === null) {\n      layer.data[tileY][tileX] = new Tile(layer, index, tileX, tileY, layer.tileWidth, layer.tileHeight);\n    } else {\n      layer.data[tileY][tileX].index = index;\n    }\n  } // Updating colliding flag on the new tile\n\n\n  var newTile = layer.data[tileY][tileX];\n  var collides = layer.collideIndexes.indexOf(newTile.index) !== -1;\n  SetTileCollision(newTile, collides); // Recalculate faces only if the colliding flag at (tileX, tileY) has changed\n\n  if (recalculateFaces && oldTileCollides !== newTile.collides) {\n    CalculateFacesAt(tileX, tileY, layer);\n  }\n\n  return newTile;\n};\n\nmodule.exports = PutTileAt;","map":null,"metadata":{},"sourceType":"script"}