{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar CONST = require('./const');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar GameEvents = require('../core/events');\n\nvar Keyboard = require('./keyboard/KeyboardManager');\n\nvar Mouse = require('./mouse/MouseManager');\n\nvar Pointer = require('./Pointer');\n\nvar Touch = require('./touch/TouchManager');\n\nvar TransformMatrix = require('../gameobjects/components/TransformMatrix');\n\nvar TransformXY = require('../math/TransformXY');\n/**\r\n * @classdesc\r\n * The Input Manager is responsible for handling the pointer related systems in a single Phaser Game instance.\r\n *\r\n * Based on the Game Config it will create handlers for mouse and touch support.\r\n *\r\n * Keyboard and Gamepad are plugins, handled directly by the InputPlugin class.\r\n *\r\n * It then manages the event queue, pointer creation and general hit test related operations.\r\n *\r\n * You rarely need to interact with the Input Manager directly, and as such, all of its properties and methods\r\n * should be considered private. Instead, you should use the Input Plugin, which is a Scene level system, responsible\r\n * for dealing with all input events for a Scene.\r\n *\r\n * @class InputManager\r\n * @memberof Phaser.Input\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Game instance that owns the Input Manager.\r\n * @param {object} config - The Input Configuration object, as set in the Game Config.\r\n */\n\n\nvar InputManager = new Class({\n  initialize: function InputManager(game, config) {\n    /**\r\n     * The Game instance that owns the Input Manager.\r\n     * A Game only maintains on instance of the Input Manager at any time.\r\n     *\r\n     * @name Phaser.Input.InputManager#game\r\n     * @type {Phaser.Game}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\n    this.game = game;\n    /**\r\n     * A reference to the global Game Scale Manager.\r\n     * Used for all bounds checks and pointer scaling.\r\n     *\r\n     * @name Phaser.Input.InputManager#scaleManager\r\n     * @type {Phaser.Scale.ScaleManager}\r\n     * @since 3.16.0\r\n     */\n\n    this.scaleManager;\n    /**\r\n     * The Canvas that is used for all DOM event input listeners.\r\n     *\r\n     * @name Phaser.Input.InputManager#canvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.0.0\r\n     */\n\n    this.canvas;\n    /**\r\n     * The Game Configuration object, as set during the game boot.\r\n     *\r\n     * @name Phaser.Input.InputManager#config\r\n     * @type {Phaser.Core.Config}\r\n     * @since 3.0.0\r\n     */\n\n    this.config = config;\n    /**\r\n     * If set, the Input Manager will run its update loop every frame.\r\n     *\r\n     * @name Phaser.Input.InputManager#enabled\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.enabled = true;\n    /**\r\n     * The Event Emitter instance that the Input Manager uses to emit events from.\r\n     *\r\n     * @name Phaser.Input.InputManager#events\r\n     * @type {Phaser.Events.EventEmitter}\r\n     * @since 3.0.0\r\n     */\n\n    this.events = new EventEmitter();\n    /**\r\n     * A standard FIFO queue for the native DOM events waiting to be handled by the Input Manager.\r\n     *\r\n     * @name Phaser.Input.InputManager#queue\r\n     * @type {array}\r\n     * @default []\r\n     * @deprecated\r\n     * @since 3.0.0\r\n     */\n\n    this.queue = [];\n    /**\r\n     * DOM Callbacks container.\r\n     *\r\n     * @name Phaser.Input.InputManager#domCallbacks\r\n     * @private\r\n     * @type {object}\r\n     * @deprecated\r\n     * @since 3.10.0\r\n     */\n\n    this.domCallbacks = {\n      up: [],\n      down: [],\n      move: [],\n      upOnce: [],\n      downOnce: [],\n      moveOnce: []\n    };\n    /**\r\n     * Are any mouse or touch pointers currently over the game canvas?\r\n     * This is updated automatically by the canvas over and out handlers.\r\n     *\r\n     * @name Phaser.Input.InputManager#isOver\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\n\n    this.isOver = true;\n    /**\r\n     * Are there any up callbacks defined?\r\n     *\r\n     * @name Phaser.Input.InputManager#_hasUpCallback\r\n     * @private\r\n     * @type {boolean}\r\n     * @deprecated\r\n     * @since 3.10.0\r\n     */\n\n    this._hasUpCallback = false;\n    /**\r\n     * Are there any down callbacks defined?\r\n     *\r\n     * @name Phaser.Input.InputManager#_hasDownCallback\r\n     * @private\r\n     * @type {boolean}\r\n     * @deprecated\r\n     * @since 3.10.0\r\n     */\n\n    this._hasDownCallback = false;\n    /**\r\n     * Are there any move callbacks defined?\r\n     *\r\n     * @name Phaser.Input.InputManager#_hasMoveCallback\r\n     * @private\r\n     * @type {boolean}\r\n     * @deprecated\r\n     * @since 3.10.0\r\n     */\n\n    this._hasMoveCallback = false;\n    /**\r\n     * Is a custom cursor currently set? (desktop only)\r\n     *\r\n     * @name Phaser.Input.InputManager#_customCursor\r\n     * @private\r\n     * @type {string}\r\n     * @since 3.10.0\r\n     */\n\n    this._customCursor = '';\n    /**\r\n     * Custom cursor tracking value.\r\n     *\r\n     * 0 - No change.\r\n     * 1 - Set new cursor.\r\n     * 2 - Reset cursor.\r\n     *\r\n     * @name Phaser.Input.InputManager#_setCursor\r\n     * @private\r\n     * @type {integer}\r\n     * @since 3.10.0\r\n     */\n\n    this._setCursor = 0;\n    /**\r\n     * The default CSS cursor to be used when interacting with your game.\r\n     *\r\n     * See the `setDefaultCursor` method for more details.\r\n     *\r\n     * @name Phaser.Input.InputManager#defaultCursor\r\n     * @type {string}\r\n     * @since 3.10.0\r\n     */\n\n    this.defaultCursor = '';\n    /**\r\n     * A reference to the Keyboard Manager class, if enabled via the `input.keyboard` Game Config property.\r\n     *\r\n     * @name Phaser.Input.InputManager#keyboard\r\n     * @type {?Phaser.Input.Keyboard.KeyboardManager}\r\n     * @since 3.16.0\r\n     */\n\n    this.keyboard = config.inputKeyboard ? new Keyboard(this) : null;\n    /**\r\n     * A reference to the Mouse Manager class, if enabled via the `input.mouse` Game Config property.\r\n     *\r\n     * @name Phaser.Input.InputManager#mouse\r\n     * @type {?Phaser.Input.Mouse.MouseManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.mouse = config.inputMouse ? new Mouse(this) : null;\n    /**\r\n     * A reference to the Touch Manager class, if enabled via the `input.touch` Game Config property.\r\n     *\r\n     * @name Phaser.Input.InputManager#touch\r\n     * @type {Phaser.Input.Touch.TouchManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.touch = config.inputTouch ? new Touch(this) : null;\n    /**\r\n     * An array of Pointers that have been added to the game.\r\n     * The first entry is reserved for the Mouse Pointer, the rest are Touch Pointers.\r\n     *\r\n     * By default there is 1 touch pointer enabled. If you need more use the `addPointer` method to start them,\r\n     * or set the `input.activePointers` property in the Game Config.\r\n     *\r\n     * @name Phaser.Input.InputManager#pointers\r\n     * @type {Phaser.Input.Pointer[]}\r\n     * @since 3.10.0\r\n     */\n\n    this.pointers = [];\n    /**\r\n     * The number of touch objects activated and being processed each update.\r\n     *\r\n     * You can change this by either calling `addPointer` at run-time, or by\r\n     * setting the `input.activePointers` property in the Game Config.\r\n     *\r\n     * @name Phaser.Input.InputManager#pointersTotal\r\n     * @type {integer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\n\n    this.pointersTotal = config.inputActivePointers;\n\n    if (config.inputTouch && this.pointersTotal === 1) {\n      this.pointersTotal = 2;\n    }\n\n    for (var i = 0; i <= this.pointersTotal; i++) {\n      var pointer = new Pointer(this, i);\n      pointer.smoothFactor = config.inputSmoothFactor;\n      this.pointers.push(pointer);\n    }\n    /**\r\n     * The mouse has its own unique Pointer object, which you can reference directly if making a _desktop specific game_.\r\n     * If you are supporting both desktop and touch devices then do not use this property, instead use `activePointer`\r\n     * which will always map to the most recently interacted pointer.\r\n     *\r\n     * @name Phaser.Input.InputManager#mousePointer\r\n     * @type {?Phaser.Input.Pointer}\r\n     * @since 3.10.0\r\n     */\n\n\n    this.mousePointer = config.inputMouse ? this.pointers[0] : null;\n    /**\r\n     * The most recently active Pointer object.\r\n     *\r\n     * If you've only 1 Pointer in your game then this will accurately be either the first finger touched, or the mouse.\r\n     *\r\n     * If your game doesn't need to support multi-touch then you can safely use this property in all of your game\r\n     * code and it will adapt to be either the mouse or the touch, based on device.\r\n     *\r\n     * @name Phaser.Input.InputManager#activePointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @since 3.0.0\r\n     */\n\n    this.activePointer = this.pointers[0];\n    /**\r\n     * Reset every frame. Set to `true` if any of the Pointers are dirty this frame.\r\n     *\r\n     * @name Phaser.Input.InputManager#dirty\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\n\n    this.dirty = false;\n    /**\r\n     * If the top-most Scene in the Scene List receives an input it will stop input from\r\n     * propagating any lower down the scene list, i.e. if you have a UI Scene at the top\r\n     * and click something on it, that click will not then be passed down to any other\r\n     * Scene below. Disable this to have input events passed through all Scenes, all the time.\r\n     *\r\n     * @name Phaser.Input.InputManager#globalTopOnly\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.globalTopOnly = true;\n    /**\r\n     * An internal flag that controls if the Input Manager will ignore or process native DOM events this frame.\r\n     * Set via the InputPlugin.stopPropagation method.\r\n     *\r\n     * @name Phaser.Input.InputManager#ignoreEvents\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.ignoreEvents = false;\n    /**\r\n     * Use the internal event queue or not?\r\n     * \r\n     * Set this via the Game Config with the `inputQueue` property.\r\n     * \r\n     * Phaser 3.15.1 and earlier used a event queue by default.\r\n     * \r\n     * This was changed in version 3.16 to use an immediate-mode system.\r\n     * The previous queue based version remains and is left under this flag for backwards\r\n     * compatibility. This flag, along with the legacy system, will be removed in a future version.\r\n     *\r\n     * @name Phaser.Input.InputManager#useQueue\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.16.0\r\n     */\n\n    this.useQueue = config.inputQueue;\n    /**\r\n     * The time this Input Manager was last updated.\r\n     * This value is populated by the Game Step each frame.\r\n     *\r\n     * @name Phaser.Input.InputManager#time\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.16.2\r\n     */\n\n    this.time = 0;\n    /**\r\n     * Internal property that tracks frame event state.\r\n     *\r\n     * @name Phaser.Input.InputManager#_updatedThisFrame\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this._updatedThisFrame = false;\n    /**\r\n     * A re-cycled point-like object to store hit test values in.\r\n     *\r\n     * @name Phaser.Input.InputManager#_tempPoint\r\n     * @type {{x:number, y:number}}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._tempPoint = {\n      x: 0,\n      y: 0\n    };\n    /**\r\n     * A re-cycled array to store hit results in.\r\n     *\r\n     * @name Phaser.Input.InputManager#_tempHitTest\r\n     * @type {array}\r\n     * @private\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this._tempHitTest = [];\n    /**\r\n     * A re-cycled matrix used in hit test calculations.\r\n     *\r\n     * @name Phaser.Input.InputManager#_tempMatrix\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @private\r\n     * @since 3.4.0\r\n     */\n\n    this._tempMatrix = new TransformMatrix();\n    /**\r\n     * A re-cycled matrix used in hit test calculations.\r\n     *\r\n     * @name Phaser.Input.InputManager#_tempMatrix2\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix2 = new TransformMatrix();\n    game.events.once(GameEvents.BOOT, this.boot, this);\n  },\n\n  /**\r\n   * The Boot handler is called by Phaser.Game when it first starts up.\r\n   * The renderer is available by now.\r\n   *\r\n   * @method Phaser.Input.InputManager#boot\r\n   * @protected\r\n   * @fires Phaser.Input.Events#MANAGER_BOOT\r\n   * @since 3.0.0\r\n   */\n  boot: function boot() {\n    this.canvas = this.game.canvas;\n    this.scaleManager = this.game.scale;\n    this.events.emit(Events.MANAGER_BOOT);\n\n    if (this.useQueue) {\n      this.game.events.on(GameEvents.PRE_STEP, this.legacyUpdate, this);\n    } else {\n      this.game.events.on(GameEvents.PRE_STEP, this.preStep, this);\n    }\n\n    this.game.events.on(GameEvents.POST_STEP, this.postUpdate, this);\n    this.game.events.once(GameEvents.DESTROY, this.destroy, this);\n  },\n\n  /**\r\n   * Internal canvas state change, called automatically by the Mouse Manager.\r\n   *\r\n   * @method Phaser.Input.InputManager#setCanvasOver\r\n   * @fires Phaser.Input.Events#GAME_OVER\r\n   * @private\r\n   * @since 3.16.0\r\n   *\r\n   * @param {(MouseEvent|TouchEvent)} event - The DOM Event.\r\n   */\n  setCanvasOver: function setCanvasOver(event) {\n    this.isOver = true;\n    this.events.emit(Events.GAME_OVER, event);\n  },\n\n  /**\r\n   * Internal canvas state change, called automatically by the Mouse Manager.\r\n   *\r\n   * @method Phaser.Input.InputManager#setCanvasOut\r\n   * @fires Phaser.Input.Events#GAME_OUT\r\n   * @private\r\n   * @since 3.16.0\r\n   *\r\n   * @param {(MouseEvent|TouchEvent)} event - The DOM Event.\r\n   */\n  setCanvasOut: function setCanvasOut(event) {\n    this.isOver = false;\n    this.events.emit(Events.GAME_OUT, event);\n  },\n\n  /**\r\n   * Internal update method, called automatically when a DOM input event is received.\r\n   *\r\n   * @method Phaser.Input.InputManager#update\r\n   * @private\r\n   * @fires Phaser.Input.Events#MANAGER_UPDATE\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} time - The time stamp value of this game step.\r\n   */\n  update: function update(time) {\n    if (!this._updatedThisFrame) {\n      this._setCursor = 0;\n      this._updatedThisFrame = true;\n    }\n\n    this.events.emit(Events.MANAGER_UPDATE);\n    this.ignoreEvents = false;\n    this.dirty = true;\n    var pointers = this.pointers;\n\n    for (var i = 0; i < this.pointersTotal; i++) {\n      pointers[i].reset(time);\n    }\n  },\n\n  /**\r\n   * Internal update, called automatically by the Game Step.\r\n   *\r\n   * @method Phaser.Input.InputManager#preStep\r\n   * @private\r\n   * @since 3.16.2\r\n   *\r\n   * @param {number} time - The time stamp value of this game step.\r\n   */\n  preStep: function preStep(time) {\n    this.time = time;\n  },\n\n  /**\r\n   * Internal update loop, called automatically by the Game Step when using the legacy event queue.\r\n   *\r\n   * @method Phaser.Input.InputManager#legacyUpdate\r\n   * @private\r\n   * @fires Phaser.Input.Events#MANAGER_UPDATE\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} time - The time stamp value of this game step.\r\n   */\n  legacyUpdate: function legacyUpdate(time) {\n    this.time = time;\n    var i;\n    this._setCursor = 0;\n    this.events.emit(Events.MANAGER_UPDATE);\n    this.ignoreEvents = false;\n    this.dirty = false;\n    var len = this.queue.length;\n    var pointers = this.pointers;\n\n    for (i = 0; i < this.pointersTotal; i++) {\n      pointers[i].reset(time);\n    }\n\n    if (!this.enabled || len === 0) {\n      for (i = 0; i < this.pointersTotal; i++) {\n        pointers[i].updateMotion();\n      }\n\n      return;\n    }\n\n    this.dirty = true; //  Clears the queue array, and also means we don't work on array data that could potentially\n    //  be modified during the processing phase\n\n    var queue = this.queue.splice(0, len);\n    var mouse = this.mousePointer; //  Process the event queue, dispatching all of the events that have stored up\n\n    for (i = 0; i < len; i += 2) {\n      var type = queue[i];\n      var event = queue[i + 1];\n\n      switch (type) {\n        case CONST.MOUSE_DOWN:\n          mouse.down(event, time);\n          break;\n\n        case CONST.MOUSE_MOVE:\n          mouse.move(event, time);\n          break;\n\n        case CONST.MOUSE_UP:\n          mouse.up(event, time);\n          break;\n\n        case CONST.TOUCH_START:\n          this.startPointer(event, time);\n          break;\n\n        case CONST.TOUCH_MOVE:\n          this.updatePointer(event, time);\n          break;\n\n        case CONST.TOUCH_END:\n          this.stopPointer(event, time);\n          break;\n\n        case CONST.TOUCH_CANCEL:\n          this.cancelPointer(event, time);\n          break;\n\n        case CONST.POINTER_LOCK_CHANGE:\n          this.events.emit(Events.POINTERLOCK_CHANGE, event, this.mouse.locked);\n          break;\n      }\n    }\n\n    for (i = 0; i < this.pointersTotal; i++) {\n      pointers[i].updateMotion();\n    }\n  },\n\n  /**\r\n   * Internal post-update, called automatically by the Game step.\r\n   *\r\n   * @method Phaser.Input.InputManager#postUpdate\r\n   * @private\r\n   * @since 3.10.0\r\n   */\n  postUpdate: function postUpdate() {\n    if (this._setCursor === 1) {\n      this.canvas.style.cursor = this._customCursor;\n    } else if (this._setCursor === 2) {\n      this.canvas.style.cursor = this.defaultCursor;\n    }\n\n    this.dirty = false;\n    this._updatedThisFrame = false;\n  },\n\n  /**\r\n   * Tells the Input system to set a custom cursor.\r\n   * \r\n   * This cursor will be the default cursor used when interacting with the game canvas.\r\n   *\r\n   * If an Interactive Object also sets a custom cursor, this is the cursor that is reset after its use.\r\n   *\r\n   * Any valid CSS cursor value is allowed, including paths to image files, i.e.:\r\n   *\r\n   * ```javascript\r\n   * this.input.setDefaultCursor('url(assets/cursors/sword.cur), pointer');\r\n   * ```\r\n   * \r\n   * Please read about the differences between browsers when it comes to the file formats and sizes they support:\r\n   *\r\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\r\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_User_Interface/Using_URL_values_for_the_cursor_property\r\n   *\r\n   * It's up to you to pick a suitable cursor format that works across the range of browsers you need to support.\r\n   *\r\n   * @method Phaser.Input.InputManager#setDefaultCursor\r\n   * @since 3.10.0\r\n   * \r\n   * @param {string} cursor - The CSS to be used when setting the default cursor.\r\n   */\n  setDefaultCursor: function setDefaultCursor(cursor) {\n    this.defaultCursor = cursor;\n\n    if (this.canvas.style.cursor !== cursor) {\n      this.canvas.style.cursor = cursor;\n    }\n  },\n\n  /**\r\n   * Called by the InputPlugin when processing over and out events.\r\n   * \r\n   * Tells the Input Manager to set a custom cursor during its postUpdate step.\r\n   *\r\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\r\n   *\r\n   * @method Phaser.Input.InputManager#setCursor\r\n   * @private\r\n   * @since 3.10.0\r\n   * \r\n   * @param {Phaser.Input.InteractiveObject} interactiveObject - The Interactive Object that called this method.\r\n   */\n  setCursor: function setCursor(interactiveObject) {\n    if (interactiveObject.cursor) {\n      this._setCursor = 1;\n      this._customCursor = interactiveObject.cursor;\n    }\n  },\n\n  /**\r\n   * Called by the InputPlugin when processing over and out events.\r\n   * \r\n   * Tells the Input Manager to clear the hand cursor, if set, during its postUpdate step.\r\n   *\r\n   * @method Phaser.Input.InputManager#resetCursor\r\n   * @private\r\n   * @since 3.10.0\r\n   * \r\n   * @param {Phaser.Input.InteractiveObject} interactiveObject - The Interactive Object that called this method.\r\n   */\n  resetCursor: function resetCursor(interactiveObject) {\n    if (interactiveObject.cursor) {\n      this._setCursor = 2;\n    }\n  },\n  //  event.targetTouches = list of all touches on the TARGET ELEMENT (i.e. game dom element)\n  //  event.touches = list of all touches on the ENTIRE DOCUMENT, not just the target element\n  //  event.changedTouches = the touches that CHANGED in this event, not the total number of them\n\n  /**\r\n   * Called by the main update loop when a Touch Start Event is received.\r\n   *\r\n   * @method Phaser.Input.InputManager#startPointer\r\n   * @private\r\n   * @since 3.10.0\r\n   *\r\n   * @param {TouchEvent} event - The native DOM event to be processed.\r\n   * @param {number} time - The time stamp value of this game step.\r\n   * \r\n   * @return {Phaser.Input.Pointer[]} An array containing all the Pointer instances that were modified by this event.\r\n   */\n  startPointer: function startPointer(event, time) {\n    var pointers = this.pointers;\n    var changed = [];\n\n    for (var c = 0; c < event.changedTouches.length; c++) {\n      var changedTouch = event.changedTouches[c];\n\n      for (var i = 1; i < this.pointersTotal; i++) {\n        var pointer = pointers[i];\n\n        if (!pointer.active) {\n          pointer.touchstart(changedTouch, time);\n          this.activePointer = pointer;\n          changed.push(pointer);\n          break;\n        }\n      }\n    }\n\n    return changed;\n  },\n\n  /**\r\n   * Called by the main update loop when a Touch Move Event is received.\r\n   *\r\n   * @method Phaser.Input.InputManager#updatePointer\r\n   * @private\r\n   * @since 3.10.0\r\n   *\r\n   * @param {TouchEvent} event - The native DOM event to be processed.\r\n   * @param {number} time - The time stamp value of this game step.\r\n   * \r\n   * @return {Phaser.Input.Pointer[]} An array containing all the Pointer instances that were modified by this event.\r\n   */\n  updatePointer: function updatePointer(event, time) {\n    var pointers = this.pointers;\n    var changed = [];\n\n    for (var c = 0; c < event.changedTouches.length; c++) {\n      var changedTouch = event.changedTouches[c];\n\n      for (var i = 1; i < this.pointersTotal; i++) {\n        var pointer = pointers[i];\n\n        if (pointer.active && pointer.identifier === changedTouch.identifier) {\n          pointer.touchmove(changedTouch, time);\n          this.activePointer = pointer;\n          changed.push(pointer);\n          break;\n        }\n      }\n    }\n\n    return changed;\n  },\n  //  For touch end its a list of the touch points that have been removed from the surface\n  //  https://developer.mozilla.org/en-US/docs/DOM/TouchList\n  //  event.changedTouches = the touches that CHANGED in this event, not the total number of them\n\n  /**\r\n   * Called by the main update loop when a Touch End Event is received.\r\n   *\r\n   * @method Phaser.Input.InputManager#stopPointer\r\n   * @private\r\n   * @since 3.10.0\r\n   *\r\n   * @param {TouchEvent} event - The native DOM event to be processed.\r\n   * @param {number} time - The time stamp value of this game step.\r\n   * \r\n   * @return {Phaser.Input.Pointer[]} An array containing all the Pointer instances that were modified by this event.\r\n   */\n  stopPointer: function stopPointer(event, time) {\n    var pointers = this.pointers;\n    var changed = [];\n\n    for (var c = 0; c < event.changedTouches.length; c++) {\n      var changedTouch = event.changedTouches[c];\n\n      for (var i = 1; i < this.pointersTotal; i++) {\n        var pointer = pointers[i];\n\n        if (pointer.active && pointer.identifier === changedTouch.identifier) {\n          pointer.touchend(changedTouch, time);\n          changed.push(pointer);\n          break;\n        }\n      }\n    }\n\n    return changed;\n  },\n\n  /**\r\n   * Called by the main update loop when a Touch Cancel Event is received.\r\n   *\r\n   * @method Phaser.Input.InputManager#cancelPointer\r\n   * @private\r\n   * @since 3.15.0\r\n   *\r\n   * @param {TouchEvent} event - The native DOM event to be processed.\r\n   * @param {number} time - The time stamp value of this game step.\r\n   * \r\n   * @return {Phaser.Input.Pointer[]} An array containing all the Pointer instances that were modified by this event.\r\n   */\n  cancelPointer: function cancelPointer(event, time) {\n    var pointers = this.pointers;\n    var changed = [];\n\n    for (var c = 0; c < event.changedTouches.length; c++) {\n      var changedTouch = event.changedTouches[c];\n\n      for (var i = 1; i < this.pointersTotal; i++) {\n        var pointer = pointers[i];\n\n        if (pointer.active && pointer.identifier === changedTouch.identifier) {\n          pointer.touchend(changedTouch, time);\n          changed.push(pointer);\n          break;\n        }\n      }\n    }\n\n    return changed;\n  },\n\n  /**\r\n   * Adds new Pointer objects to the Input Manager.\r\n   *\r\n   * By default Phaser creates 2 pointer objects: `mousePointer` and `pointer1`.\r\n   *\r\n   * You can create more either by calling this method, or by setting the `input.activePointers` property\r\n   * in the Game Config, up to a maximum of 10 pointers.\r\n   *\r\n   * The first 10 pointers are available via the `InputPlugin.pointerX` properties, once they have been added\r\n   * via this method.\r\n   *\r\n   * @method Phaser.Input.InputManager#addPointer\r\n   * @since 3.10.0\r\n   *\r\n   * @param {integer} [quantity=1] The number of new Pointers to create. A maximum of 10 is allowed in total.\r\n   *\r\n   * @return {Phaser.Input.Pointer[]} An array containing all of the new Pointer objects that were created.\r\n   */\n  addPointer: function addPointer(quantity) {\n    if (quantity === undefined) {\n      quantity = 1;\n    }\n\n    var output = [];\n\n    if (this.pointersTotal + quantity > 10) {\n      quantity = 10 - this.pointersTotal;\n    }\n\n    for (var i = 0; i < quantity; i++) {\n      var id = this.pointers.length;\n      var pointer = new Pointer(this, id);\n      pointer.smoothFactor = this.config.inputSmoothFactor;\n      this.pointers.push(pointer);\n      this.pointersTotal++;\n      output.push(pointer);\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Process any pending DOM callbacks.\r\n   *\r\n   * @method Phaser.Input.InputManager#processDomCallbacks\r\n   * @private\r\n   * @deprecated\r\n   * @since 3.10.0\r\n   *\r\n   * @param {array} once - The isOnce callbacks to invoke.\r\n   * @param {array} every - The every frame callbacks to invoke.\r\n   * @param {any} event - The native DOM event that is passed to the callbacks.\r\n   *\r\n   * @return {boolean} `true` if there are callbacks still in the list, otherwise `false`.\r\n   */\n  processDomCallbacks: function processDomCallbacks(once, every, event) {\n    var i = 0;\n\n    for (i = 0; i < once.length; i++) {\n      once[i](event);\n    }\n\n    for (i = 0; i < every.length; i++) {\n      every[i](event);\n    }\n\n    return every.length > 0;\n  },\n\n  /**\r\n   * Internal method that gets a list of all the active Input Plugins in the game\r\n   * and updates each of them in turn, in reverse order (top to bottom), to allow\r\n   * for DOM top-level event handling simulation.\r\n   *\r\n   * @method Phaser.Input.InputManager#updateInputPlugins\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} time - The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().\r\n   * @param {number} delta - The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.\r\n   */\n  updateInputPlugins: function updateInputPlugins(time, delta) {\n    var scenes = this.game.scene.getScenes(true, true);\n\n    for (var i = 0; i < scenes.length; i++) {\n      var scene = scenes[i];\n\n      if (scene.sys.input) {\n        scene.sys.input.update(time, delta);\n      }\n    }\n  },\n\n  /**\r\n   * Queues a touch start event, as passed in by the TouchManager.\r\n   * Also dispatches any DOM callbacks for this event.\r\n   *\r\n   * @method Phaser.Input.InputManager#queueTouchStart\r\n   * @private\r\n   * @since 3.10.0\r\n   *\r\n   * @param {TouchEvent} event - The native DOM Touch event.\r\n   */\n  queueTouchStart: function queueTouchStart(event) {\n    if (this.useQueue) {\n      this.queue.push(CONST.TOUCH_START, event);\n\n      if (this._hasDownCallback) {\n        var callbacks = this.domCallbacks;\n        this._hasDownCallback = this.processDomCallbacks(callbacks.downOnce, callbacks.down, event);\n        callbacks.downOnce = [];\n      }\n    } else if (this.enabled) {\n      this.update(event.timeStamp);\n      var changed = this.startPointer(event, event.timeStamp);\n      changed.forEach(function (pointer) {\n        pointer.updateMotion();\n      });\n      this.updateInputPlugins(event.timeStamp, this.game.loop.delta);\n    }\n  },\n\n  /**\r\n   * Queues a touch move event, as passed in by the TouchManager.\r\n   * Also dispatches any DOM callbacks for this event.\r\n   *\r\n   * @method Phaser.Input.InputManager#queueTouchMove\r\n   * @private\r\n   * @since 3.10.0\r\n   *\r\n   * @param {TouchEvent} event - The native DOM Touch event.\r\n   */\n  queueTouchMove: function queueTouchMove(event) {\n    if (this.useQueue) {\n      this.queue.push(CONST.TOUCH_MOVE, event);\n\n      if (this._hasMoveCallback) {\n        var callbacks = this.domCallbacks;\n        this._hasMoveCallback = this.processDomCallbacks(callbacks.moveOnce, callbacks.move, event);\n        callbacks.moveOnce = [];\n      }\n    } else if (this.enabled) {\n      this.update(event.timeStamp);\n      var changed = this.updatePointer(event, event.timeStamp);\n      changed.forEach(function (pointer) {\n        pointer.updateMotion();\n      });\n      this.updateInputPlugins(event.timeStamp, this.game.loop.delta);\n    }\n  },\n\n  /**\r\n   * Queues a touch end event, as passed in by the TouchManager.\r\n   * Also dispatches any DOM callbacks for this event.\r\n   *\r\n   * @method Phaser.Input.InputManager#queueTouchEnd\r\n   * @private\r\n   * @since 3.10.0\r\n   *\r\n   * @param {TouchEvent} event - The native DOM Touch event.\r\n   */\n  queueTouchEnd: function queueTouchEnd(event) {\n    if (this.useQueue) {\n      this.queue.push(CONST.TOUCH_END, event);\n\n      if (this._hasUpCallback) {\n        var callbacks = this.domCallbacks;\n        this._hasUpCallback = this.processDomCallbacks(callbacks.upOnce, callbacks.up, event);\n        callbacks.upOnce = [];\n      }\n    } else if (this.enabled) {\n      this.update(event.timeStamp);\n      var changed = this.stopPointer(event, event.timeStamp);\n      changed.forEach(function (pointer) {\n        pointer.updateMotion();\n      });\n      this.updateInputPlugins(event.timeStamp, this.game.loop.delta);\n    }\n  },\n\n  /**\r\n   * Queues a touch cancel event, as passed in by the TouchManager.\r\n   * Also dispatches any DOM callbacks for this event.\r\n   *\r\n   * @method Phaser.Input.InputManager#queueTouchCancel\r\n   * @private\r\n   * @since 3.15.0\r\n   *\r\n   * @param {TouchEvent} event - The native DOM Touch event.\r\n   */\n  queueTouchCancel: function queueTouchCancel(event) {\n    if (this.useQueue) {\n      this.queue.push(CONST.TOUCH_CANCEL, event);\n    } else if (this.enabled) {\n      this.update(event.timeStamp);\n      var changed = this.cancelPointer(event, event.timeStamp);\n      changed.forEach(function (pointer) {\n        pointer.updateMotion();\n      });\n      this.updateInputPlugins(event.timeStamp, this.game.loop.delta);\n    }\n  },\n\n  /**\r\n   * Queues a mouse down event, as passed in by the MouseManager.\r\n   * Also dispatches any DOM callbacks for this event.\r\n   *\r\n   * @method Phaser.Input.InputManager#queueMouseDown\r\n   * @private\r\n   * @since 3.10.0\r\n   *\r\n   * @param {MouseEvent} event - The native DOM Mouse event.\r\n   */\n  queueMouseDown: function queueMouseDown(event) {\n    if (this.useQueue) {\n      this.queue.push(CONST.MOUSE_DOWN, event);\n\n      if (this._hasDownCallback) {\n        var callbacks = this.domCallbacks;\n        this._hasDownCallback = this.processDomCallbacks(callbacks.downOnce, callbacks.down, event);\n        callbacks.downOnce = [];\n      }\n    } else if (this.enabled) {\n      this.update(event.timeStamp);\n      this.mousePointer.down(event, event.timeStamp);\n      this.mousePointer.updateMotion();\n      this.updateInputPlugins(event.timeStamp, this.game.loop.delta);\n    }\n  },\n\n  /**\r\n   * Queues a mouse move event, as passed in by the MouseManager.\r\n   * Also dispatches any DOM callbacks for this event.\r\n   *\r\n   * @method Phaser.Input.InputManager#queueMouseMove\r\n   * @private\r\n   * @since 3.10.0\r\n   *\r\n   * @param {MouseEvent} event - The native DOM Mouse event.\r\n   */\n  queueMouseMove: function queueMouseMove(event) {\n    if (this.useQueue) {\n      this.queue.push(CONST.MOUSE_MOVE, event);\n\n      if (this._hasMoveCallback) {\n        var callbacks = this.domCallbacks;\n        this._hasMoveCallback = this.processDomCallbacks(callbacks.moveOnce, callbacks.move, event);\n        callbacks.moveOnce = [];\n      }\n    } else if (this.enabled) {\n      this.update(event.timeStamp);\n      this.mousePointer.move(event, event.timeStamp);\n      this.mousePointer.updateMotion();\n      this.updateInputPlugins(event.timeStamp, this.game.loop.delta);\n    }\n  },\n\n  /**\r\n   * Queues a mouse up event, as passed in by the MouseManager.\r\n   * Also dispatches any DOM callbacks for this event.\r\n   *\r\n   * @method Phaser.Input.InputManager#queueMouseUp\r\n   * @private\r\n   * @since 3.10.0\r\n   *\r\n   * @param {MouseEvent} event - The native DOM Mouse event.\r\n   */\n  queueMouseUp: function queueMouseUp(event) {\n    if (this.useQueue) {\n      this.queue.push(CONST.MOUSE_UP, event);\n\n      if (this._hasUpCallback) {\n        var callbacks = this.domCallbacks;\n        this._hasUpCallback = this.processDomCallbacks(callbacks.upOnce, callbacks.up, event);\n        callbacks.upOnce = [];\n      }\n    } else if (this.enabled) {\n      this.update(event.timeStamp);\n      this.mousePointer.up(event, event.timeStamp);\n      this.mousePointer.updateMotion();\n      this.updateInputPlugins(event.timeStamp, this.game.loop.delta);\n    }\n  },\n\n  /**\r\n   * **Note:** As of Phaser 3.16 this method is no longer required _unless_ you have set `input.queue = true`\r\n   * in your game config, to force it to use the legacy event queue system. This method is deprecated and\r\n   * will be removed in a future version.\r\n   * \r\n   * Adds a callback to be invoked whenever the native DOM `mouseup` or `touchend` events are received.\r\n   * By setting the `isOnce` argument you can control if the callback is called once,\r\n   * or every time the DOM event occurs.\r\n   *\r\n   * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,\r\n   * within the scope of the DOM event handler. Therefore, they are considered as 'native'\r\n   * from the perspective of the browser. This means they can be used for tasks such as\r\n   * opening new browser windows, or anything which explicitly requires user input to activate.\r\n   * However, as a result of this, they come with their own risks, and as such should not be used\r\n   * for general game input, but instead be reserved for special circumstances.\r\n   *\r\n   * If all you're trying to do is execute a callback when a pointer is released, then\r\n   * please use the internal Input event system instead.\r\n   *\r\n   * Please understand that these callbacks are invoked when the browser feels like doing so,\r\n   * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep\r\n   * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,\r\n   * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating\r\n   * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind\r\n   * solve.\r\n   *\r\n   * @method Phaser.Input.InputManager#addUpCallback\r\n   * @deprecated\r\n   * @since 3.10.0\r\n   *\r\n   * @param {function} callback - The callback to be invoked on this dom event.\r\n   * @param {boolean} [isOnce=true] - `true` if the callback will only be invoked once, `false` to call every time this event happens.\r\n   *\r\n   * @return {this} The Input Manager.\r\n   */\n  addUpCallback: function addUpCallback(callback, isOnce) {\n    if (isOnce === undefined) {\n      isOnce = true;\n    }\n\n    if (isOnce) {\n      this.domCallbacks.upOnce.push(callback);\n    } else {\n      this.domCallbacks.up.push(callback);\n    }\n\n    this._hasUpCallback = true;\n    return this;\n  },\n\n  /**\r\n   * **Note:** As of Phaser 3.16 this method is no longer required _unless_ you have set `input.queue = true`\r\n   * in your game config, to force it to use the legacy event queue system. This method is deprecated and\r\n   * will be removed in a future version.\r\n   * \r\n   * Adds a callback to be invoked whenever the native DOM `mousedown` or `touchstart` events are received.\r\n   * By setting the `isOnce` argument you can control if the callback is called once,\r\n   * or every time the DOM event occurs.\r\n   *\r\n   * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,\r\n   * within the scope of the DOM event handler. Therefore, they are considered as 'native'\r\n   * from the perspective of the browser. This means they can be used for tasks such as\r\n   * opening new browser windows, or anything which explicitly requires user input to activate.\r\n   * However, as a result of this, they come with their own risks, and as such should not be used\r\n   * for general game input, but instead be reserved for special circumstances.\r\n   *\r\n   * If all you're trying to do is execute a callback when a pointer is down, then\r\n   * please use the internal Input event system instead.\r\n   *\r\n   * Please understand that these callbacks are invoked when the browser feels like doing so,\r\n   * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep\r\n   * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,\r\n   * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating\r\n   * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind\r\n   * solve.\r\n   *\r\n   * @method Phaser.Input.InputManager#addDownCallback\r\n   * @deprecated\r\n   * @since 3.10.0\r\n   *\r\n   * @param {function} callback - The callback to be invoked on this dom event.\r\n   * @param {boolean} [isOnce=true] - `true` if the callback will only be invoked once, `false` to call every time this event happens.\r\n   *\r\n   * @return {this} The Input Manager.\r\n   */\n  addDownCallback: function addDownCallback(callback, isOnce) {\n    if (isOnce === undefined) {\n      isOnce = true;\n    }\n\n    if (isOnce) {\n      this.domCallbacks.downOnce.push(callback);\n    } else {\n      this.domCallbacks.down.push(callback);\n    }\n\n    this._hasDownCallback = true;\n    return this;\n  },\n\n  /**\r\n   * **Note:** As of Phaser 3.16 this method is no longer required _unless_ you have set `input.queue = true`\r\n   * in your game config, to force it to use the legacy event queue system. This method is deprecated and\r\n   * will be removed in a future version.\r\n   * \r\n   * Adds a callback to be invoked whenever the native DOM `mousemove` or `touchmove` events are received.\r\n   * By setting the `isOnce` argument you can control if the callback is called once,\r\n   * or every time the DOM event occurs.\r\n   *\r\n   * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,\r\n   * within the scope of the DOM event handler. Therefore, they are considered as 'native'\r\n   * from the perspective of the browser. This means they can be used for tasks such as\r\n   * opening new browser windows, or anything which explicitly requires user input to activate.\r\n   * However, as a result of this, they come with their own risks, and as such should not be used\r\n   * for general game input, but instead be reserved for special circumstances.\r\n   *\r\n   * If all you're trying to do is execute a callback when a pointer is moved, then\r\n   * please use the internal Input event system instead.\r\n   *\r\n   * Please understand that these callbacks are invoked when the browser feels like doing so,\r\n   * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep\r\n   * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,\r\n   * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating\r\n   * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind\r\n   * solve.\r\n   *\r\n   * @method Phaser.Input.InputManager#addMoveCallback\r\n   * @deprecated\r\n   * @since 3.10.0\r\n   *\r\n   * @param {function} callback - The callback to be invoked on this dom event.\r\n   * @param {boolean} [isOnce=false] - `true` if the callback will only be invoked once, `false` to call every time this event happens.\r\n   *\r\n   * @return {this} The Input Manager.\r\n   */\n  addMoveCallback: function addMoveCallback(callback, isOnce) {\n    if (isOnce === undefined) {\n      isOnce = false;\n    }\n\n    if (isOnce) {\n      this.domCallbacks.moveOnce.push(callback);\n    } else {\n      this.domCallbacks.move.push(callback);\n    }\n\n    this._hasMoveCallback = true;\n    return this;\n  },\n\n  /**\r\n   * Checks if the given Game Object should be considered as a candidate for input or not.\r\n   *\r\n   * Checks if the Game Object has an input component that is enabled, that it will render,\r\n   * and finally, if it has a parent, that the parent parent, or any ancestor, is visible or not.\r\n   *\r\n   * @method Phaser.Input.InputManager#inputCandidate\r\n   * @private\r\n   * @since 3.10.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to test.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera which is being tested against.\r\n   *\r\n   * @return {boolean} `true` if the Game Object should be considered for input, otherwise `false`.\r\n   */\n  inputCandidate: function inputCandidate(gameObject, camera) {\n    var input = gameObject.input;\n\n    if (!input || !input.enabled || !gameObject.willRender(camera)) {\n      return false;\n    }\n\n    var visible = true;\n    var parent = gameObject.parentContainer;\n\n    if (parent) {\n      do {\n        if (!parent.willRender(camera)) {\n          visible = false;\n          break;\n        }\n\n        parent = parent.parentContainer;\n      } while (parent);\n    }\n\n    return visible;\n  },\n\n  /**\r\n   * Performs a hit test using the given Pointer and camera, against an array of interactive Game Objects.\r\n   *\r\n   * The Game Objects are culled against the camera, and then the coordinates are translated into the local camera space\r\n   * and used to determine if they fall within the remaining Game Objects hit areas or not.\r\n   *\r\n   * If nothing is matched an empty array is returned.\r\n   *\r\n   * This method is called automatically by InputPlugin.hitTestPointer and doesn't usually need to be invoked directly.\r\n   *\r\n   * @method Phaser.Input.InputManager#hitTest\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to test against.\r\n   * @param {array} gameObjects - An array of interactive Game Objects to check.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera which is being tested against.\r\n   * @param {array} [output] - An array to store the results in. If not given, a new empty array is created.\r\n   *\r\n   * @return {array} An array of the Game Objects that were hit during this hit test.\r\n   */\n  hitTest: function hitTest(pointer, gameObjects, camera, output) {\n    if (output === undefined) {\n      output = this._tempHitTest;\n    }\n\n    var tempPoint = this._tempPoint;\n    var csx = camera.scrollX;\n    var csy = camera.scrollY;\n    output.length = 0;\n    var x = pointer.x;\n    var y = pointer.y;\n\n    if (camera.resolution !== 1) {\n      x += camera._x;\n      y += camera._y;\n    } //  Stores the world point inside of tempPoint\n\n\n    camera.getWorldPoint(x, y, tempPoint);\n    pointer.worldX = tempPoint.x;\n    pointer.worldY = tempPoint.y;\n    var point = {\n      x: 0,\n      y: 0\n    };\n    var matrix = this._tempMatrix;\n    var parentMatrix = this._tempMatrix2;\n\n    for (var i = 0; i < gameObjects.length; i++) {\n      var gameObject = gameObjects[i]; //  Checks if the Game Object can receive input (isn't being ignored by the camera, invisible, etc)\n      //  and also checks all of its parents, if any\n\n      if (!this.inputCandidate(gameObject, camera)) {\n        continue;\n      }\n\n      var px = tempPoint.x + csx * gameObject.scrollFactorX - csx;\n      var py = tempPoint.y + csy * gameObject.scrollFactorY - csy;\n\n      if (gameObject.parentContainer) {\n        gameObject.getWorldTransformMatrix(matrix, parentMatrix);\n        matrix.applyInverse(px, py, point);\n      } else {\n        TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, point);\n      }\n\n      if (this.pointWithinHitArea(gameObject, point.x, point.y)) {\n        output.push(gameObject);\n      }\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Checks if the given x and y coordinate are within the hit area of the Game Object.\r\n   *\r\n   * This method assumes that the coordinate values have already been translated into the space of the Game Object.\r\n   *\r\n   * If the coordinates are within the hit area they are set into the Game Objects Input `localX` and `localY` properties.\r\n   *\r\n   * @method Phaser.Input.InputManager#pointWithinHitArea\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The interactive Game Object to check against.\r\n   * @param {number} x - The translated x coordinate for the hit test.\r\n   * @param {number} y - The translated y coordinate for the hit test.\r\n   *\r\n   * @return {boolean} `true` if the coordinates were inside the Game Objects hit area, otherwise `false`.\r\n   */\n  pointWithinHitArea: function pointWithinHitArea(gameObject, x, y) {\n    //  Normalize the origin\n    x += gameObject.displayOriginX;\n    y += gameObject.displayOriginY;\n    var input = gameObject.input;\n\n    if (input && input.hitAreaCallback(input.hitArea, x, y, gameObject)) {\n      input.localX = x;\n      input.localY = y;\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  /**\r\n   * Checks if the given x and y coordinate are within the hit area of the Interactive Object.\r\n   *\r\n   * This method assumes that the coordinate values have already been translated into the space of the Interactive Object.\r\n   *\r\n   * If the coordinates are within the hit area they are set into the Interactive Objects Input `localX` and `localY` properties.\r\n   *\r\n   * @method Phaser.Input.InputManager#pointWithinInteractiveObject\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.InteractiveObject} object - The Interactive Object to check against.\r\n   * @param {number} x - The translated x coordinate for the hit test.\r\n   * @param {number} y - The translated y coordinate for the hit test.\r\n   *\r\n   * @return {boolean} `true` if the coordinates were inside the Game Objects hit area, otherwise `false`.\r\n   */\n  pointWithinInteractiveObject: function pointWithinInteractiveObject(object, x, y) {\n    if (!object.hitArea) {\n      return false;\n    } //  Normalize the origin\n\n\n    x += object.gameObject.displayOriginX;\n    y += object.gameObject.displayOriginY;\n    object.localX = x;\n    object.localY = y;\n    return object.hitAreaCallback(object.hitArea, x, y, object);\n  },\n\n  /**\r\n   * Transforms the pageX and pageY values of a Pointer into the scaled coordinate space of the Input Manager.\r\n   *\r\n   * @method Phaser.Input.InputManager#transformPointer\r\n   * @since 3.10.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to transform the values for.\r\n   * @param {number} pageX - The Page X value.\r\n   * @param {number} pageY - The Page Y value.\r\n   * @param {boolean} wasMove - Are we transforming the Pointer from a move event, or an up / down event?\r\n   */\n  transformPointer: function transformPointer(pointer, pageX, pageY, wasMove) {\n    var p0 = pointer.position;\n    var p1 = pointer.prevPosition; //  Store previous position\n\n    p1.x = p0.x;\n    p1.y = p0.y; //  Translate coordinates\n\n    var x = this.scaleManager.transformX(pageX);\n    var y = this.scaleManager.transformY(pageY);\n    var a = pointer.smoothFactor;\n\n    if (!wasMove || a === 0) {\n      //  Set immediately\n      p0.x = x;\n      p0.y = y;\n    } else {\n      //  Apply smoothing\n      p0.x = x * a + p1.x * (1 - a);\n      p0.y = y * a + p1.y * (1 - a);\n    }\n  },\n\n  /**\r\n   * Destroys the Input Manager and all of its systems.\r\n   *\r\n   * There is no way to recover from doing this.\r\n   *\r\n   * @method Phaser.Input.InputManager#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    this.events.removeAllListeners();\n\n    if (this.keyboard) {\n      this.keyboard.destroy();\n    }\n\n    if (this.mouse) {\n      this.mouse.destroy();\n    }\n\n    if (this.touch) {\n      this.touch.destroy();\n    }\n\n    for (var i = 0; i < this.pointers.length; i++) {\n      this.pointers[i].destroy();\n    }\n\n    this.domCallbacks = {};\n    this.pointers = [];\n    this.queue = [];\n    this._tempHitTest = [];\n\n    this._tempMatrix.destroy();\n\n    this.canvas = null;\n    this.game = null;\n  }\n});\nmodule.exports = InputManager;","map":null,"metadata":{},"sourceType":"script"}