{"ast":null,"code":"/**\r\n* The `Matter.Engine` module contains methods for creating and manipulating engines.\r\n* An engine is a controller that manages updating the simulation of the world.\r\n* See `Matter.Runner` for an optional game loop utility.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Engine\r\n*/\nvar Engine = {};\nmodule.exports = Engine;\n\nvar World = require('../body/World');\n\nvar Sleeping = require('./Sleeping');\n\nvar Resolver = require('../collision/Resolver');\n\nvar Pairs = require('../collision/Pairs');\n\nvar Metrics = require('./Metrics');\n\nvar Grid = require('../collision/Grid');\n\nvar Events = require('./Events');\n\nvar Composite = require('../body/Composite');\n\nvar Constraint = require('../constraint/Constraint');\n\nvar Common = require('./Common');\n\nvar Body = require('../body/Body');\n\n(function () {\n  /**\r\n   * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n   * All properties have default values, and many are pre-calculated automatically based on other properties.\r\n   * See the properties section below for detailed information on what you can pass via the `options` object.\r\n   * @method create\r\n   * @param {object} [options]\r\n   * @return {engine} engine\r\n   */\n  Engine.create = function (element, options) {\n    // options may be passed as the first (and only) argument\n    options = Common.isElement(element) ? options : element;\n    element = Common.isElement(element) ? element : null;\n    options = options || {};\n\n    if (element || options.render) {\n      Common.warn('Engine.create: engine.render is deprecated (see docs)');\n    }\n\n    var defaults = {\n      positionIterations: 6,\n      velocityIterations: 4,\n      constraintIterations: 2,\n      enableSleeping: false,\n      events: [],\n      plugin: {},\n      timing: {\n        timestamp: 0,\n        timeScale: 1\n      },\n      broadphase: {\n        controller: Grid\n      }\n    };\n    var engine = Common.extend(defaults, options); // @deprecated\n\n    if (element || engine.render) {\n      var renderDefaults = {\n        element: element,\n        controller: Render\n      };\n      engine.render = Common.extend(renderDefaults, engine.render);\n    } // @deprecated\n\n\n    if (engine.render && engine.render.controller) {\n      engine.render = engine.render.controller.create(engine.render);\n    } // @deprecated\n\n\n    if (engine.render) {\n      engine.render.engine = engine;\n    }\n\n    engine.world = options.world || World.create(engine.world);\n    engine.pairs = Pairs.create();\n    engine.broadphase = engine.broadphase.controller.create(engine.broadphase);\n    engine.metrics = engine.metrics || {\n      extended: false\n    }; // @if DEBUG\n\n    engine.metrics = Metrics.create(engine.metrics); // @endif\n\n    return engine;\n  };\n  /**\r\n   * Moves the simulation forward in time by `delta` ms.\r\n   * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.\r\n   * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.\r\n   * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.\r\n   * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).\r\n   * See the paper on <a href=\"http://lonesock.net/article/verlet.html\">Time Corrected Verlet</a> for more information.\r\n   *\r\n   * Triggers `beforeUpdate` and `afterUpdate` events.\r\n   * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\r\n   * @method update\r\n   * @param {engine} engine\r\n   * @param {number} [delta=16.666]\r\n   * @param {number} [correction=1]\r\n   */\n\n\n  Engine.update = function (engine, delta, correction) {\n    delta = delta || 1000 / 60;\n    correction = correction || 1;\n    var world = engine.world,\n        timing = engine.timing,\n        broadphase = engine.broadphase,\n        broadphasePairs = [],\n        i; // increment timestamp\n\n    timing.timestamp += delta * timing.timeScale; // create an event object\n\n    var event = {\n      timestamp: timing.timestamp\n    };\n    Events.trigger(engine, 'beforeUpdate', event); // get lists of all bodies and constraints, no matter what composites they are in\n\n    var allBodies = Composite.allBodies(world),\n        allConstraints = Composite.allConstraints(world); // @if DEBUG\n    // reset metrics logging\n\n    Metrics.reset(engine.metrics); // @endif\n    // if sleeping enabled, call the sleeping controller\n\n    if (engine.enableSleeping) Sleeping.update(allBodies, timing.timeScale); // applies gravity to all bodies\n\n    Engine._bodiesApplyGravity(allBodies, world.gravity); // update all body position and rotation by integration\n\n\n    Engine._bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds); // update all constraints (first pass)\n\n\n    Constraint.preSolveAll(allBodies);\n\n    for (i = 0; i < engine.constraintIterations; i++) {\n      Constraint.solveAll(allConstraints, timing.timeScale);\n    }\n\n    Constraint.postSolveAll(allBodies); // broadphase pass: find potential collision pairs\n\n    if (broadphase.controller) {\n      // if world is dirty, we must flush the whole grid\n      if (world.isModified) broadphase.controller.clear(broadphase); // update the grid buckets based on current bodies\n\n      broadphase.controller.update(broadphase, allBodies, engine, world.isModified);\n      broadphasePairs = broadphase.pairsList;\n    } else {\n      // if no broadphase set, we just pass all bodies\n      broadphasePairs = allBodies;\n    } // clear all composite modified flags\n\n\n    if (world.isModified) {\n      Composite.setModified(world, false, false, true);\n    } // narrowphase pass: find actual collisions, then create or update collision pairs\n\n\n    var collisions = broadphase.detector(broadphasePairs, engine); // update collision pairs\n\n    var pairs = engine.pairs,\n        timestamp = timing.timestamp;\n    Pairs.update(pairs, collisions, timestamp);\n    Pairs.removeOld(pairs, timestamp); // wake up bodies involved in collisions\n\n    if (engine.enableSleeping) Sleeping.afterCollisions(pairs.list, timing.timeScale); // trigger collision events\n\n    if (pairs.collisionStart.length > 0) Events.trigger(engine, 'collisionStart', {\n      pairs: pairs.collisionStart\n    }); // iteratively resolve position between collisions\n\n    Resolver.preSolvePosition(pairs.list);\n\n    for (i = 0; i < engine.positionIterations; i++) {\n      Resolver.solvePosition(pairs.list, allBodies, timing.timeScale);\n    }\n\n    Resolver.postSolvePosition(allBodies); // update all constraints (second pass)\n\n    Constraint.preSolveAll(allBodies);\n\n    for (i = 0; i < engine.constraintIterations; i++) {\n      Constraint.solveAll(allConstraints, timing.timeScale);\n    }\n\n    Constraint.postSolveAll(allBodies); // iteratively resolve velocity between collisions\n\n    Resolver.preSolveVelocity(pairs.list);\n\n    for (i = 0; i < engine.velocityIterations; i++) {\n      Resolver.solveVelocity(pairs.list, timing.timeScale);\n    } // trigger collision events\n\n\n    if (pairs.collisionActive.length > 0) Events.trigger(engine, 'collisionActive', {\n      pairs: pairs.collisionActive\n    });\n    if (pairs.collisionEnd.length > 0) Events.trigger(engine, 'collisionEnd', {\n      pairs: pairs.collisionEnd\n    }); // @if DEBUG\n    // update metrics log\n\n    Metrics.update(engine.metrics, engine); // @endif\n    // clear force buffers\n\n    Engine._bodiesClearForces(allBodies);\n\n    Events.trigger(engine, 'afterUpdate', event);\n    return engine;\n  };\n  /**\r\n   * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.\r\n   * @method merge\r\n   * @param {engine} engineA\r\n   * @param {engine} engineB\r\n   */\n\n\n  Engine.merge = function (engineA, engineB) {\n    Common.extend(engineA, engineB);\n\n    if (engineB.world) {\n      engineA.world = engineB.world;\n      Engine.clear(engineA);\n      var bodies = Composite.allBodies(engineA.world);\n\n      for (var i = 0; i < bodies.length; i++) {\n        var body = bodies[i];\n        Sleeping.set(body, false);\n        body.id = Common.nextId();\n      }\n    }\n  };\n  /**\r\n   * Clears the engine including the world, pairs and broadphase.\r\n   * @method clear\r\n   * @param {engine} engine\r\n   */\n\n\n  Engine.clear = function (engine) {\n    var world = engine.world;\n    Pairs.clear(engine.pairs);\n    var broadphase = engine.broadphase;\n\n    if (broadphase.controller) {\n      var bodies = Composite.allBodies(world);\n      broadphase.controller.clear(broadphase);\n      broadphase.controller.update(broadphase, bodies, engine, true);\n    }\n  };\n  /**\r\n   * Zeroes the `body.force` and `body.torque` force buffers.\r\n   * @method _bodiesClearForces\r\n   * @private\r\n   * @param {body[]} bodies\r\n   */\n\n\n  Engine._bodiesClearForces = function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i]; // reset force buffers\n\n      body.force.x = 0;\n      body.force.y = 0;\n      body.torque = 0;\n    }\n  };\n  /**\r\n   * Applys a mass dependant force to all given bodies.\r\n   * @method _bodiesApplyGravity\r\n   * @private\r\n   * @param {body[]} bodies\r\n   * @param {vector} gravity\r\n   */\n\n\n  Engine._bodiesApplyGravity = function (bodies, gravity) {\n    var gravityScale = typeof gravity.scale !== 'undefined' ? gravity.scale : 0.001;\n\n    if (gravity.x === 0 && gravity.y === 0 || gravityScale === 0) {\n      return;\n    }\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i];\n      if (body.ignoreGravity || body.isStatic || body.isSleeping) continue; // apply gravity\n\n      body.force.y += body.mass * gravity.y * gravityScale;\n      body.force.x += body.mass * gravity.x * gravityScale;\n    }\n  };\n  /**\r\n   * Applys `Body.update` to all given `bodies`.\r\n   * @method _bodiesUpdate\r\n   * @private\r\n   * @param {body[]} bodies\r\n   * @param {number} deltaTime \r\n   * The amount of time elapsed between updates\r\n   * @param {number} timeScale\r\n   * @param {number} correction \r\n   * The Verlet correction factor (deltaTime / lastDeltaTime)\r\n   * @param {bounds} worldBounds\r\n   */\n\n\n  Engine._bodiesUpdate = function (bodies, deltaTime, timeScale, correction, worldBounds) {\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i];\n      if (body.isStatic || body.isSleeping) continue;\n      Body.update(body, deltaTime, timeScale, correction);\n    }\n  };\n  /**\r\n   * An alias for `Runner.run`, see `Matter.Runner` for more information.\r\n   * @method run\r\n   * @param {engine} engine\r\n   */\n\n  /**\r\n  * Fired just before an update\r\n  *\r\n  * @event beforeUpdate\r\n  * @param {} event An event object\r\n  * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired after engine update and all collision events\r\n  *\r\n  * @event afterUpdate\r\n  * @param {} event An event object\r\n  * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)\r\n  *\r\n  * @event collisionStart\r\n  * @param {} event An event object\r\n  * @param {} event.pairs List of affected pairs\r\n  * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)\r\n  *\r\n  * @event collisionActive\r\n  * @param {} event An event object\r\n  * @param {} event.pairs List of affected pairs\r\n  * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)\r\n  *\r\n  * @event collisionEnd\r\n  * @param {} event An event object\r\n  * @param {} event.pairs List of affected pairs\r\n  * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /*\r\n  *\r\n  *  Properties Documentation\r\n  *\r\n  */\n\n  /**\r\n   * An integer `Number` that specifies the number of position iterations to perform each update.\r\n   * The higher the value, the higher quality the simulation will be at the expense of performance.\r\n   *\r\n   * @property positionIterations\r\n   * @type number\r\n   * @default 6\r\n   */\n\n  /**\r\n   * An integer `Number` that specifies the number of velocity iterations to perform each update.\r\n   * The higher the value, the higher quality the simulation will be at the expense of performance.\r\n   *\r\n   * @property velocityIterations\r\n   * @type number\r\n   * @default 4\r\n   */\n\n  /**\r\n   * An integer `Number` that specifies the number of constraint iterations to perform each update.\r\n   * The higher the value, the higher quality the simulation will be at the expense of performance.\r\n   * The default value of `2` is usually very adequate.\r\n   *\r\n   * @property constraintIterations\r\n   * @type number\r\n   * @default 2\r\n   */\n\n  /**\r\n   * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.\r\n   * Sleeping can improve stability and performance, but often at the expense of accuracy.\r\n   *\r\n   * @property enableSleeping\r\n   * @type boolean\r\n   * @default false\r\n   */\n\n  /**\r\n   * An `Object` containing properties regarding the timing systems of the engine. \r\n   *\r\n   * @property timing\r\n   * @type object\r\n   */\n\n  /**\r\n   * A `Number` that specifies the global scaling factor of time for all bodies.\r\n   * A value of `0` freezes the simulation.\r\n   * A value of `0.1` gives a slow-motion effect.\r\n   * A value of `1.2` gives a speed-up effect.\r\n   *\r\n   * @property timing.timeScale\r\n   * @type number\r\n   * @default 1\r\n   */\n\n  /**\r\n   * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. \r\n   * It is incremented on every `Engine.update` by the given `delta` argument. \r\n   *\r\n   * @property timing.timestamp\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * An instance of a `Render` controller. The default value is a `Matter.Render` instance created by `Engine.create`.\r\n   * One may also develop a custom renderer module based on `Matter.Render` and pass an instance of it to `Engine.create` via `options.render`.\r\n   *\r\n   * A minimal custom renderer object must define at least three functions: `create`, `clear` and `world` (see `Matter.Render`).\r\n   * It is also possible to instead pass the _module_ reference via `options.render.controller` and `Engine.create` will instantiate one for you.\r\n   *\r\n   * @property render\r\n   * @type render\r\n   * @deprecated see Demo.js for an example of creating a renderer\r\n   * @default a Matter.Render instance\r\n   */\n\n  /**\r\n   * An instance of a broadphase controller. The default value is a `Matter.Grid` instance created by `Engine.create`.\r\n   *\r\n   * @property broadphase\r\n   * @type grid\r\n   * @default a Matter.Grid instance\r\n   */\n\n  /**\r\n   * A `World` composite object that will contain all simulated bodies and constraints.\r\n   *\r\n   * @property world\r\n   * @type world\r\n   * @default a Matter.World instance\r\n   */\n\n  /**\r\n   * An object reserved for storing plugin-specific properties.\r\n   *\r\n   * @property plugin\r\n   * @type {}\r\n   */\n\n})();","map":null,"metadata":{},"sourceType":"script"}