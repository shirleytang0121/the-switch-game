{"ast":null,"code":"/**\r\n* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.\r\n*\r\n* @class Sleeping\r\n*/\nvar Sleeping = {};\nmodule.exports = Sleeping;\n\nvar Events = require('./Events');\n\n(function () {\n  Sleeping._motionWakeThreshold = 0.18;\n  Sleeping._motionSleepThreshold = 0.08;\n  Sleeping._minBias = 0.9;\n  /**\r\n   * Puts bodies to sleep or wakes them up depending on their motion.\r\n   * @method update\r\n   * @param {body[]} bodies\r\n   * @param {number} timeScale\r\n   */\n\n  Sleeping.update = function (bodies, timeScale) {\n    var timeFactor = timeScale * timeScale * timeScale; // update bodies sleeping status\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i],\n          motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed; // wake up bodies if they have a force applied\n\n      if (body.force.x !== 0 || body.force.y !== 0) {\n        Sleeping.set(body, false);\n        continue;\n      }\n\n      var minMotion = Math.min(body.motion, motion),\n          maxMotion = Math.max(body.motion, motion); // biased average motion estimation between frames\n\n      body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;\n\n      if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {\n        body.sleepCounter += 1;\n        if (body.sleepCounter >= body.sleepThreshold) Sleeping.set(body, true);\n      } else if (body.sleepCounter > 0) {\n        body.sleepCounter -= 1;\n      }\n    }\n  };\n  /**\r\n   * Given a set of colliding pairs, wakes the sleeping bodies involved.\r\n   * @method afterCollisions\r\n   * @param {pair[]} pairs\r\n   * @param {number} timeScale\r\n   */\n\n\n  Sleeping.afterCollisions = function (pairs, timeScale) {\n    var timeFactor = timeScale * timeScale * timeScale; // wake up bodies involved in collisions\n\n    for (var i = 0; i < pairs.length; i++) {\n      var pair = pairs[i]; // don't wake inactive pairs\n\n      if (!pair.isActive) continue;\n      var collision = pair.collision,\n          bodyA = collision.bodyA.parent,\n          bodyB = collision.bodyB.parent; // don't wake if at least one body is static\n\n      if (bodyA.isSleeping && bodyB.isSleeping || bodyA.isStatic || bodyB.isStatic) continue;\n\n      if (bodyA.isSleeping || bodyB.isSleeping) {\n        var sleepingBody = bodyA.isSleeping && !bodyA.isStatic ? bodyA : bodyB,\n            movingBody = sleepingBody === bodyA ? bodyB : bodyA;\n\n        if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {\n          Sleeping.set(sleepingBody, false);\n        }\n      }\n    }\n  };\n  /**\r\n   * Set a body as sleeping or awake.\r\n   * @method set\r\n   * @param {body} body\r\n   * @param {boolean} isSleeping\r\n   */\n\n\n  Sleeping.set = function (body, isSleeping) {\n    var wasSleeping = body.isSleeping;\n\n    if (isSleeping) {\n      body.isSleeping = true;\n      body.sleepCounter = body.sleepThreshold;\n      body.positionImpulse.x = 0;\n      body.positionImpulse.y = 0;\n      body.positionPrev.x = body.position.x;\n      body.positionPrev.y = body.position.y;\n      body.anglePrev = body.angle;\n      body.speed = 0;\n      body.angularSpeed = 0;\n      body.motion = 0;\n\n      if (!wasSleeping) {\n        Events.trigger(body, 'sleepStart');\n      }\n    } else {\n      body.isSleeping = false;\n      body.sleepCounter = 0;\n\n      if (wasSleeping) {\n        Events.trigger(body, 'sleepEnd');\n      }\n    }\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}