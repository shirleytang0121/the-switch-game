{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar CONST = require('./const');\n\nvar DefaultPlugins = require('../plugins/DefaultPlugins');\n\nvar Events = require('./events');\n\nvar GetPhysicsPlugins = require('./GetPhysicsPlugins');\n\nvar GetScenePlugins = require('./GetScenePlugins');\n\nvar NOOP = require('../utils/NOOP');\n\nvar Settings = require('./Settings');\n/**\r\n * @classdesc\r\n * The Scene Systems class.\r\n *\r\n * This class is available from within a Scene under the property `sys`.\r\n * It is responsible for managing all of the plugins a Scene has running, including the display list, and\r\n * handling the update step and renderer. It also contains references to global systems belonging to Game.\r\n *\r\n * @class Systems\r\n * @memberof Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that owns this Systems instance.\r\n * @param {(string|Phaser.Scenes.Settings.Config)} config - Scene specific configuration settings.\r\n */\n\n\nvar Systems = new Class({\n  initialize: function Systems(scene, config) {\n    /**\r\n     * A reference to the Scene that these Systems belong to.\r\n     *\r\n     * @name Phaser.Scenes.Systems#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n    this.scene = scene;\n    /**\r\n     * A reference to the Phaser Game instance.\r\n     *\r\n     * @name Phaser.Scenes.Systems#game\r\n     * @type {Phaser.Game}\r\n     * @since 3.0.0\r\n     */\n\n    this.game;\n\n    if (typeof PLUGIN_FBINSTANT) {\n      /**\r\n       * The Facebook Instant Games Plugin.\r\n       *\r\n       * @name Phaser.Scenes.Systems#facebook\r\n       * @type {Phaser.FacebookInstantGamesPlugin}\r\n       * @since 3.12.0\r\n       */\n      this.facebook;\n    }\n    /**\r\n     * The Scene Configuration object, as passed in when creating the Scene.\r\n     *\r\n     * @name Phaser.Scenes.Systems#config\r\n     * @type {(string|Phaser.Scenes.Settings.Config)}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.config = config;\n    /**\r\n     * The Scene Settings. This is the parsed output based on the Scene configuration.\r\n     *\r\n     * @name Phaser.Scenes.Systems#settings\r\n     * @type {Phaser.Scenes.Settings.Object}\r\n     * @since 3.0.0\r\n     */\n\n    this.settings = Settings.create(config);\n    /**\r\n     * A handy reference to the Scene canvas / context.\r\n     *\r\n     * @name Phaser.Scenes.Systems#canvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.0.0\r\n     */\n\n    this.canvas;\n    /**\r\n     * A reference to the Canvas Rendering Context being used by the renderer.\r\n     *\r\n     * @name Phaser.Scenes.Systems#context\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.0.0\r\n     */\n\n    this.context; //  Global Systems - these are single-instance global managers that belong to Game\n\n    /**\r\n     * A reference to the global Animations Manager.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.anims` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#anims\r\n     * @type {Phaser.Animations.AnimationManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.anims;\n    /**\r\n     * A reference to the global Cache. The Cache stores all files bought in to Phaser via\r\n     * the Loader, with the exception of images. Images are stored in the Texture Manager.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.cache` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#cache\r\n     * @type {Phaser.Cache.CacheManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.cache;\n    /**\r\n     * A reference to the global Plugins Manager.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.plugins` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#plugins\r\n     * @type {Phaser.Plugins.PluginManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.plugins;\n    /**\r\n     * A reference to the global registry. This is a game-wide instance of the Data Manager, allowing\r\n     * you to exchange data between Scenes via a universal and shared point.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.registry` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#registry\r\n     * @type {Phaser.Data.DataManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.registry;\n    /**\r\n     * A reference to the global Scale Manager.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.scale` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#scale\r\n     * @type {Phaser.Scale.ScaleManager}\r\n     * @since 3.15.0\r\n     */\n\n    this.scale;\n    /**\r\n     * A reference to the global Sound Manager.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.sound` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#sound\r\n     * @type {Phaser.Sound.BaseSoundManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.sound;\n    /**\r\n     * A reference to the global Texture Manager.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.textures` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#textures\r\n     * @type {Phaser.Textures.TextureManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.textures; //  Core Plugins - these are non-optional Scene plugins, needed by lots of the other systems\n\n    /**\r\n     * A reference to the Scene's Game Object Factory.\r\n     * \r\n     * Use this to quickly and easily create new Game Object's.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.add` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#add\r\n     * @type {Phaser.GameObjects.GameObjectFactory}\r\n     * @since 3.0.0\r\n     */\n\n    this.add;\n    /**\r\n     * A reference to the Scene's Camera Manager.\r\n     * \r\n     * Use this to manipulate and create Cameras for this specific Scene.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.cameras` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#cameras\r\n     * @type {Phaser.Cameras.Scene2D.CameraManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.cameras;\n    /**\r\n     * A reference to the Scene's Display List.\r\n     * \r\n     * Use this to organize the children contained in the display list.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.children` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#displayList\r\n     * @type {Phaser.GameObjects.DisplayList}\r\n     * @since 3.0.0\r\n     */\n\n    this.displayList;\n    /**\r\n     * A reference to the Scene's Event Manager.\r\n     * \r\n     * Use this to listen for Scene specific events, such as `pause` and `shutdown`.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.events` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#events\r\n     * @type {Phaser.Events.EventEmitter}\r\n     * @since 3.0.0\r\n     */\n\n    this.events;\n    /**\r\n     * A reference to the Scene's Game Object Creator.\r\n     * \r\n     * Use this to quickly and easily create new Game Object's. The difference between this and the\r\n     * Game Object Factory, is that the Creator just creates and returns Game Object instances, it\r\n     * doesn't then add them to the Display List or Update List.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.make` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#make\r\n     * @type {Phaser.GameObjects.GameObjectCreator}\r\n     * @since 3.0.0\r\n     */\n\n    this.make;\n    /**\r\n     * A reference to the Scene Manager Plugin.\r\n     * \r\n     * Use this to manipulate both this and other Scene's in your game, for example to launch a parallel Scene,\r\n     * or pause or resume a Scene, or switch from this Scene to another.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.scene` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#scenePlugin\r\n     * @type {Phaser.Scenes.ScenePlugin}\r\n     * @since 3.0.0\r\n     */\n\n    this.scenePlugin;\n    /**\r\n     * A reference to the Scene's Update List.\r\n     * \r\n     * Use this to organize the children contained in the update list.\r\n     * \r\n     * The Update List is responsible for managing children that need their `preUpdate` methods called,\r\n     * in order to process so internal components, such as Sprites with Animations.\r\n     * \r\n     * In the default set-up there is no reference to this from within the Scene itself.\r\n     *\r\n     * @name Phaser.Scenes.Systems#updateList\r\n     * @type {Phaser.GameObjects.UpdateList}\r\n     * @since 3.0.0\r\n     */\n\n    this.updateList;\n    /**\r\n     * The Scene Update function.\r\n     *\r\n     * This starts out as NOOP during init, preload and create, and at the end of create\r\n     * it swaps to be whatever the Scene.update function is.\r\n     *\r\n     * @name Phaser.Scenes.Systems#sceneUpdate\r\n     * @type {function}\r\n     * @private\r\n     * @since 3.10.0\r\n     */\n\n    this.sceneUpdate = NOOP;\n  },\n\n  /**\r\n   * This method is called only once by the Scene Manager when the Scene is instantiated.\r\n   * It is responsible for setting up all of the Scene plugins and references.\r\n   * It should never be called directly.\r\n   *\r\n   * @method Phaser.Scenes.Systems#init\r\n   * @protected\r\n   * @fires Phaser.Scenes.Events#BOOT\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Game} game - A reference to the Phaser Game instance.\r\n   */\n  init: function init(game) {\n    this.settings.status = CONST.INIT; //  This will get replaced by the SceneManager with the actual update function, if it exists, once create is over.\n\n    this.sceneUpdate = NOOP;\n    this.game = game;\n    this.canvas = game.canvas;\n    this.context = game.context;\n    var pluginManager = game.plugins;\n    this.plugins = pluginManager;\n    pluginManager.addToScene(this, DefaultPlugins.Global, [DefaultPlugins.CoreScene, GetScenePlugins(this), GetPhysicsPlugins(this)]);\n    this.events.emit(Events.BOOT, this);\n    this.settings.isBooted = true;\n  },\n\n  /**\r\n   * Called by a plugin, it tells the System to install the plugin locally.\r\n   *\r\n   * @method Phaser.Scenes.Systems#install\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {array} plugin - An array of plugins to install into this Scene.\r\n   */\n  install: function install(plugin) {\n    if (!Array.isArray(plugin)) {\n      plugin = [plugin];\n    }\n\n    this.plugins.installLocal(this, plugin);\n  },\n\n  /**\r\n   * A single game step. Called automatically by the Scene Manager as a result of a Request Animation\r\n   * Frame or Set Timeout call to the main Game instance.\r\n   *\r\n   * @method Phaser.Scenes.Systems#step\r\n   * @fires Phaser.Scenes.Events#PRE_UPDATE\r\n   * @fires Phaser.Scenes.Events#_UPDATE\r\n   * @fires Phaser.Scenes.Events#POST_UPDATE\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} time - The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().\r\n   * @param {number} delta - The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.\r\n   */\n  step: function step(time, delta) {\n    this.events.emit(Events.PRE_UPDATE, time, delta);\n    this.events.emit(Events.UPDATE, time, delta);\n    this.sceneUpdate.call(this.scene, time, delta);\n    this.events.emit(Events.POST_UPDATE, time, delta);\n  },\n\n  /**\r\n   * Called automatically by the Scene Manager.\r\n   * Instructs the Scene to render itself via its Camera Manager to the renderer given.\r\n   *\r\n   * @method Phaser.Scenes.Systems#render\r\n   * @fires Phaser.Scenes.Events#RENDER\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer that invoked the render call.\r\n   */\n  render: function render(renderer) {\n    var displayList = this.displayList;\n    displayList.depthSort();\n    this.cameras.render(renderer, displayList);\n    this.events.emit(Events.RENDER, renderer);\n  },\n\n  /**\r\n   * Force a sort of the display list on the next render.\r\n   *\r\n   * @method Phaser.Scenes.Systems#queueDepthSort\r\n   * @since 3.0.0\r\n   */\n  queueDepthSort: function queueDepthSort() {\n    this.displayList.queueDepthSort();\n  },\n\n  /**\r\n   * Immediately sorts the display list if the flag is set.\r\n   *\r\n   * @method Phaser.Scenes.Systems#depthSort\r\n   * @since 3.0.0\r\n   */\n  depthSort: function depthSort() {\n    this.displayList.depthSort();\n  },\n\n  /**\r\n   * Pause this Scene.\r\n   * A paused Scene still renders, it just doesn't run ANY of its update handlers or systems.\r\n   *\r\n   * @method Phaser.Scenes.Systems#pause\r\n   * @fires Phaser.Scenes.Events#PAUSE\r\n   * @since 3.0.0\r\n   * \r\n   * @param {object} [data] - A data object that will be passed in the 'pause' event.\r\n   *\r\n   * @return {Phaser.Scenes.Systems} This Systems object.\r\n   */\n  pause: function pause(data) {\n    if (this.settings.active) {\n      this.settings.status = CONST.PAUSED;\n      this.settings.active = false;\n      this.events.emit(Events.PAUSE, this, data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Resume this Scene from a paused state.\r\n   *\r\n   * @method Phaser.Scenes.Systems#resume\r\n   * @fires Phaser.Scenes.Events#RESUME\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} [data] - A data object that will be passed in the 'resume' event.\r\n   *\r\n   * @return {Phaser.Scenes.Systems} This Systems object.\r\n   */\n  resume: function resume(data) {\n    if (!this.settings.active) {\n      this.settings.status = CONST.RUNNING;\n      this.settings.active = true;\n      this.events.emit(Events.RESUME, this, data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Send this Scene to sleep.\r\n   *\r\n   * A sleeping Scene doesn't run it's update step or render anything, but it also isn't shut down\r\n   * or have any of its systems or children removed, meaning it can be re-activated at any point and\r\n   * will carry on from where it left off. It also keeps everything in memory and events and callbacks\r\n   * from other Scenes may still invoke changes within it, so be careful what is left active.\r\n   *\r\n   * @method Phaser.Scenes.Systems#sleep\r\n   * @fires Phaser.Scenes.Events#SLEEP\r\n   * @since 3.0.0\r\n   * \r\n   * @param {object} [data] - A data object that will be passed in the 'sleep' event.\r\n   *\r\n   * @return {Phaser.Scenes.Systems} This Systems object.\r\n   */\n  sleep: function sleep(data) {\n    this.settings.status = CONST.SLEEPING;\n    this.settings.active = false;\n    this.settings.visible = false;\n    this.events.emit(Events.SLEEP, this, data);\n    return this;\n  },\n\n  /**\r\n   * Wake-up this Scene if it was previously asleep.\r\n   *\r\n   * @method Phaser.Scenes.Systems#wake\r\n   * @fires Phaser.Scenes.Events#WAKE\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} [data] - A data object that will be passed in the 'wake' event.\r\n   *\r\n   * @return {Phaser.Scenes.Systems} This Systems object.\r\n   */\n  wake: function wake(data) {\n    var settings = this.settings;\n    settings.status = CONST.RUNNING;\n    settings.active = true;\n    settings.visible = true;\n    this.events.emit(Events.WAKE, this, data);\n\n    if (settings.isTransition) {\n      this.events.emit(Events.TRANSITION_WAKE, settings.transitionFrom, settings.transitionDuration);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Is this Scene sleeping?\r\n   *\r\n   * @method Phaser.Scenes.Systems#isSleeping\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` if this Scene is asleep, otherwise `false`.\r\n   */\n  isSleeping: function isSleeping() {\n    return this.settings.status === CONST.SLEEPING;\n  },\n\n  /**\r\n   * Is this Scene active?\r\n   *\r\n   * @method Phaser.Scenes.Systems#isActive\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` if this Scene is active, otherwise `false`.\r\n   */\n  isActive: function isActive() {\n    return this.settings.status === CONST.RUNNING;\n  },\n\n  /**\r\n   * Is this Scene paused?\r\n   *\r\n   * @method Phaser.Scenes.Systems#isPaused\r\n   * @since 3.13.0\r\n   *\r\n   * @return {boolean} `true` if this Scene is paused, otherwise `false`.\r\n   */\n  isPaused: function isPaused() {\n    return this.settings.status === CONST.PAUSED;\n  },\n\n  /**\r\n   * Is this Scene currently transitioning out to, or in from another Scene?\r\n   *\r\n   * @method Phaser.Scenes.Systems#isTransitioning\r\n   * @since 3.5.0\r\n   *\r\n   * @return {boolean} `true` if this Scene is currently transitioning, otherwise `false`.\r\n   */\n  isTransitioning: function isTransitioning() {\n    return this.settings.isTransition || this.scenePlugin._target !== null;\n  },\n\n  /**\r\n   * Is this Scene currently transitioning out from itself to another Scene?\r\n   *\r\n   * @method Phaser.Scenes.Systems#isTransitionOut\r\n   * @since 3.5.0\r\n   *\r\n   * @return {boolean} `true` if this Scene is in transition to another Scene, otherwise `false`.\r\n   */\n  isTransitionOut: function isTransitionOut() {\n    return this.scenePlugin._target !== null && this.scenePlugin._duration > 0;\n  },\n\n  /**\r\n   * Is this Scene currently transitioning in from another Scene?\r\n   *\r\n   * @method Phaser.Scenes.Systems#isTransitionIn\r\n   * @since 3.5.0\r\n   *\r\n   * @return {boolean} `true` if this Scene is transitioning in from another Scene, otherwise `false`.\r\n   */\n  isTransitionIn: function isTransitionIn() {\n    return this.settings.isTransition;\n  },\n\n  /**\r\n   * Is this Scene visible and rendering?\r\n   *\r\n   * @method Phaser.Scenes.Systems#isVisible\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` if this Scene is visible, otherwise `false`.\r\n   */\n  isVisible: function isVisible() {\n    return this.settings.visible;\n  },\n\n  /**\r\n   * Sets the visible state of this Scene.\r\n   * An invisible Scene will not render, but will still process updates.\r\n   *\r\n   * @method Phaser.Scenes.Systems#setVisible\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - `true` to render this Scene, otherwise `false`.\r\n   *\r\n   * @return {Phaser.Scenes.Systems} This Systems object.\r\n   */\n  setVisible: function setVisible(value) {\n    this.settings.visible = value;\n    return this;\n  },\n\n  /**\r\n   * Set the active state of this Scene.\r\n   * \r\n   * An active Scene will run its core update loop.\r\n   *\r\n   * @method Phaser.Scenes.Systems#setActive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - If `true` the Scene will be resumed, if previously paused. If `false` it will be paused.\r\n   * @param {object} [data] - A data object that will be passed in the 'resume' or 'pause' events.\r\n   *\r\n   * @return {Phaser.Scenes.Systems} This Systems object.\r\n   */\n  setActive: function setActive(value, data) {\n    if (value) {\n      return this.resume(data);\n    } else {\n      return this.pause(data);\n    }\n  },\n\n  /**\r\n   * Start this Scene running and rendering.\r\n   * Called automatically by the SceneManager.\r\n   *\r\n   * @method Phaser.Scenes.Systems#start\r\n   * @fires Phaser.Scenes.Events#START\r\n   * @fires Phaser.Scenes.Events#READY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} data - Optional data object that may have been passed to this Scene from another.\r\n   */\n  start: function start(data) {\n    if (data) {\n      this.settings.data = data;\n    }\n\n    this.settings.status = CONST.START;\n    this.settings.active = true;\n    this.settings.visible = true; //  For plugins to listen out for\n\n    this.events.emit(Events.START, this); //  For user-land code to listen out for\n\n    this.events.emit(Events.READY, this, data);\n  },\n\n  /**\r\n   * Shutdown this Scene and send a shutdown event to all of its systems.\r\n   * A Scene that has been shutdown will not run its update loop or render, but it does\r\n   * not destroy any of its plugins or references. It is put into hibernation for later use.\r\n   * If you don't ever plan to use this Scene again, then it should be destroyed instead\r\n   * to free-up resources.\r\n   *\r\n   * @method Phaser.Scenes.Systems#shutdown\r\n   * @fires Phaser.Scenes.Events#SHUTDOWN\r\n   * @since 3.0.0\r\n   * \r\n   * @param {object} [data] - A data object that will be passed in the 'shutdown' event.\r\n   */\n  shutdown: function shutdown(data) {\n    this.events.off(Events.TRANSITION_INIT);\n    this.events.off(Events.TRANSITION_START);\n    this.events.off(Events.TRANSITION_COMPLETE);\n    this.events.off(Events.TRANSITION_OUT);\n    this.settings.status = CONST.SHUTDOWN;\n    this.settings.active = false;\n    this.settings.visible = false;\n    this.events.emit(Events.SHUTDOWN, this, data);\n  },\n\n  /**\r\n   * Destroy this Scene and send a destroy event all of its systems.\r\n   * A destroyed Scene cannot be restarted.\r\n   * You should not call this directly, instead use `SceneManager.remove`.\r\n   *\r\n   * @method Phaser.Scenes.Systems#destroy\r\n   * @private\r\n   * @fires Phaser.Scenes.Events#DESTROY\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    this.settings.status = CONST.DESTROYED;\n    this.settings.active = false;\n    this.settings.visible = false;\n    this.events.emit(Events.DESTROY, this);\n    this.events.removeAllListeners();\n    var props = ['scene', 'game', 'anims', 'cache', 'plugins', 'registry', 'sound', 'textures', 'add', 'camera', 'displayList', 'events', 'make', 'scenePlugin', 'updateList'];\n\n    for (var i = 0; i < props.length; i++) {\n      this[props[i]] = null;\n    }\n  }\n});\nmodule.exports = Systems;","map":null,"metadata":{},"sourceType":"script"}