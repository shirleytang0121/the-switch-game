{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\n//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\nvar CatmullRom = require('../math/CatmullRom');\n\nvar Class = require('../utils/Class');\n\nvar Curve = require('./Curve');\n\nvar Vector2 = require('../math/Vector2');\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Spline\r\n * @extends Phaser.Curves.Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Vector2[]} [points] - [description]\r\n */\n\n\nvar SplineCurve = new Class({\n  Extends: Curve,\n  initialize: function SplineCurve(points) {\n    if (points === undefined) {\n      points = [];\n    }\n\n    Curve.call(this, 'SplineCurve');\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Curves.Spline#points\r\n     * @type {Phaser.Math.Vector2[]}\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this.points = [];\n    this.addPoints(points);\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Spline#addPoints\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Math.Vector2[]|number[]|number[][])} points - [description]\r\n   *\r\n   * @return {Phaser.Curves.Spline} This curve object.\r\n   */\n  addPoints: function addPoints(points) {\n    for (var i = 0; i < points.length; i++) {\n      var p = new Vector2();\n\n      if (typeof points[i] === 'number') {\n        p.x = points[i];\n        p.y = points[i + 1];\n        i++;\n      } else if (Array.isArray(points[i])) {\n        //  An array of arrays?\n        p.x = points[i][0];\n        p.y = points[i][1];\n      } else {\n        p.x = points[i].x;\n        p.y = points[i].y;\n      }\n\n      this.points.push(p);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Spline#addPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   *\r\n   * @return {Phaser.Math.Vector2} [description]\r\n   */\n  addPoint: function addPoint(x, y) {\n    var vec = new Vector2(x, y);\n    this.points.push(vec);\n    return vec;\n  },\n\n  /**\r\n   * Gets the starting point on the curve.\r\n   *\r\n   * @method Phaser.Curves.Spline#getStartPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n   */\n  getStartPoint: function getStartPoint(out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    return out.copy(this.points[0]);\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Spline#getResolution\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} divisions - [description]\r\n   *\r\n   * @return {number} [description]\r\n   */\n  getResolution: function getResolution(divisions) {\n    return divisions * this.points.length;\n  },\n\n  /**\r\n   * Get point at relative position in curve according to length.\r\n   *\r\n   * @method Phaser.Curves.Spline#getPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n   * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n   */\n  getPoint: function getPoint(t, out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    var points = this.points;\n    var point = (points.length - 1) * t;\n    var intPoint = Math.floor(point);\n    var weight = point - intPoint;\n    var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];\n    var p1 = points[intPoint];\n    var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];\n    var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];\n    return out.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Spline#toJSON\r\n   * @since 3.0.0\r\n   *\r\n   * @return {JSONCurve} The JSON object containing this curve data.\r\n   */\n  toJSON: function toJSON() {\n    var points = [];\n\n    for (var i = 0; i < this.points.length; i++) {\n      points.push(this.points[i].x);\n      points.push(this.points[i].y);\n    }\n\n    return {\n      type: this.type,\n      points: points\n    };\n  }\n});\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Curves.Spline.fromJSON\r\n * @since 3.0.0\r\n *\r\n * @param {JSONCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.Spline} [description]\r\n */\n\nSplineCurve.fromJSON = function (data) {\n  return new SplineCurve(data.points);\n};\n\nmodule.exports = SplineCurve;","map":null,"metadata":{},"sourceType":"script"}