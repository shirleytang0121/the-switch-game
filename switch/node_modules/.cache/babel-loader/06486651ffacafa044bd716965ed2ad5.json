{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar GameObjectCreator = require('../../gameobjects/GameObjectCreator');\n\nvar GameObjectFactory = require('../../gameobjects/GameObjectFactory');\n\nvar TWEEN_CONST = require('./const');\n/**\r\n * @classdesc\r\n * A Tween is able to manipulate the properties of one or more objects to any given value, based\r\n * on a duration and type of ease. They are rarely instantiated directly and instead should be\r\n * created via the TweenManager.\r\n *\r\n * @class Tween\r\n * @memberof Phaser.Tweens\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Tweens.TweenManager|Phaser.Tweens.Timeline)} parent - A reference to the parent of this Tween. Either the Tween Manager or a Tween Timeline instance.\r\n * @param {Phaser.Tweens.TweenDataConfig[]} data - An array of TweenData objects, each containing a unique property to be tweened.\r\n * @param {array} targets - An array of targets to be tweened.\r\n */\n\n\nvar Tween = new Class({\n  initialize: function Tween(parent, data, targets) {\n    /**\r\n     * A reference to the parent of this Tween.\r\n     * Either the Tween Manager or a Tween Timeline instance.\r\n     *\r\n     * @name Phaser.Tweens.Tween#parent\r\n     * @type {(Phaser.Tweens.TweenManager|Phaser.Tweens.Timeline)}\r\n     * @since 3.0.0\r\n     */\n    this.parent = parent;\n    /**\r\n     * Is the parent of this Tween a Timeline?\r\n     *\r\n     * @name Phaser.Tweens.Tween#parentIsTimeline\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.parentIsTimeline = parent.hasOwnProperty('isTimeline');\n    /**\r\n     * An array of TweenData objects, each containing a unique property and target being tweened.\r\n     *\r\n     * @name Phaser.Tweens.Tween#data\r\n     * @type {Phaser.Tweens.TweenDataConfig[]}\r\n     * @since 3.0.0\r\n     */\n\n    this.data = data;\n    /**\r\n     * The cached length of the data array.\r\n     *\r\n     * @name Phaser.Tweens.Tween#totalData\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.totalData = data.length;\n    /**\r\n     * An array of references to the target/s this Tween is operating on.\r\n     *\r\n     * @name Phaser.Tweens.Tween#targets\r\n     * @type {object[]}\r\n     * @since 3.0.0\r\n     */\n\n    this.targets = targets;\n    /**\r\n     * Cached target total (not necessarily the same as the data total)\r\n     *\r\n     * @name Phaser.Tweens.Tween#totalTargets\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.totalTargets = targets.length;\n    /**\r\n     * If `true` then duration, delay, etc values are all frame totals.\r\n     *\r\n     * @name Phaser.Tweens.Tween#useFrames\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.useFrames = false;\n    /**\r\n     * Scales the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.\r\n     * Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.\r\n     *\r\n     * @name Phaser.Tweens.Tween#timeScale\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\n\n    this.timeScale = 1;\n    /**\r\n     * Loop this tween? Can be -1 for an infinite loop, or an integer.\r\n     * When enabled it will play through ALL TweenDatas again. Use TweenData.repeat to loop a single element.\r\n     *\r\n     * @name Phaser.Tweens.Tween#loop\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.loop = 0;\n    /**\r\n     * Time in ms/frames before the tween loops.\r\n     *\r\n     * @name Phaser.Tweens.Tween#loopDelay\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.loopDelay = 0;\n    /**\r\n     * How many loops are left to run?\r\n     *\r\n     * @name Phaser.Tweens.Tween#loopCounter\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.loopCounter = 0;\n    /**\r\n     * Time in ms/frames before the 'onComplete' event fires. This never fires if loop = -1 (as it never completes)\r\n     *\r\n     * @name Phaser.Tweens.Tween#completeDelay\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.completeDelay = 0;\n    /**\r\n     * Countdown timer (used by timeline offset, loopDelay and completeDelay)\r\n     *\r\n     * @name Phaser.Tweens.Tween#countdown\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.countdown = 0;\n    /**\r\n     * Set only if this Tween is part of a Timeline.\r\n     *\r\n     * @name Phaser.Tweens.Tween#offset\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.offset = 0;\n    /**\r\n     * Set only if this Tween is part of a Timeline. The calculated offset amount.\r\n     *\r\n     * @name Phaser.Tweens.Tween#calculatedOffset\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.calculatedOffset = 0;\n    /**\r\n     * The current state of the tween\r\n     *\r\n     * @name Phaser.Tweens.Tween#state\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.state = TWEEN_CONST.PENDING_ADD;\n    /**\r\n     * The state of the tween when it was paused (used by Resume)\r\n     *\r\n     * @name Phaser.Tweens.Tween#_pausedState\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._pausedState = TWEEN_CONST.PENDING_ADD;\n    /**\r\n     * Does the Tween start off paused? (if so it needs to be started with Tween.play)\r\n     *\r\n     * @name Phaser.Tweens.Tween#paused\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.paused = false;\n    /**\r\n     * Elapsed time in ms/frames of this run through the Tween.\r\n     *\r\n     * @name Phaser.Tweens.Tween#elapsed\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.elapsed = 0;\n    /**\r\n     * Total elapsed time in ms/frames of the entire Tween, including looping.\r\n     *\r\n     * @name Phaser.Tweens.Tween#totalElapsed\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.totalElapsed = 0;\n    /**\r\n     * Time in ms/frames for the whole Tween to play through once, excluding loop amounts and loop delays.\r\n     *\r\n     * @name Phaser.Tweens.Tween#duration\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.duration = 0;\n    /**\r\n     * Value between 0 and 1. The amount through the Tween, excluding loops.\r\n     *\r\n     * @name Phaser.Tweens.Tween#progress\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.progress = 0;\n    /**\r\n     * Time in ms/frames for the Tween to complete (including looping)\r\n     *\r\n     * @name Phaser.Tweens.Tween#totalDuration\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.totalDuration = 0;\n    /**\r\n     * Value between 0 and 1. The amount through the entire Tween, including looping.\r\n     *\r\n     * @name Phaser.Tweens.Tween#totalProgress\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.totalProgress = 0;\n    /**\r\n     * An object containing the various Tween callback references.\r\n     *\r\n     * @name Phaser.Tweens.Tween#callbacks\r\n     * @type {object}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.callbacks = {\n      onComplete: null,\n      onLoop: null,\n      onRepeat: null,\n      onStart: null,\n      onUpdate: null,\n      onYoyo: null\n    };\n    this.callbackScope;\n  },\n\n  /**\r\n   * Returns the current value of the Tween.\r\n   *\r\n   * @method Phaser.Tweens.Tween#getValue\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The value of the Tween.\r\n   */\n  getValue: function getValue() {\n    return this.data[0].current;\n  },\n\n  /**\r\n   * Set the scale the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.\r\n   *\r\n   * @method Phaser.Tweens.Tween#setTimeScale\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The scale factor for timescale.\r\n   *\r\n   * @return {this} - This Tween instance.\r\n   */\n  setTimeScale: function setTimeScale(value) {\n    this.timeScale = value;\n    return this;\n  },\n\n  /**\r\n   * Returns the scale of the time applied to this Tween.\r\n   *\r\n   * @method Phaser.Tweens.Tween#getTimeScale\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The timescale of this tween (between 0 and 1)\r\n   */\n  getTimeScale: function getTimeScale() {\n    return this.timeScale;\n  },\n\n  /**\r\n   * Checks if the Tween is currently active.\r\n   *\r\n   * @method Phaser.Tweens.Tween#isPlaying\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` if the Tween is active, otherwise `false`.\r\n   */\n  isPlaying: function isPlaying() {\n    return this.state === TWEEN_CONST.ACTIVE;\n  },\n\n  /**\r\n   * Checks if the Tween is currently paused.\r\n   *\r\n   * @method Phaser.Tweens.Tween#isPaused\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` if the Tween is paused, otherwise `false`.\r\n   */\n  isPaused: function isPaused() {\n    return this.state === TWEEN_CONST.PAUSED;\n  },\n\n  /**\r\n   * See if this Tween is currently acting upon the given target.\r\n   *\r\n   * @method Phaser.Tweens.Tween#hasTarget\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} target - The target to check against this Tween.\r\n   *\r\n   * @return {boolean} `true` if the given target is a target of this Tween, otherwise `false`.\r\n   */\n  hasTarget: function hasTarget(target) {\n    return this.targets.indexOf(target) !== -1;\n  },\n\n  /**\r\n   * Updates the value of a property of this Tween to a new value, without adjusting the\r\n   * Tween duration or current progress.\r\n   * \r\n   * You can optionally tell it to set the 'start' value to be the current value (before the change).\r\n   *\r\n   * @method Phaser.Tweens.Tween#updateTo\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The property to set the new value for.\r\n   * @param {*} value - The new value of the property.\r\n   * @param {boolean} [startToCurrent=false] - Should this change set the start value to be the current value?\r\n   *\r\n   * @return {this} - This Tween instance.\r\n   */\n  updateTo: function updateTo(key, value, startToCurrent) {\n    if (startToCurrent === undefined) {\n      startToCurrent = false;\n    }\n\n    for (var i = 0; i < this.totalData; i++) {\n      var tweenData = this.data[i];\n\n      if (tweenData.key === key) {\n        tweenData.end = value;\n\n        if (startToCurrent) {\n          tweenData.start = tweenData.current;\n        }\n\n        break;\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Restarts the tween from the beginning.\r\n   *\r\n   * @method Phaser.Tweens.Tween#restart\r\n   * @since 3.0.0\r\n   *\r\n   * @return {this} This Tween instance.\r\n   */\n  restart: function restart() {\n    if (this.state === TWEEN_CONST.REMOVED) {\n      this.seek(0);\n      this.parent.makeActive(this);\n    } else {\n      this.stop();\n      this.play();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Internal method that calculates the overall duration of the Tween.\r\n   *\r\n   * @method Phaser.Tweens.Tween#calcDuration\r\n   * @since 3.0.0\r\n   */\n  calcDuration: function calcDuration() {\n    var max = 0;\n    var data = this.data;\n\n    for (var i = 0; i < this.totalData; i++) {\n      var tweenData = data[i]; //  Set t1 (duration + hold + yoyo)\n\n      tweenData.t1 = tweenData.duration + tweenData.hold;\n\n      if (tweenData.yoyo) {\n        tweenData.t1 += tweenData.duration;\n      } //  Set t2 (repeatDelay + duration + hold + yoyo)\n\n\n      tweenData.t2 = tweenData.t1 + tweenData.repeatDelay; //  Total Duration\n\n      tweenData.totalDuration = tweenData.delay + tweenData.t1;\n\n      if (tweenData.repeat === -1) {\n        tweenData.totalDuration += tweenData.t2 * 999999999999;\n      } else if (tweenData.repeat > 0) {\n        tweenData.totalDuration += tweenData.t2 * tweenData.repeat;\n      }\n\n      if (tweenData.totalDuration > max) {\n        //  Get the longest TweenData from the Tween, used to calculate the Tween TD\n        max = tweenData.totalDuration;\n      }\n    } //  Excludes loop values\n\n\n    this.duration = max;\n    this.loopCounter = this.loop === -1 ? 999999999999 : this.loop;\n\n    if (this.loopCounter > 0) {\n      this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter;\n    } else {\n      this.totalDuration = this.duration + this.completeDelay;\n    }\n  },\n\n  /**\r\n   * Called by TweenManager.preUpdate as part of its loop to check pending and active tweens.\r\n   * Should not be called directly.\r\n   *\r\n   * @method Phaser.Tweens.Tween#init\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} Returns `true` if this Tween should be moved from the pending list to the active list by the Tween Manager.\r\n   */\n  init: function init() {\n    var data = this.data;\n    var totalTargets = this.totalTargets;\n\n    for (var i = 0; i < this.totalData; i++) {\n      var tweenData = data[i];\n      var target = tweenData.target;\n      var gen = tweenData.gen;\n      tweenData.delay = gen.delay(i, totalTargets, target);\n      tweenData.duration = gen.duration(i, totalTargets, target);\n      tweenData.hold = gen.hold(i, totalTargets, target);\n      tweenData.repeat = gen.repeat(i, totalTargets, target);\n      tweenData.repeatDelay = gen.repeatDelay(i, totalTargets, target);\n    }\n\n    this.calcDuration();\n    this.progress = 0;\n    this.totalProgress = 0;\n    this.elapsed = 0;\n    this.totalElapsed = 0; //  You can't have a paused Tween if it's part of a Timeline\n\n    if (this.paused && !this.parentIsTimeline) {\n      this.state = TWEEN_CONST.PENDING_ADD;\n      this._pausedState = TWEEN_CONST.INIT;\n      return false;\n    } else {\n      this.state = TWEEN_CONST.INIT;\n      return true;\n    }\n  },\n\n  /**\r\n   * Internal method that advances to the next state of the Tween during playback.\r\n   *\r\n   * @method Phaser.Tweens.Tween#nextState\r\n   * @since 3.0.0\r\n   */\n  nextState: function nextState() {\n    if (this.loopCounter > 0) {\n      this.elapsed = 0;\n      this.progress = 0;\n      this.loopCounter--;\n      var onLoop = this.callbacks.onLoop;\n\n      if (onLoop) {\n        onLoop.params[1] = this.targets;\n        onLoop.func.apply(onLoop.scope, onLoop.params);\n      }\n\n      this.resetTweenData(true);\n\n      if (this.loopDelay > 0) {\n        this.countdown = this.loopDelay;\n        this.state = TWEEN_CONST.LOOP_DELAY;\n      } else {\n        this.state = TWEEN_CONST.ACTIVE;\n      }\n    } else if (this.completeDelay > 0) {\n      this.countdown = this.completeDelay;\n      this.state = TWEEN_CONST.COMPLETE_DELAY;\n    } else {\n      var onComplete = this.callbacks.onComplete;\n\n      if (onComplete) {\n        onComplete.params[1] = this.targets;\n        onComplete.func.apply(onComplete.scope, onComplete.params);\n      }\n\n      this.state = TWEEN_CONST.PENDING_REMOVE;\n    }\n  },\n\n  /**\r\n   * Pauses the Tween immediately. Use `resume` to continue playback.\r\n   *\r\n   * @method Phaser.Tweens.Tween#pause\r\n   * @since 3.0.0\r\n   *\r\n   * @return {this} - This Tween instance.\r\n   */\n  pause: function pause() {\n    if (this.state === TWEEN_CONST.PAUSED) {\n      return;\n    }\n\n    this.paused = true;\n    this._pausedState = this.state;\n    this.state = TWEEN_CONST.PAUSED;\n    return this;\n  },\n\n  /**\r\n   * Starts a Tween playing.\r\n   * \r\n   * You only need to call this method if you have configured the tween to be paused on creation.\r\n   *\r\n   * @method Phaser.Tweens.Tween#play\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} resetFromTimeline - Is this Tween being played as part of a Timeline?\r\n   *\r\n   * @return {this} This Tween instance.\r\n   */\n  play: function play(resetFromTimeline) {\n    if (this.state === TWEEN_CONST.ACTIVE) {\n      return this;\n    } else if (this.state === TWEEN_CONST.PENDING_REMOVE || this.state === TWEEN_CONST.REMOVED) {\n      this.init();\n      this.parent.makeActive(this);\n      resetFromTimeline = true;\n    }\n\n    var onStart = this.callbacks.onStart;\n\n    if (this.parentIsTimeline) {\n      this.resetTweenData(resetFromTimeline);\n\n      if (this.calculatedOffset === 0) {\n        if (onStart) {\n          onStart.params[1] = this.targets;\n          onStart.func.apply(onStart.scope, onStart.params);\n        }\n\n        this.state = TWEEN_CONST.ACTIVE;\n      } else {\n        this.countdown = this.calculatedOffset;\n        this.state = TWEEN_CONST.OFFSET_DELAY;\n      }\n    } else if (this.paused) {\n      this.paused = false;\n      this.parent.makeActive(this);\n    } else {\n      this.resetTweenData(resetFromTimeline);\n      this.state = TWEEN_CONST.ACTIVE;\n\n      if (onStart) {\n        onStart.params[1] = this.targets;\n        onStart.func.apply(onStart.scope, onStart.params);\n      }\n\n      this.parent.makeActive(this);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Internal method that resets all of the Tween Data, including the progress and elapsed values.\r\n   *\r\n   * @method Phaser.Tweens.Tween#resetTweenData\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} resetFromLoop - Has this method been called as part of a loop?\r\n   */\n  resetTweenData: function resetTweenData(resetFromLoop) {\n    var data = this.data;\n\n    for (var i = 0; i < this.totalData; i++) {\n      var tweenData = data[i];\n      tweenData.progress = 0;\n      tweenData.elapsed = 0;\n      tweenData.repeatCounter = tweenData.repeat === -1 ? 999999999999 : tweenData.repeat;\n\n      if (resetFromLoop) {\n        tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start);\n        tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.end);\n        tweenData.current = tweenData.start;\n        tweenData.state = TWEEN_CONST.PLAYING_FORWARD;\n      } else if (tweenData.delay > 0) {\n        tweenData.elapsed = tweenData.delay;\n        tweenData.state = TWEEN_CONST.DELAY;\n      } else {\n        tweenData.state = TWEEN_CONST.PENDING_RENDER;\n      }\n    }\n  },\n\n  /**\r\n   * Resumes the playback of a previously paused Tween.\r\n   *\r\n   * @method Phaser.Tweens.Tween#resume\r\n   * @since 3.0.0\r\n   *\r\n   * @return {this} - This Tween instance.\r\n   */\n  resume: function resume() {\n    if (this.state === TWEEN_CONST.PAUSED) {\n      this.paused = false;\n      this.state = this._pausedState;\n    } else {\n      this.play();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Attempts to seek to a specific position in a Tween.\r\n   *\r\n   * @method Phaser.Tweens.Tween#seek\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} toPosition - A value between 0 and 1 which represents the progress point to seek to.\r\n   *\r\n   * @return {this} This Tween instance.\r\n   */\n  seek: function seek(toPosition) {\n    var data = this.data;\n\n    for (var i = 0; i < this.totalData; i++) {\n      //  This won't work with loop > 0 yet\n      var ms = this.totalDuration * toPosition;\n      var tweenData = data[i];\n      var progress = 0;\n      var elapsed = 0;\n\n      if (ms <= tweenData.delay) {\n        progress = 0;\n        elapsed = 0;\n      } else if (ms >= tweenData.totalDuration) {\n        progress = 1;\n        elapsed = tweenData.duration;\n      } else if (ms > tweenData.delay && ms <= tweenData.t1) {\n        //  Keep it zero bound\n        ms = Math.max(0, ms - tweenData.delay); //  Somewhere in the first playthru range\n\n        progress = ms / tweenData.t1;\n        elapsed = tweenData.duration * progress;\n      } else if (ms > tweenData.t1 && ms < tweenData.totalDuration) {\n        //  Somewhere in repeat land\n        ms -= tweenData.delay;\n        ms -= tweenData.t1; // var repeats = Math.floor(ms / tweenData.t2);\n        //  remainder\n\n        ms = ms / tweenData.t2 % 1 * tweenData.t2;\n\n        if (ms > tweenData.repeatDelay) {\n          progress = ms / tweenData.t1;\n          elapsed = tweenData.duration * progress;\n        }\n      }\n\n      tweenData.progress = progress;\n      tweenData.elapsed = elapsed;\n      var v = tweenData.ease(tweenData.progress);\n      tweenData.current = tweenData.start + (tweenData.end - tweenData.start) * v;\n      tweenData.target[tweenData.key] = tweenData.current;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets an event based callback to be invoked during playback.\r\n   *\r\n   * @method Phaser.Tweens.Tween#setCallback\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} type - Type of the callback.\r\n   * @param {function} callback - Callback function.\r\n   * @param {array} [params] - An array of parameters for specified callbacks types.\r\n   * @param {object} [scope] - The context the callback will be invoked in.\r\n   *\r\n   * @return {this} This Tween instance.\r\n   */\n  setCallback: function setCallback(type, callback, params, scope) {\n    this.callbacks[type] = {\n      func: callback,\n      scope: scope,\n      params: params\n    };\n    return this;\n  },\n\n  /**\r\n   * Flags the Tween as being complete, whatever stage of progress it is at.\r\n   *\r\n   * If an onComplete callback has been defined it will automatically invoke it, unless a `delay`\r\n   * argument is provided, in which case the Tween will delay for that period of time before calling the callback.\r\n   *\r\n   * If you don't need a delay, or have an onComplete callback, then call `Tween.stop` instead.\r\n   *\r\n   * @method Phaser.Tweens.Tween#complete\r\n   * @since 3.2.0\r\n   *\r\n   * @param {number} [delay=0] - The time to wait before invoking the complete callback. If zero it will fire immediately.\r\n   *\r\n   * @return {this} This Tween instance.\r\n   */\n  complete: function complete(delay) {\n    if (delay === undefined) {\n      delay = 0;\n    }\n\n    if (delay) {\n      this.countdown = delay;\n      this.state = TWEEN_CONST.COMPLETE_DELAY;\n    } else {\n      var onComplete = this.callbacks.onComplete;\n\n      if (onComplete) {\n        onComplete.params[1] = this.targets;\n        onComplete.func.apply(onComplete.scope, onComplete.params);\n      }\n\n      this.state = TWEEN_CONST.PENDING_REMOVE;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Stops the Tween immediately, whatever stage of progress it is at and flags it for removal by the TweenManager.\r\n   *\r\n   * @method Phaser.Tweens.Tween#stop\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [resetTo] - A value between 0 and 1.\r\n   *\r\n   * @return {this} This Tween instance.\r\n   */\n  stop: function stop(resetTo) {\n    if (this.state === TWEEN_CONST.ACTIVE) {\n      if (resetTo !== undefined) {\n        this.seek(resetTo);\n      }\n    }\n\n    if (this.state !== TWEEN_CONST.REMOVED) {\n      if (this.state === TWEEN_CONST.PAUSED || this.state === TWEEN_CONST.PENDING_ADD) {\n        this.parent._destroy.push(this);\n\n        this.parent._toProcess++;\n      }\n\n      this.state = TWEEN_CONST.PENDING_REMOVE;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Internal method that advances the Tween based on the time values.\r\n   *\r\n   * @method Phaser.Tweens.Tween#update\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} timestamp - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n   * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n   *\r\n   * @return {boolean} Returns `true` if this Tween has finished and should be removed from the Tween Manager, otherwise returns `false`.\r\n   */\n  update: function update(timestamp, delta) {\n    if (this.state === TWEEN_CONST.PAUSED) {\n      return false;\n    }\n\n    if (this.useFrames) {\n      delta = 1 * this.parent.timeScale;\n    }\n\n    delta *= this.timeScale;\n    this.elapsed += delta;\n    this.progress = Math.min(this.elapsed / this.duration, 1);\n    this.totalElapsed += delta;\n    this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);\n\n    switch (this.state) {\n      case TWEEN_CONST.ACTIVE:\n        var stillRunning = false;\n\n        for (var i = 0; i < this.totalData; i++) {\n          if (this.updateTweenData(this, this.data[i], delta)) {\n            stillRunning = true;\n          }\n        } //  Anything still running? If not, we're done\n\n\n        if (!stillRunning) {\n          this.nextState();\n        }\n\n        break;\n\n      case TWEEN_CONST.LOOP_DELAY:\n        this.countdown -= delta;\n\n        if (this.countdown <= 0) {\n          this.state = TWEEN_CONST.ACTIVE;\n        }\n\n        break;\n\n      case TWEEN_CONST.OFFSET_DELAY:\n        this.countdown -= delta;\n\n        if (this.countdown <= 0) {\n          var onStart = this.callbacks.onStart;\n\n          if (onStart) {\n            onStart.params[1] = this.targets;\n            onStart.func.apply(onStart.scope, onStart.params);\n          }\n\n          this.state = TWEEN_CONST.ACTIVE;\n        }\n\n        break;\n\n      case TWEEN_CONST.COMPLETE_DELAY:\n        this.countdown -= delta;\n\n        if (this.countdown <= 0) {\n          var onComplete = this.callbacks.onComplete;\n\n          if (onComplete) {\n            onComplete.func.apply(onComplete.scope, onComplete.params);\n          }\n\n          this.state = TWEEN_CONST.PENDING_REMOVE;\n        }\n\n        break;\n    }\n\n    return this.state === TWEEN_CONST.PENDING_REMOVE;\n  },\n\n  /**\r\n   * Internal method used as part of the playback process that sets a tween to play in reverse.\r\n   *\r\n   * @method Phaser.Tweens.Tween#setStateFromEnd\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Tweens.Tween} tween - The Tween to update.\r\n   * @param {Phaser.Tweens.TweenDataConfig} tweenData - The TweenData property to update.\r\n   * @param {number} diff - Any extra time that needs to be accounted for in the elapsed and progress values.\r\n   *\r\n   * @return {integer} The state of this Tween.\r\n   */\n  setStateFromEnd: function setStateFromEnd(tween, tweenData, diff) {\n    if (tweenData.yoyo) {\n      //  We've hit the end of a Playing Forward TweenData and we have a yoyo\n      //  Account for any extra time we got from the previous frame\n      tweenData.elapsed = diff;\n      tweenData.progress = diff / tweenData.duration;\n\n      if (tweenData.flipX) {\n        tweenData.target.toggleFlipX();\n      } //  Problem: The flip and callback and so on gets called for every TweenData that triggers it at the same time.\n      //  If you're tweening several properties it can fire for all of them, at once.\n\n\n      if (tweenData.flipY) {\n        tweenData.target.toggleFlipY();\n      }\n\n      var onYoyo = tween.callbacks.onYoyo;\n\n      if (onYoyo) {\n        //  Element 1 is reserved for the target of the yoyo (and needs setting here)\n        onYoyo.params[1] = tweenData.target;\n        onYoyo.func.apply(onYoyo.scope, onYoyo.params);\n      }\n\n      tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start);\n      return TWEEN_CONST.PLAYING_BACKWARD;\n    } else if (tweenData.repeatCounter > 0) {\n      //  We've hit the end of a Playing Forward TweenData and we have a Repeat.\n      //  So we're going to go right back to the start to repeat it again.\n      tweenData.repeatCounter--; //  Account for any extra time we got from the previous frame\n\n      tweenData.elapsed = diff;\n      tweenData.progress = diff / tweenData.duration;\n\n      if (tweenData.flipX) {\n        tweenData.target.toggleFlipX();\n      }\n\n      if (tweenData.flipY) {\n        tweenData.target.toggleFlipY();\n      }\n\n      var onRepeat = tween.callbacks.onRepeat;\n\n      if (onRepeat) {\n        //  Element 1 is reserved for the target of the repeat (and needs setting here)\n        onRepeat.params[1] = tweenData.target;\n        onRepeat.func.apply(onRepeat.scope, onRepeat.params);\n      }\n\n      tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start);\n      tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start); //  Delay?\n\n      if (tweenData.repeatDelay > 0) {\n        tweenData.elapsed = tweenData.repeatDelay - diff;\n        tweenData.current = tweenData.start;\n        tweenData.target[tweenData.key] = tweenData.current;\n        return TWEEN_CONST.REPEAT_DELAY;\n      } else {\n        return TWEEN_CONST.PLAYING_FORWARD;\n      }\n    }\n\n    return TWEEN_CONST.COMPLETE;\n  },\n\n  /**\r\n   * Internal method used as part of the playback process that sets a tween to play from the start.\r\n   *\r\n   * @method Phaser.Tweens.Tween#setStateFromStart\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Tweens.Tween} tween - The Tween to update.\r\n   * @param {Phaser.Tweens.TweenDataConfig} tweenData - The TweenData property to update.\r\n   * @param {number} diff - Any extra time that needs to be accounted for in the elapsed and progress values.\r\n   *\r\n   * @return {integer} The state of this Tween.\r\n   */\n  setStateFromStart: function setStateFromStart(tween, tweenData, diff) {\n    if (tweenData.repeatCounter > 0) {\n      tweenData.repeatCounter--; //  Account for any extra time we got from the previous frame\n\n      tweenData.elapsed = diff;\n      tweenData.progress = diff / tweenData.duration;\n\n      if (tweenData.flipX) {\n        tweenData.target.toggleFlipX();\n      }\n\n      if (tweenData.flipY) {\n        tweenData.target.toggleFlipY();\n      }\n\n      var onRepeat = tween.callbacks.onRepeat;\n\n      if (onRepeat) {\n        //  Element 1 is reserved for the target of the repeat (and needs setting here)\n        onRepeat.params[1] = tweenData.target;\n        onRepeat.func.apply(onRepeat.scope, onRepeat.params);\n      }\n\n      tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start); //  Delay?\n\n      if (tweenData.repeatDelay > 0) {\n        tweenData.elapsed = tweenData.repeatDelay - diff;\n        tweenData.current = tweenData.start;\n        tweenData.target[tweenData.key] = tweenData.current;\n        return TWEEN_CONST.REPEAT_DELAY;\n      } else {\n        return TWEEN_CONST.PLAYING_FORWARD;\n      }\n    }\n\n    return TWEEN_CONST.COMPLETE;\n  },\n\n  /**\r\n   * Internal method that advances the TweenData based on the time value given.\r\n   *\r\n   * @method Phaser.Tweens.Tween#updateTweenData\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Tweens.Tween} tween - The Tween to update.\r\n   * @param {Phaser.Tweens.TweenDataConfig} tweenData - The TweenData property to update.\r\n   * @param {number} delta - Either a value in ms, or 1 if Tween.useFrames is true\r\n   *\r\n   * @return {boolean} [description]\r\n   */\n  updateTweenData: function updateTweenData(tween, tweenData, delta) {\n    switch (tweenData.state) {\n      case TWEEN_CONST.PLAYING_FORWARD:\n      case TWEEN_CONST.PLAYING_BACKWARD:\n        if (!tweenData.target) {\n          tweenData.state = TWEEN_CONST.COMPLETE;\n          break;\n        }\n\n        var elapsed = tweenData.elapsed;\n        var duration = tweenData.duration;\n        var diff = 0;\n        elapsed += delta;\n\n        if (elapsed > duration) {\n          diff = elapsed - duration;\n          elapsed = duration;\n        }\n\n        var forward = tweenData.state === TWEEN_CONST.PLAYING_FORWARD;\n        var progress = elapsed / duration;\n        var v;\n\n        if (forward) {\n          v = tweenData.ease(progress);\n        } else {\n          v = tweenData.ease(1 - progress);\n        }\n\n        tweenData.current = tweenData.start + (tweenData.end - tweenData.start) * v;\n        tweenData.target[tweenData.key] = tweenData.current;\n        tweenData.elapsed = elapsed;\n        tweenData.progress = progress;\n        var onUpdate = tween.callbacks.onUpdate;\n\n        if (onUpdate) {\n          onUpdate.params[1] = tweenData.target;\n          onUpdate.func.apply(onUpdate.scope, onUpdate.params);\n        }\n\n        if (progress === 1) {\n          if (forward) {\n            if (tweenData.hold > 0) {\n              tweenData.elapsed = tweenData.hold - diff;\n              tweenData.state = TWEEN_CONST.HOLD_DELAY;\n            } else {\n              tweenData.state = this.setStateFromEnd(tween, tweenData, diff);\n            }\n          } else {\n            tweenData.state = this.setStateFromStart(tween, tweenData, diff);\n          }\n        }\n\n        break;\n\n      case TWEEN_CONST.DELAY:\n        tweenData.elapsed -= delta;\n\n        if (tweenData.elapsed <= 0) {\n          tweenData.elapsed = Math.abs(tweenData.elapsed);\n          tweenData.state = TWEEN_CONST.PENDING_RENDER;\n        }\n\n        break;\n\n      case TWEEN_CONST.REPEAT_DELAY:\n        tweenData.elapsed -= delta;\n\n        if (tweenData.elapsed <= 0) {\n          tweenData.elapsed = Math.abs(tweenData.elapsed);\n          tweenData.state = TWEEN_CONST.PLAYING_FORWARD;\n        }\n\n        break;\n\n      case TWEEN_CONST.HOLD_DELAY:\n        tweenData.elapsed -= delta;\n\n        if (tweenData.elapsed <= 0) {\n          tweenData.state = this.setStateFromEnd(tween, tweenData, Math.abs(tweenData.elapsed));\n        }\n\n        break;\n\n      case TWEEN_CONST.PENDING_RENDER:\n        if (tweenData.target) {\n          tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.target[tweenData.key]);\n          tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start);\n          tweenData.current = tweenData.start;\n          tweenData.target[tweenData.key] = tweenData.start;\n          tweenData.state = TWEEN_CONST.PLAYING_FORWARD;\n        } else {\n          tweenData.state = TWEEN_CONST.COMPLETE;\n        }\n\n        break;\n    } //  Return TRUE if this TweenData still playing, otherwise return FALSE\n\n\n    return tweenData.state !== TWEEN_CONST.COMPLETE;\n  }\n});\nTween.TYPES = ['onComplete', 'onLoop', 'onRepeat', 'onStart', 'onUpdate', 'onYoyo'];\n/**\r\n * Creates a new Tween object.\r\n *\r\n * Note: This method will only be available Tweens have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#tween\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The Tween configuration.\r\n *\r\n * @return {Phaser.Tweens.Tween} The Tween that was created.\r\n */\n\nGameObjectFactory.register('tween', function (config) {\n  return this.scene.sys.tweens.add(config);\n}); //  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n\n/**\r\n * Creates a new Tween object and returns it.\r\n *\r\n * Note: This method will only be available if Tweens have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#tween\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The Tween configuration.\r\n *\r\n * @return {Phaser.Tweens.Tween} The Tween that was created.\r\n */\n\nGameObjectCreator.register('tween', function (config) {\n  return this.scene.sys.tweens.create(config);\n}); //  When registering a factory function 'this' refers to the GameObjectCreator context.\n\nmodule.exports = Tween;","map":null,"metadata":{},"sourceType":"script"}