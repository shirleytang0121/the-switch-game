{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar SnapFloor = require('../../math/snap/SnapFloor');\n\nvar SnapCeil = require('../../math/snap/SnapCeil');\n/**\r\n * Returns the tiles in the given layer that are within the camera's viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.CullTiles\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - An optional array to store the Tile objects within.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\n\n\nvar CullTiles = function CullTiles(layer, camera, outputArray, renderOrder) {\n  if (outputArray === undefined) {\n    outputArray = [];\n  }\n\n  if (renderOrder === undefined) {\n    renderOrder = 0;\n  }\n\n  outputArray.length = 0;\n  var tilemap = layer.tilemapLayer.tilemap;\n  var tilemapLayer = layer.tilemapLayer;\n  var mapData = layer.data;\n  var mapWidth = layer.width;\n  var mapHeight = layer.height; //  We need to use the tile sizes defined for the map as a whole, not the layer,\n  //  in order to calculate the bounds correctly. As different sized tiles may be\n  //  placed on the grid and we cannot trust layer.baseTileWidth to give us the true size.\n\n  var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);\n  var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);\n  var drawLeft = 0;\n  var drawRight = mapWidth;\n  var drawTop = 0;\n  var drawBottom = mapHeight;\n\n  if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1) {\n    //  Camera world view bounds, snapped for scaled tile size\n    //  Cull Padding values are given in tiles, not pixels\n    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;\n    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;\n    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH, 0, true) - tilemapLayer.cullPaddingY;\n    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH, 0, true) + tilemapLayer.cullPaddingY;\n    drawLeft = Math.max(0, boundsLeft);\n    drawRight = Math.min(mapWidth, boundsRight);\n    drawTop = Math.max(0, boundsTop);\n    drawBottom = Math.min(mapHeight, boundsBottom);\n  }\n\n  var x;\n  var y;\n  var tile;\n\n  if (renderOrder === 0) {\n    //  right-down\n    for (y = drawTop; y < drawBottom; y++) {\n      for (x = drawLeft; mapData[y] && x < drawRight; x++) {\n        tile = mapData[y][x];\n\n        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {\n          continue;\n        }\n\n        outputArray.push(tile);\n      }\n    }\n  } else if (renderOrder === 1) {\n    //  left-down\n    for (y = drawTop; y < drawBottom; y++) {\n      for (x = drawRight; mapData[y] && x >= drawLeft; x--) {\n        tile = mapData[y][x];\n\n        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {\n          continue;\n        }\n\n        outputArray.push(tile);\n      }\n    }\n  } else if (renderOrder === 2) {\n    //  right-up\n    for (y = drawBottom; y >= drawTop; y--) {\n      for (x = drawLeft; mapData[y] && x < drawRight; x++) {\n        tile = mapData[y][x];\n\n        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {\n          continue;\n        }\n\n        outputArray.push(tile);\n      }\n    }\n  } else if (renderOrder === 3) {\n    //  left-up\n    for (y = drawBottom; y >= drawTop; y--) {\n      for (x = drawRight; mapData[y] && x >= drawLeft; x--) {\n        tile = mapData[y][x];\n\n        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {\n          continue;\n        }\n\n        outputArray.push(tile);\n      }\n    }\n  }\n\n  tilemapLayer.tilesDrawn = outputArray.length;\n  tilemapLayer.tilesTotal = mapWidth * mapHeight;\n  return outputArray;\n};\n\nmodule.exports = CullTiles;","map":null,"metadata":{},"sourceType":"script"}