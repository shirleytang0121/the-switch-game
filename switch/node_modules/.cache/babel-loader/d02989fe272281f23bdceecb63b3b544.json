{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar BaseCamera = require('../../cameras/2d/BaseCamera');\n\nvar CameraEvents = require('../../cameras/2d/events');\n\nvar Class = require('../../utils/Class');\n\nvar CONST = require('../../const');\n\nvar IsSizePowerOfTwo = require('../../math/pow2/IsSizePowerOfTwo');\n\nvar SpliceOne = require('../../utils/array/SpliceOne');\n\nvar TextureEvents = require('../../textures/events');\n\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\n\nvar Utils = require('./Utils');\n\nvar WebGLSnapshot = require('../snapshot/WebGLSnapshot'); // Default Pipelines\n\n\nvar BitmapMaskPipeline = require('./pipelines/BitmapMaskPipeline');\n\nvar ForwardDiffuseLightPipeline = require('./pipelines/ForwardDiffuseLightPipeline');\n\nvar TextureTintPipeline = require('./pipelines/TextureTintPipeline');\n/**\r\n * @callback WebGLContextCallback\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer which owns the context.\r\n */\n\n/**\r\n * @classdesc\r\n * WebGLRenderer is a class that contains the needed functionality to keep the\r\n * WebGLRenderingContext state clean. The main idea of the WebGLRenderer is to keep track of\r\n * any context change that happens for WebGL rendering inside of Phaser. This means\r\n * if raw webgl functions are called outside the WebGLRenderer of the Phaser WebGL\r\n * rendering ecosystem they might pollute the current WebGLRenderingContext state producing\r\n * unexpected behavior. It's recommended that WebGL interaction is done through\r\n * WebGLRenderer and/or WebGLPipeline.\r\n *\r\n * @class WebGLRenderer\r\n * @memberof Phaser.Renderer.WebGL\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Game instance which owns this WebGL Renderer.\r\n */\n\n\nvar WebGLRenderer = new Class({\n  initialize: function WebGLRenderer(game) {\n    // eslint-disable-next-line consistent-this\n    var renderer = this;\n    var gameConfig = game.config;\n    var contextCreationConfig = {\n      alpha: gameConfig.transparent,\n      depth: false,\n      antialias: gameConfig.antialias,\n      premultipliedAlpha: gameConfig.premultipliedAlpha,\n      stencil: true,\n      failIfMajorPerformanceCaveat: gameConfig.failIfMajorPerformanceCaveat,\n      powerPreference: gameConfig.powerPreference\n    };\n    /**\r\n     * The local configuration settings of this WebGL Renderer.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#config\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.config = {\n      clearBeforeRender: gameConfig.clearBeforeRender,\n      antialias: gameConfig.antialias,\n      backgroundColor: gameConfig.backgroundColor,\n      contextCreation: contextCreationConfig,\n      resolution: gameConfig.resolution,\n      roundPixels: gameConfig.roundPixels,\n      maxTextures: gameConfig.maxTextures,\n      maxTextureSize: gameConfig.maxTextureSize,\n      batchSize: gameConfig.batchSize,\n      maxLights: gameConfig.maxLights\n    };\n    /**\r\n     * The Game instance which owns this WebGL Renderer.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#game\r\n     * @type {Phaser.Game}\r\n     * @since 3.0.0\r\n     */\n\n    this.game = game;\n    /**\r\n     * A constant which allows the renderer to be easily identified as a WebGL Renderer.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#type\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.type = CONST.WEBGL;\n    /**\r\n     * The width of the canvas being rendered to.\r\n     * This is populated in the onResize event handler.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#width\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.width = 0;\n    /**\r\n     * The height of the canvas being rendered to.\r\n     * This is populated in the onResize event handler.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#height\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.height = 0;\n    /**\r\n     * The canvas which this WebGL Renderer draws to.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#canvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.0.0\r\n     */\n\n    this.canvas = game.canvas;\n    /**\r\n     * An array of functions to invoke if the WebGL context is lost.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#lostContextCallbacks\r\n     * @type {WebGLContextCallback[]}\r\n     * @since 3.0.0\r\n     */\n\n    this.lostContextCallbacks = [];\n    /**\r\n     * An array of functions to invoke if the WebGL context is restored.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#restoredContextCallbacks\r\n     * @type {WebGLContextCallback[]}\r\n     * @since 3.0.0\r\n     */\n\n    this.restoredContextCallbacks = [];\n    /**\r\n     * An array of blend modes supported by the WebGL Renderer.\r\n     * \r\n     * This array includes the default blend modes as well as any custom blend modes added through {@link #addBlendMode}.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#blendModes\r\n     * @type {array}\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this.blendModes = [];\n    /**\r\n     * Keeps track of any WebGLTexture created with the current WebGLRenderingContext\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#nativeTextures\r\n     * @type {array}\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this.nativeTextures = [];\n    /**\r\n     * Set to `true` if the WebGL context of the renderer is lost.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#contextLost\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.contextLost = false;\n    /**\r\n     * This object will store all pipelines created through addPipeline\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#pipelines\r\n     * @type {object}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.pipelines = null;\n    /**\r\n     * Details about the currently scheduled snapshot.\r\n     * \r\n     * If a non-null `callback` is set in this object, a snapshot of the canvas will be taken after the current frame is fully rendered.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#snapshotState\r\n     * @type {SnapshotState}\r\n     * @since 3.0.0\r\n     */\n\n    this.snapshotState = {\n      x: 0,\n      y: 0,\n      width: 1,\n      height: 1,\n      getPixel: false,\n      callback: null,\n      type: 'image/png',\n      encoder: 0.92\n    }; // Internal Renderer State (Textures, Framebuffers, Pipelines, Buffers, etc)\n\n    /**\r\n     * Cached value for the last texture unit that was used\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentActiveTextureUnit\r\n     * @type {integer}\r\n     * @since 3.1.0\r\n     */\n\n    this.currentActiveTextureUnit = 0;\n    /**\r\n     * An array of the last texture handles that were bound to the WebGLRenderingContext\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentTextures\r\n     * @type {array}\r\n     * @since 3.0.0\r\n     */\n\n    this.currentTextures = new Array(16);\n    /**\r\n     * Current framebuffer in use\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentFramebuffer\r\n     * @type {WebGLFramebuffer}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.currentFramebuffer = null;\n    /**\r\n     * Current WebGLPipeline in use\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentPipeline\r\n     * @type {Phaser.Renderer.WebGL.WebGLPipeline}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.currentPipeline = null;\n    /**\r\n     * Current WebGLProgram in use\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentProgram\r\n     * @type {WebGLProgram}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.currentProgram = null;\n    /**\r\n     * Current WebGLBuffer (Vertex buffer) in use\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentVertexBuffer\r\n     * @type {WebGLBuffer}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.currentVertexBuffer = null;\n    /**\r\n     * Current WebGLBuffer (Index buffer) in use\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentIndexBuffer\r\n     * @type {WebGLBuffer}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.currentIndexBuffer = null;\n    /**\r\n     * Current blend mode in use\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentBlendMode\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.currentBlendMode = Infinity;\n    /**\r\n     * Indicates if the the scissor state is enabled in WebGLRenderingContext\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentScissorEnabled\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.currentScissorEnabled = false;\n    /**\r\n     * Stores the current scissor data\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentScissor\r\n     * @type {Uint32Array}\r\n     * @since 3.0.0\r\n     */\n    // this.currentScissor = new Uint32Array([ 0, 0, this.width, this.height ]);\n\n    this.currentScissor = null;\n    /**\r\n     * Stack of scissor data\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#scissorStack\r\n     * @type {Uint32Array}\r\n     * @since 3.0.0\r\n     */\n\n    this.scissorStack = []; // Setup context lost and restore event listeners\n\n    this.canvas.addEventListener('webglcontextlost', function (event) {\n      renderer.contextLost = true;\n      event.preventDefault();\n\n      for (var index = 0; index < renderer.lostContextCallbacks.length; ++index) {\n        var callback = renderer.lostContextCallbacks[index];\n        callback[0].call(callback[1], renderer);\n      }\n    }, false);\n    this.canvas.addEventListener('webglcontextrestored', function () {\n      renderer.contextLost = false;\n      renderer.init(renderer.config);\n\n      for (var index = 0; index < renderer.restoredContextCallbacks.length; ++index) {\n        var callback = renderer.restoredContextCallbacks[index];\n        callback[0].call(callback[1], renderer);\n      }\n    }, false); // These are initialized post context creation\n\n    /**\r\n     * The underlying WebGL context of the renderer.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#gl\r\n     * @type {WebGLRenderingContext}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.gl = null;\n    /**\r\n     * Array of strings that indicate which WebGL extensions are supported by the browser\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#supportedExtensions\r\n     * @type {object}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.supportedExtensions = null;\n    /**\r\n     * Extensions loaded into the current context\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#extensions\r\n     * @type {object}\r\n     * @default {}\r\n     * @since 3.0.0\r\n     */\n\n    this.extensions = {};\n    /**\r\n     * Stores the current WebGL component formats for further use\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#glFormats\r\n     * @type {array}\r\n     * @default []\r\n     * @since 3.2.0\r\n     */\n\n    this.glFormats = [];\n    /**\r\n     * Stores the supported WebGL texture compression formats.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#compression\r\n     * @type {array}\r\n     * @since 3.8.0\r\n     */\n\n    this.compression = {\n      ETC1: false,\n      PVRTC: false,\n      S3TC: false\n    };\n    /**\r\n     * Cached drawing buffer height to reduce gl calls.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#drawingBufferHeight\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.11.0\r\n     */\n\n    this.drawingBufferHeight = 0;\n    /**\r\n     * A blank 32x32 transparent texture, as used by the Graphics system where needed.\r\n     * This is set in the `boot` method.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#blankTexture\r\n     * @type {WebGLTexture}\r\n     * @readonly\r\n     * @since 3.12.0\r\n     */\n\n    this.blankTexture = null;\n    /**\r\n     * A default Camera used in calls when no other camera has been provided.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#defaultCamera\r\n     * @type {Phaser.Cameras.Scene2D.BaseCamera}\r\n     * @since 3.12.0\r\n     */\n\n    this.defaultCamera = new BaseCamera(0, 0, 0, 0);\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix1\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix1 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix2\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix2 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix3\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix3 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix4\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix4 = new TransformMatrix();\n    this.init(this.config);\n  },\n\n  /**\r\n   * Creates a new WebGLRenderingContext and initializes all internal state.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#init\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} config - The configuration object for the renderer.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  init: function init(config) {\n    var gl;\n    var game = this.game;\n    var canvas = this.canvas;\n    var clearColor = config.backgroundColor; //  Did they provide their own context?\n\n    if (game.config.context) {\n      gl = game.config.context;\n    } else {\n      gl = canvas.getContext('webgl', config.contextCreation) || canvas.getContext('experimental-webgl', config.contextCreation);\n    }\n\n    if (!gl || gl.isContextLost()) {\n      this.contextLost = true;\n      throw new Error('WebGL unsupported');\n    }\n\n    this.gl = gl; //  Set it back into the Game, so developers can access it from there too\n\n    game.context = gl;\n\n    for (var i = 0; i <= 27; i++) {\n      this.blendModes.push({\n        func: [gl.ONE, gl.ONE_MINUS_SRC_ALPHA],\n        equation: gl.FUNC_ADD\n      });\n    } //  ADD\n\n\n    this.blendModes[1].func = [gl.ONE, gl.DST_ALPHA]; //  MULTIPLY\n\n    this.blendModes[2].func = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA]; //  SCREEN\n\n    this.blendModes[3].func = [gl.ONE, gl.ONE_MINUS_SRC_COLOR]; //  ERASE\n\n    this.blendModes[17] = {\n      func: [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA],\n      equation: gl.FUNC_REVERSE_SUBTRACT\n    };\n    this.glFormats[0] = gl.BYTE;\n    this.glFormats[1] = gl.SHORT;\n    this.glFormats[2] = gl.UNSIGNED_BYTE;\n    this.glFormats[3] = gl.UNSIGNED_SHORT;\n    this.glFormats[4] = gl.FLOAT; // Load supported extensions\n\n    var exts = gl.getSupportedExtensions();\n\n    if (!config.maxTextures) {\n      config.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    }\n\n    if (!config.maxTextureSize) {\n      config.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    }\n\n    var extString = 'WEBGL_compressed_texture_';\n    var wkExtString = 'WEBKIT_' + extString;\n    this.compression.ETC1 = gl.getExtension(extString + 'etc1') || gl.getExtension(wkExtString + 'etc1');\n    this.compression.PVRTC = gl.getExtension(extString + 'pvrtc') || gl.getExtension(wkExtString + 'pvrtc');\n    this.compression.S3TC = gl.getExtension(extString + 's3tc') || gl.getExtension(wkExtString + 's3tc');\n    this.supportedExtensions = exts; //  Setup initial WebGL state\n\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.CULL_FACE);\n    gl.enable(gl.BLEND);\n    gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL); // Initialize all textures to null\n\n    for (var index = 0; index < this.currentTextures.length; ++index) {\n      this.currentTextures[index] = null;\n    } // Clear previous pipelines and reload default ones\n\n\n    this.pipelines = {};\n    this.addPipeline('TextureTintPipeline', new TextureTintPipeline({\n      game: game,\n      renderer: this\n    }));\n    this.addPipeline('BitmapMaskPipeline', new BitmapMaskPipeline({\n      game: game,\n      renderer: this\n    }));\n    this.addPipeline('Light2D', new ForwardDiffuseLightPipeline({\n      game: game,\n      renderer: this,\n      maxLights: config.maxLights\n    }));\n    this.setBlendMode(CONST.BlendModes.NORMAL);\n    game.textures.once(TextureEvents.READY, this.boot, this);\n    return this;\n  },\n\n  /**\r\n   * Internal boot handler. Calls 'boot' on each pipeline.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#boot\r\n   * @private\r\n   * @since 3.11.0\r\n   */\n  boot: function boot() {\n    for (var pipelineName in this.pipelines) {\n      this.pipelines[pipelineName].boot();\n    }\n\n    var blank = this.game.textures.getFrame('__DEFAULT');\n    this.pipelines.TextureTintPipeline.currentFrame = blank;\n    this.blankTexture = blank;\n    var gl = this.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.enable(gl.SCISSOR_TEST);\n    this.setPipeline(this.pipelines.TextureTintPipeline);\n    this.game.scale.on('resize', this.onResize, this);\n    var baseSize = this.game.scale.baseSize;\n    this.resize(baseSize.width, baseSize.height, this.game.scale.resolution);\n  },\n\n  /**\r\n   * The event handler that manages the `resize` event dispatched by the Scale Manager.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#onResize\r\n   * @since 3.16.0\r\n   *\r\n   * @param {Phaser.Structs.Size} gameSize - The default Game Size object. This is the un-modified game dimensions.\r\n   * @param {Phaser.Structs.Size} baseSize - The base Size object. The game dimensions multiplied by the resolution. The canvas width / height values match this.\r\n   * @param {Phaser.Structs.Size} displaySize - The display Size object. The size of the canvas style width / height attributes.\r\n   * @param {number} [resolution] - The Scale Manager resolution setting.\r\n   */\n  onResize: function onResize(gameSize, baseSize, displaySize, resolution) {\n    //  Has the underlying canvas size changed?\n    if (baseSize.width !== this.width || baseSize.height !== this.height || resolution !== this.resolution) {\n      this.resize(baseSize.width, baseSize.height, resolution);\n    }\n  },\n\n  /**\r\n   * Resizes the drawing buffer to match that required by the Scale Manager.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#resize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [width] - The new width of the renderer.\r\n   * @param {number} [height] - The new height of the renderer.\r\n   * @param {number} [resolution] - The new resolution of the renderer.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  resize: function resize(width, height, resolution) {\n    var gl = this.gl;\n    var pipelines = this.pipelines;\n    this.width = width;\n    this.height = height;\n    this.resolution = resolution;\n    gl.viewport(0, 0, width, height); //  Update all registered pipelines\n\n    for (var pipelineName in pipelines) {\n      pipelines[pipelineName].resize(width, height, resolution);\n    }\n\n    this.drawingBufferHeight = gl.drawingBufferHeight;\n    gl.scissor(0, gl.drawingBufferHeight - height, width, height);\n    this.defaultCamera.setSize(width, height);\n    return this;\n  },\n\n  /**\r\n   * Adds a callback to be invoked when the WebGL context has been restored by the browser.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#onContextRestored\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLContextCallback} callback - The callback to be invoked on context restoration.\r\n   * @param {object} target - The context of the callback.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  onContextRestored: function onContextRestored(callback, target) {\n    this.restoredContextCallbacks.push([callback, target]);\n    return this;\n  },\n\n  /**\r\n   * Adds a callback to be invoked when the WebGL context has been lost by the browser.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#onContextLost\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLContextCallback} callback - The callback to be invoked on context loss.\r\n   * @param {object} target - The context of the callback.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  onContextLost: function onContextLost(callback, target) {\n    this.lostContextCallbacks.push([callback, target]);\n    return this;\n  },\n\n  /**\r\n   * Checks if a WebGL extension is supported\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#hasExtension\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} extensionName - Name of the WebGL extension\r\n   *\r\n   * @return {boolean} `true` if the extension is supported, otherwise `false`.\r\n   */\n  hasExtension: function hasExtension(extensionName) {\n    return this.supportedExtensions ? this.supportedExtensions.indexOf(extensionName) : false;\n  },\n\n  /**\r\n   * Loads a WebGL extension\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#getExtension\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} extensionName - The name of the extension to load.\r\n   *\r\n   * @return {object} WebGL extension if the extension is supported\r\n   */\n  getExtension: function getExtension(extensionName) {\n    if (!this.hasExtension(extensionName)) {\n      return null;\n    }\n\n    if (!(extensionName in this.extensions)) {\n      this.extensions[extensionName] = this.gl.getExtension(extensionName);\n    }\n\n    return this.extensions[extensionName];\n  },\n\n  /**\r\n   * Flushes the current pipeline if the pipeline is bound\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#flush\r\n   * @since 3.0.0\r\n   */\n  flush: function flush() {\n    if (this.currentPipeline) {\n      this.currentPipeline.flush();\n    }\n  },\n\n  /**\r\n   * Checks if a pipeline is present in the current WebGLRenderer\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#hasPipeline\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} pipelineName - The name of the pipeline.\r\n   *\r\n   * @return {boolean} `true` if the given pipeline is loaded, otherwise `false`.\r\n   */\n  hasPipeline: function hasPipeline(pipelineName) {\n    return pipelineName in this.pipelines;\n  },\n\n  /**\r\n   * Returns the pipeline by name if the pipeline exists\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#getPipeline\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} pipelineName - The name of the pipeline.\r\n   *\r\n   * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline instance, or `null` if not found.\r\n   */\n  getPipeline: function getPipeline(pipelineName) {\n    return this.hasPipeline(pipelineName) ? this.pipelines[pipelineName] : null;\n  },\n\n  /**\r\n   * Removes a pipeline by name.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#removePipeline\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} pipelineName - The name of the pipeline to be removed.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  removePipeline: function removePipeline(pipelineName) {\n    delete this.pipelines[pipelineName];\n    return this;\n  },\n\n  /**\r\n   * Adds a pipeline instance into the collection of pipelines\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#addPipeline\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} pipelineName - A unique string-based key for the pipeline.\r\n   * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - A pipeline instance which must extend WebGLPipeline.\r\n   *\r\n   * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline instance that was passed.\r\n   */\n  addPipeline: function addPipeline(pipelineName, pipelineInstance) {\n    if (!this.hasPipeline(pipelineName)) {\n      this.pipelines[pipelineName] = pipelineInstance;\n    } else {\n      console.warn('Pipeline exists: ' + pipelineName);\n    }\n\n    pipelineInstance.name = pipelineName;\n    this.pipelines[pipelineName].resize(this.width, this.height, this.config.resolution);\n    return pipelineInstance;\n  },\n\n  /**\r\n   * Pushes a new scissor state. This is used to set nested scissor states.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#pushScissor\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} x - The x position of the scissor.\r\n   * @param {integer} y - The y position of the scissor.\r\n   * @param {integer} width - The width of the scissor.\r\n   * @param {integer} height - The height of the scissor.\r\n   * @param {integer} [drawingBufferHeight] - Optional drawingBufferHeight override value.\r\n   *\r\n   * @return {integer[]} An array containing the scissor values.\r\n   */\n  pushScissor: function pushScissor(x, y, width, height, drawingBufferHeight) {\n    if (drawingBufferHeight === undefined) {\n      drawingBufferHeight = this.drawingBufferHeight;\n    }\n\n    var scissorStack = this.scissorStack;\n    var scissor = [x, y, width, height];\n    scissorStack.push(scissor);\n    this.setScissor(x, y, width, height, drawingBufferHeight);\n    this.currentScissor = scissor;\n    return scissor;\n  },\n\n  /**\r\n   * Sets the current scissor state.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setScissor\r\n   * @since 3.0.0\r\n   * \r\n   * @param {integer} x - The x position of the scissor.\r\n   * @param {integer} y - The y position of the scissor.\r\n   * @param {integer} width - The width of the scissor.\r\n   * @param {integer} height - The height of the scissor.\r\n   * @param {integer} [drawingBufferHeight] - Optional drawingBufferHeight override value.\r\n   */\n  setScissor: function setScissor(x, y, width, height, drawingBufferHeight) {\n    var gl = this.gl;\n    var current = this.currentScissor;\n    var setScissor = width > 0 && height > 0;\n\n    if (current && setScissor) {\n      var cx = current[0];\n      var cy = current[1];\n      var cw = current[2];\n      var ch = current[3];\n      setScissor = cx !== x || cy !== y || cw !== width || ch !== height;\n    }\n\n    if (setScissor) {\n      this.flush(); // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/scissor\n\n      gl.scissor(x, drawingBufferHeight - y - height, width, height);\n    }\n  },\n\n  /**\r\n   * Pops the last scissor state and sets it.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#popScissor\r\n   * @since 3.0.0\r\n   */\n  popScissor: function popScissor() {\n    var scissorStack = this.scissorStack; //  Remove the current scissor\n\n    scissorStack.pop(); //  Reset the previous scissor\n\n    var scissor = scissorStack[scissorStack.length - 1];\n\n    if (scissor) {\n      this.setScissor(scissor[0], scissor[1], scissor[2], scissor[3]);\n    }\n\n    this.currentScissor = scissor;\n  },\n\n  /**\r\n   * Binds a WebGLPipeline and sets it as the current pipeline to be used.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setPipeline\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - The pipeline instance to be activated.\r\n   * @param {Phaser.GameObjects.GameObject} [gameObject] - The Game Object that invoked this pipeline, if any.\r\n   *\r\n   * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline that was activated.\r\n   */\n  setPipeline: function setPipeline(pipelineInstance, gameObject) {\n    if (this.currentPipeline !== pipelineInstance || this.currentPipeline.vertexBuffer !== this.currentVertexBuffer || this.currentPipeline.program !== this.currentProgram) {\n      this.flush();\n      this.currentPipeline = pipelineInstance;\n      this.currentPipeline.bind();\n    }\n\n    this.currentPipeline.onBind(gameObject);\n    return this.currentPipeline;\n  },\n\n  /**\r\n   * Use this to reset the gl context to the state that Phaser requires to continue rendering.\r\n   * Calling this will:\r\n   * \r\n   * * Disable `DEPTH_TEST`, `CULL_FACE` and `STENCIL_TEST`.\r\n   * * Clear the depth buffer and stencil buffers.\r\n   * * Reset the viewport size.\r\n   * * Reset the blend mode.\r\n   * * Bind a blank texture as the active texture on texture unit zero.\r\n   * * Rebinds the given pipeline instance.\r\n   * \r\n   * You should call this having previously called `clearPipeline` and then wishing to return\r\n   * control to Phaser again.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#rebindPipeline\r\n   * @since 3.16.0\r\n   * \r\n   * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - The pipeline instance to be activated.\r\n   */\n  rebindPipeline: function rebindPipeline(pipelineInstance) {\n    var gl = this.gl;\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.CULL_FACE);\n    gl.disable(gl.STENCIL_TEST);\n    gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n    gl.viewport(0, 0, this.width, this.height);\n    this.setBlendMode(0, true);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this.blankTexture.glTexture);\n    this.currentActiveTextureUnit = 0;\n    this.currentTextures[0] = this.blankTexture.glTexture;\n    this.currentPipeline = pipelineInstance;\n    this.currentPipeline.bind();\n    this.currentPipeline.onBind();\n  },\n\n  /**\r\n   * Flushes the current WebGLPipeline being used and then clears it, along with the\r\n   * the current shader program and vertex buffer. Then resets the blend mode to NORMAL.\r\n   * Call this before jumping to your own gl context handler, and then call `rebindPipeline` when\r\n   * you wish to return control to Phaser again.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#clearPipeline\r\n   * @since 3.16.0\r\n   */\n  clearPipeline: function clearPipeline() {\n    this.flush();\n    this.currentPipeline = null;\n    this.currentProgram = null;\n    this.currentVertexBuffer = null;\n    this.currentIndexBuffer = null;\n    this.setBlendMode(0, true);\n  },\n\n  /**\r\n   * Sets the blend mode to the value given.\r\n   *\r\n   * If the current blend mode is different from the one given, the pipeline is flushed and the new\r\n   * blend mode is enabled.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setBlendMode\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} blendModeId - The blend mode to be set. Can be a `BlendModes` const or an integer value.\r\n   * @param {boolean} [force=false] - Force the blend mode to be set, regardless of the currently set blend mode.\r\n   *\r\n   * @return {boolean} `true` if the blend mode was changed as a result of this call, forcing a flush, otherwise `false`.\r\n   */\n  setBlendMode: function setBlendMode(blendModeId, force) {\n    if (force === undefined) {\n      force = false;\n    }\n\n    var gl = this.gl;\n    var blendMode = this.blendModes[blendModeId];\n\n    if (force || blendModeId !== CONST.BlendModes.SKIP_CHECK && this.currentBlendMode !== blendModeId) {\n      this.flush();\n      gl.enable(gl.BLEND);\n      gl.blendEquation(blendMode.equation);\n\n      if (blendMode.func.length > 2) {\n        gl.blendFuncSeparate(blendMode.func[0], blendMode.func[1], blendMode.func[2], blendMode.func[3]);\n      } else {\n        gl.blendFunc(blendMode.func[0], blendMode.func[1]);\n      }\n\n      this.currentBlendMode = blendModeId;\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Creates a new custom blend mode for the renderer.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#addBlendMode\r\n   * @since 3.0.0\r\n   *\r\n   * @param {function} func - An array containing the WebGL functions to use for the source and the destination blending factors, respectively. See the possible constants for {@link WebGLRenderingContext#blendFunc()}.\r\n   * @param {function} equation - The equation to use for combining the RGB and alpha components of a new pixel with a rendered one. See the possible constants for {@link WebGLRenderingContext#blendEquation()}.\r\n   *\r\n   * @return {integer} The index of the new blend mode, used for referencing it in the future.\r\n   */\n  addBlendMode: function addBlendMode(func, equation) {\n    var index = this.blendModes.push({\n      func: func,\n      equation: equation\n    });\n    return index - 1;\n  },\n\n  /**\r\n   * Updates the function bound to a given custom blend mode.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#updateBlendMode\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} index - The index of the custom blend mode.\r\n   * @param {function} func - The function to use for the blend mode.\r\n   * @param {function} equation - The equation to use for the blend mode.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  updateBlendMode: function updateBlendMode(index, func, equation) {\n    if (this.blendModes[index]) {\n      this.blendModes[index].func = func;\n\n      if (equation) {\n        this.blendModes[index].equation = equation;\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes a custom blend mode from the renderer.\r\n   * Any Game Objects still using this blend mode will error, so be sure to clear them first.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#removeBlendMode\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} index - The index of the custom blend mode to be removed.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  removeBlendMode: function removeBlendMode(index) {\n    if (index > 17 && this.blendModes[index]) {\n      this.blendModes.splice(index, 1);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the current active texture for texture unit zero to be a blank texture.\r\n   * This only happens if there isn't a texture already in use by texture unit zero.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setBlankTexture\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {boolean} [force=false] - Force a blank texture set, regardless of what's already bound?\r\n   */\n  setBlankTexture: function setBlankTexture(force) {\n    if (force === undefined) {\n      force = false;\n    }\n\n    if (force || this.currentActiveTextureUnit !== 0 || !this.currentTextures[0]) {\n      this.setTexture2D(this.blankTexture.glTexture, 0);\n    }\n  },\n\n  /**\r\n   * Binds a texture at a texture unit. If a texture is already\r\n   * bound to that unit it will force a flush on the current pipeline.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setTexture2D\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLTexture} texture - The WebGL texture that needs to be bound.\r\n   * @param {integer} textureUnit - The texture unit to which the texture will be bound.\r\n   * @param {boolean} [flush=true] - Will the current pipeline be flushed if this is a new texture, or not?\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  setTexture2D: function setTexture2D(texture, textureUnit, flush) {\n    if (flush === undefined) {\n      flush = true;\n    }\n\n    var gl = this.gl;\n\n    if (texture !== this.currentTextures[textureUnit]) {\n      if (flush) {\n        this.flush();\n      }\n\n      if (this.currentActiveTextureUnit !== textureUnit) {\n        gl.activeTexture(gl.TEXTURE0 + textureUnit);\n        this.currentActiveTextureUnit = textureUnit;\n      }\n\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      this.currentTextures[textureUnit] = texture;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Binds a framebuffer. If there was another framebuffer already bound it will force a pipeline flush.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFramebuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLFramebuffer} framebuffer - The framebuffer that needs to be bound.\r\n   * @param {boolean} [updateScissor=false] - If a framebuffer is given, set the gl scissor to match the frame buffer size? Or, if `null` given, pop the scissor from the stack.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  setFramebuffer: function setFramebuffer(framebuffer, updateScissor) {\n    if (updateScissor === undefined) {\n      updateScissor = false;\n    }\n\n    var gl = this.gl;\n    var width = this.width;\n    var height = this.height;\n\n    if (framebuffer !== this.currentFramebuffer) {\n      if (framebuffer && framebuffer.renderTexture) {\n        width = framebuffer.renderTexture.width;\n        height = framebuffer.renderTexture.height;\n      } else {\n        this.flush();\n      }\n\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n      gl.viewport(0, 0, width, height);\n\n      if (updateScissor) {\n        if (framebuffer) {\n          this.drawingBufferHeight = height;\n          this.pushScissor(0, 0, width, height);\n        } else {\n          this.drawingBufferHeight = this.height;\n          this.popScissor();\n        }\n      }\n\n      this.currentFramebuffer = framebuffer;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Binds a program. If there was another program already bound it will force a pipeline flush.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setProgram\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The program that needs to be bound.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  setProgram: function setProgram(program) {\n    var gl = this.gl;\n\n    if (program !== this.currentProgram) {\n      this.flush();\n      gl.useProgram(program);\n      this.currentProgram = program;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Bounds a vertex buffer. If there is a vertex buffer already bound it'll force a pipeline flush.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setVertexBuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLBuffer} vertexBuffer - The buffer that needs to be bound.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  setVertexBuffer: function setVertexBuffer(vertexBuffer) {\n    var gl = this.gl;\n\n    if (vertexBuffer !== this.currentVertexBuffer) {\n      this.flush();\n      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n      this.currentVertexBuffer = vertexBuffer;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Bounds a index buffer. If there is a index buffer already bound it'll force a pipeline flush.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setIndexBuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLBuffer} indexBuffer - The buffer the needs to be bound.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  setIndexBuffer: function setIndexBuffer(indexBuffer) {\n    var gl = this.gl;\n\n    if (indexBuffer !== this.currentIndexBuffer) {\n      this.flush();\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\n      this.currentIndexBuffer = indexBuffer;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Creates a texture from an image source. If the source is not valid it creates an empty texture.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#createTextureFromSource\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} source - The source of the texture.\r\n   * @param {integer} width - The width of the texture.\r\n   * @param {integer} height - The height of the texture.\r\n   * @param {integer} scaleMode - The scale mode to be used by the texture.\r\n   *\r\n   * @return {?WebGLTexture} The WebGL Texture that was created, or `null` if it couldn't be created.\r\n   */\n  createTextureFromSource: function createTextureFromSource(source, width, height, scaleMode) {\n    var gl = this.gl;\n    var filter = gl.NEAREST;\n    var wrap = gl.CLAMP_TO_EDGE;\n    var texture = null;\n    width = source ? source.width : width;\n    height = source ? source.height : height;\n\n    if (IsSizePowerOfTwo(width, height)) {\n      wrap = gl.REPEAT;\n    }\n\n    if (scaleMode === CONST.ScaleModes.LINEAR && this.config.antialias) {\n      filter = gl.LINEAR;\n    }\n\n    if (!source && typeof width === 'number' && typeof height === 'number') {\n      texture = this.createTexture2D(0, filter, filter, wrap, wrap, gl.RGBA, null, width, height);\n    } else {\n      texture = this.createTexture2D(0, filter, filter, wrap, wrap, gl.RGBA, source);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * A wrapper for creating a WebGLTexture. If no pixel data is passed it will create an empty texture.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#createTexture2D\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} mipLevel - Mip level of the texture.\r\n   * @param {integer} minFilter - Filtering of the texture.\r\n   * @param {integer} magFilter - Filtering of the texture.\r\n   * @param {integer} wrapT - Wrapping mode of the texture.\r\n   * @param {integer} wrapS - Wrapping mode of the texture.\r\n   * @param {integer} format - Which format does the texture use.\r\n   * @param {object} pixels - pixel data.\r\n   * @param {integer} width - Width of the texture in pixels.\r\n   * @param {integer} height - Height of the texture in pixels.\r\n   * @param {boolean} pma - Does the texture have premultiplied alpha?\r\n   *\r\n   * @return {WebGLTexture} The WebGLTexture that was created.\r\n   */\n  createTexture2D: function createTexture2D(mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height, pma) {\n    pma = pma === undefined || pma === null ? true : pma;\n    var gl = this.gl;\n    var texture = gl.createTexture();\n    this.setTexture2D(texture, 0);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, pma);\n\n    if (pixels === null || pixels === undefined) {\n      gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl.UNSIGNED_BYTE, null);\n    } else {\n      gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, format, gl.UNSIGNED_BYTE, pixels);\n      width = pixels.width;\n      height = pixels.height;\n    }\n\n    this.setTexture2D(null, 0);\n    texture.isAlphaPremultiplied = pma;\n    texture.isRenderTexture = false;\n    texture.width = width;\n    texture.height = height;\n    this.nativeTextures.push(texture);\n    return texture;\n  },\n\n  /**\r\n   * Wrapper for creating WebGLFramebuffer.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#createFramebuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} width - Width in pixels of the framebuffer\r\n   * @param {integer} height - Height in pixels of the framebuffer\r\n   * @param {WebGLTexture} renderTexture - The color texture to where the color pixels are written\r\n   * @param {boolean} addDepthStencilBuffer - Indicates if the current framebuffer support depth and stencil buffers\r\n   *\r\n   * @return {WebGLFramebuffer} Raw WebGLFramebuffer\r\n   */\n  createFramebuffer: function createFramebuffer(width, height, renderTexture, addDepthStencilBuffer) {\n    var gl = this.gl;\n    var framebuffer = gl.createFramebuffer();\n    var complete = 0;\n    this.setFramebuffer(framebuffer);\n\n    if (addDepthStencilBuffer) {\n      var depthStencilBuffer = gl.createRenderbuffer();\n      gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);\n      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilBuffer);\n    }\n\n    renderTexture.isRenderTexture = true;\n    renderTexture.isAlphaPremultiplied = false;\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);\n    complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n    if (complete !== gl.FRAMEBUFFER_COMPLETE) {\n      var errors = {\n        36054: 'Incomplete Attachment',\n        36055: 'Missing Attachment',\n        36057: 'Incomplete Dimensions',\n        36061: 'Framebuffer Unsupported'\n      };\n      throw new Error('Framebuffer incomplete. Framebuffer status: ' + errors[complete]);\n    }\n\n    framebuffer.renderTexture = renderTexture;\n    this.setFramebuffer(null);\n    return framebuffer;\n  },\n\n  /**\r\n   * Wrapper for creating a WebGLProgram\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#createProgram\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} vertexShader - Source to the vertex shader\r\n   * @param {string} fragmentShader - Source to the fragment shader\r\n   *\r\n   * @return {WebGLProgram} Raw WebGLProgram\r\n   */\n  createProgram: function createProgram(vertexShader, fragmentShader) {\n    var gl = this.gl;\n    var program = gl.createProgram();\n    var vs = gl.createShader(gl.VERTEX_SHADER);\n    var fs = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(vs, vertexShader);\n    gl.shaderSource(fs, fragmentShader);\n    gl.compileShader(vs);\n    gl.compileShader(fs);\n\n    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n      throw new Error('Failed to compile Vertex Shader:\\n' + gl.getShaderInfoLog(vs));\n    }\n\n    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n      throw new Error('Failed to compile Fragment Shader:\\n' + gl.getShaderInfoLog(fs));\n    }\n\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      throw new Error('Failed to link program:\\n' + gl.getProgramInfoLog(program));\n    }\n\n    return program;\n  },\n\n  /**\r\n   * Wrapper for creating a vertex buffer.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#createVertexBuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {ArrayBuffer} initialDataOrSize - It's either ArrayBuffer or an integer indicating the size of the vbo\r\n   * @param {integer} bufferUsage - How the buffer is used. gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW\r\n   *\r\n   * @return {WebGLBuffer} Raw vertex buffer\r\n   */\n  createVertexBuffer: function createVertexBuffer(initialDataOrSize, bufferUsage) {\n    var gl = this.gl;\n    var vertexBuffer = gl.createBuffer();\n    this.setVertexBuffer(vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, initialDataOrSize, bufferUsage);\n    this.setVertexBuffer(null);\n    return vertexBuffer;\n  },\n\n  /**\r\n   * Wrapper for creating a vertex buffer.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#createIndexBuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {ArrayBuffer} initialDataOrSize - Either ArrayBuffer or an integer indicating the size of the vbo.\r\n   * @param {integer} bufferUsage - How the buffer is used. gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW.\r\n   *\r\n   * @return {WebGLBuffer} Raw index buffer\r\n   */\n  createIndexBuffer: function createIndexBuffer(initialDataOrSize, bufferUsage) {\n    var gl = this.gl;\n    var indexBuffer = gl.createBuffer();\n    this.setIndexBuffer(indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, initialDataOrSize, bufferUsage);\n    this.setIndexBuffer(null);\n    return indexBuffer;\n  },\n\n  /**\r\n   * Removes the given texture from the nativeTextures array and then deletes it from the GPU.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteTexture\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLTexture} texture - The WebGL Texture to be deleted.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  deleteTexture: function deleteTexture(texture) {\n    var index = this.nativeTextures.indexOf(texture);\n\n    if (index !== -1) {\n      SpliceOne(this.nativeTextures, index);\n    }\n\n    this.gl.deleteTexture(texture);\n\n    if (this.currentTextures[0] === texture && !this.game.pendingDestroy) {\n      //  texture we just deleted is in use, so bind a blank texture\n      this.setBlankTexture(true);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Deletes a WebGLFramebuffer from the GL instance.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteFramebuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLFramebuffer} framebuffer - The Framebuffer to be deleted.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  deleteFramebuffer: function deleteFramebuffer(framebuffer) {\n    this.gl.deleteFramebuffer(framebuffer);\n    return this;\n  },\n\n  /**\r\n   * Deletes a WebGLProgram from the GL instance.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteProgram\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The shader program to be deleted.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  deleteProgram: function deleteProgram(program) {\n    this.gl.deleteProgram(program);\n    return this;\n  },\n\n  /**\r\n   * Deletes a WebGLBuffer from the GL instance.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteBuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLBuffer} vertexBuffer - The WebGLBuffer to be deleted.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  deleteBuffer: function deleteBuffer(buffer) {\n    this.gl.deleteBuffer(buffer);\n    return this;\n  },\n\n  /**\r\n   * Controls the pre-render operations for the given camera.\r\n   * Handles any clipping needed by the camera and renders the background color if a color is visible.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#preRenderCamera\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to pre-render.\r\n   */\n  preRenderCamera: function preRenderCamera(camera) {\n    var cx = camera._cx;\n    var cy = camera._cy;\n    var cw = camera._cw;\n    var ch = camera._ch;\n    var TextureTintPipeline = this.pipelines.TextureTintPipeline;\n    var color = camera.backgroundColor;\n\n    if (camera.renderToTexture) {\n      this.flush();\n      this.pushScissor(cx, cy, cw, -ch);\n      this.setFramebuffer(camera.framebuffer);\n      var gl = this.gl;\n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      TextureTintPipeline.projOrtho(cx, cw + cx, cy, ch + cy, -1000, 1000);\n\n      if (color.alphaGL > 0) {\n        TextureTintPipeline.drawFillRect(cx, cy, cw + cx, ch + cy, Utils.getTintFromFloats(color.redGL, color.greenGL, color.blueGL, 1), color.alphaGL);\n      }\n\n      camera.emit(CameraEvents.PRE_RENDER, camera);\n    } else {\n      this.pushScissor(cx, cy, cw, ch);\n\n      if (color.alphaGL > 0) {\n        TextureTintPipeline.drawFillRect(cx, cy, cw, ch, Utils.getTintFromFloats(color.redGL, color.greenGL, color.blueGL, 1), color.alphaGL);\n      }\n    }\n  },\n\n  /**\r\n   * Controls the post-render operations for the given camera.\r\n   * Renders the foreground camera effects like flash and fading. It resets the current scissor state.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#postRenderCamera\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to post-render.\r\n   */\n  postRenderCamera: function postRenderCamera(camera) {\n    var TextureTintPipeline = this.pipelines.TextureTintPipeline;\n    camera.flashEffect.postRenderWebGL(TextureTintPipeline, Utils.getTintFromFloats);\n    camera.fadeEffect.postRenderWebGL(TextureTintPipeline, Utils.getTintFromFloats);\n    camera.dirty = false;\n    this.popScissor();\n\n    if (camera.renderToTexture) {\n      TextureTintPipeline.flush();\n      this.setFramebuffer(null);\n      camera.emit(CameraEvents.POST_RENDER, camera);\n      TextureTintPipeline.projOrtho(0, TextureTintPipeline.width, TextureTintPipeline.height, 0, -1000.0, 1000.0);\n      var getTint = Utils.getTintAppendFloatAlpha;\n      var pipeline = camera.pipeline ? camera.pipeline : TextureTintPipeline;\n      pipeline.batchTexture(camera, camera.glTexture, camera.width, camera.height, camera.x, camera.y, camera.width, camera.height, camera.zoom, camera.zoom, camera.rotation, camera.flipX, !camera.flipY, 1, 1, 0, 0, 0, 0, camera.width, camera.height, getTint(camera._tintTL, camera._alphaTL), getTint(camera._tintTR, camera._alphaTR), getTint(camera._tintBL, camera._alphaBL), getTint(camera._tintBR, camera._alphaBR), camera._isTinted && camera.tintFill, 0, 0, this.defaultCamera, null); //  Force clear the current texture so that items next in the batch (like Graphics) don't try and use it\n\n      this.setBlankTexture(true);\n    }\n  },\n\n  /**\r\n   * Clears the current vertex buffer and updates pipelines.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#preRender\r\n   * @since 3.0.0\r\n   */\n  preRender: function preRender() {\n    if (this.contextLost) {\n      return;\n    }\n\n    var gl = this.gl;\n    var pipelines = this.pipelines; //  Make sure we are bound to the main frame buffer\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n    if (this.config.clearBeforeRender) {\n      var clearColor = this.config.backgroundColor;\n      gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n    }\n\n    gl.enable(gl.SCISSOR_TEST);\n\n    for (var key in pipelines) {\n      pipelines[key].onPreRender();\n    } //  TODO - Find a way to stop needing to create these arrays every frame\n    //  and equally not need a huge array buffer created to hold them\n\n\n    this.currentScissor = [0, 0, this.width, this.height];\n    this.scissorStack = [this.currentScissor];\n\n    if (this.game.scene.customViewports) {\n      gl.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height);\n    }\n\n    this.setPipeline(this.pipelines.TextureTintPipeline);\n  },\n\n  /**\r\n   * The core render step for a Scene Camera.\r\n   * \r\n   * Iterates through the given Game Object's array and renders them with the given Camera.\r\n   * \r\n   * This is called by the `CameraManager.render` method. The Camera Manager instance belongs to a Scene, and is invoked\r\n   * by the Scene Systems.render method.\r\n   * \r\n   * This method is not called if `Camera.visible` is `false`, or `Camera.alpha` is zero.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#render\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Scene} scene - The Scene to render.\r\n   * @param {Phaser.GameObjects.GameObject} children - The Game Object's within the Scene to be rendered.\r\n   * @param {number} interpolationPercentage - The interpolation percentage to apply. Currently un-used.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera to render with.\r\n   */\n  render: function render(scene, children, interpolationPercentage, camera) {\n    if (this.contextLost) {\n      return;\n    }\n\n    var list = children.list;\n    var childCount = list.length;\n    var pipelines = this.pipelines;\n\n    for (var key in pipelines) {\n      pipelines[key].onRender(scene, camera);\n    } //   Apply scissor for cam region + render background color, if not transparent\n\n\n    this.preRenderCamera(camera);\n\n    for (var i = 0; i < childCount; i++) {\n      var child = list[i];\n\n      if (!child.willRender(camera)) {\n        continue;\n      }\n\n      if (child.blendMode !== this.currentBlendMode) {\n        this.setBlendMode(child.blendMode);\n      }\n\n      var mask = child.mask;\n\n      if (mask) {\n        mask.preRenderWebGL(this, child, camera);\n        child.renderWebGL(this, child, interpolationPercentage, camera);\n        mask.postRenderWebGL(this, child);\n      } else {\n        child.renderWebGL(this, child, interpolationPercentage, camera);\n      }\n    }\n\n    this.setBlendMode(CONST.BlendModes.NORMAL); //  Applies camera effects and pops the scissor, if set\n\n    this.postRenderCamera(camera);\n  },\n\n  /**\r\n   * The post-render step happens after all Cameras in all Scenes have been rendered.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#postRender\r\n   * @since 3.0.0\r\n   */\n  postRender: function postRender() {\n    if (this.contextLost) {\n      return;\n    }\n\n    this.flush(); // Unbind custom framebuffer here\n\n    var state = this.snapshotState;\n\n    if (state.callback) {\n      WebGLSnapshot(this.canvas, state);\n      state.callback = null;\n    }\n\n    var pipelines = this.pipelines;\n\n    for (var key in pipelines) {\n      pipelines[key].onPostRender();\n    }\n  },\n\n  /**\r\n   * Schedules a snapshot of the entire game viewport to be taken after the current frame is rendered.\r\n   * \r\n   * To capture a specific area see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.\r\n   * \r\n   * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n   * calling this method will override it.\r\n   * \r\n   * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n   * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n   * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n   * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshot\r\n   * @since 3.0.0\r\n   *\r\n   * @param {SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n   * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n   * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n   *\r\n   * @return {this} This WebGL Renderer.\r\n   */\n  snapshot: function snapshot(callback, type, encoderOptions) {\n    return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, callback, type, encoderOptions);\n  },\n\n  /**\r\n   * Schedules a snapshot of the given area of the game viewport to be taken after the current frame is rendered.\r\n   * \r\n   * To capture the whole game viewport see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.\r\n   * \r\n   * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n   * calling this method will override it.\r\n   * \r\n   * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n   * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n   * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n   * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotArea\r\n   * @since 3.16.0\r\n   *\r\n   * @param {integer} x - The x coordinate to grab from.\r\n   * @param {integer} y - The y coordinate to grab from.\r\n   * @param {integer} width - The width of the area to grab.\r\n   * @param {integer} height - The height of the area to grab.\r\n   * @param {SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n   * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n   * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n   *\r\n   * @return {this} This WebGL Renderer.\r\n   */\n  snapshotArea: function snapshotArea(x, y, width, height, callback, type, encoderOptions) {\n    var state = this.snapshotState;\n    state.callback = callback;\n    state.type = type;\n    state.encoder = encoderOptions;\n    state.getPixel = false;\n    state.x = x;\n    state.y = y;\n    state.width = Math.min(width, this.gl.drawingBufferWidth);\n    state.height = Math.min(height, this.gl.drawingBufferHeight);\n    return this;\n  },\n\n  /**\r\n   * Schedules a snapshot of the given pixel from the game viewport to be taken after the current frame is rendered.\r\n   * \r\n   * To capture the whole game viewport see the `snapshot` method. To capture a specific area, see `snapshotArea`.\r\n   * \r\n   * Only one snapshot can be active _per frame_. If you have already called `snapshotArea`, for example, then\r\n   * calling this method will override it.\r\n   * \r\n   * Unlike the other two snapshot methods, this one will return a `Color` object containing the color data for\r\n   * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,\r\n   * using less memory.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotPixel\r\n   * @since 3.16.0\r\n   *\r\n   * @param {integer} x - The x coordinate of the pixel to get.\r\n   * @param {integer} y - The y coordinate of the pixel to get.\r\n   * @param {SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.\r\n   *\r\n   * @return {this} This WebGL Renderer.\r\n   */\n  snapshotPixel: function snapshotPixel(x, y, callback) {\n    this.snapshotArea(x, y, 1, 1, callback);\n    this.snapshotState.getPixel = true;\n    return this;\n  },\n\n  /**\r\n   * Creates a WebGL Texture based on the given canvas element.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#canvasToTexture\r\n   * @since 3.0.0\r\n   *\r\n   * @param {HTMLCanvasElement} srcCanvas - The Canvas element that will be used to populate the texture.\r\n   * @param {WebGLTexture} [dstTexture] - Is this going to replace an existing texture? If so, pass it here.\r\n   * @param {boolean} [noRepeat=false] - Should this canvas never be allowed to set REPEAT? (such as for Text objects)\r\n   *\r\n   * @return {WebGLTexture} The newly created WebGL Texture.\r\n   */\n  canvasToTexture: function canvasToTexture(srcCanvas, dstTexture, noRepeat) {\n    if (noRepeat === undefined) {\n      noRepeat = false;\n    }\n\n    var gl = this.gl;\n\n    if (!dstTexture) {\n      var wrapping = gl.CLAMP_TO_EDGE;\n\n      if (!noRepeat && IsSizePowerOfTwo(srcCanvas.width, srcCanvas.height)) {\n        wrapping = gl.REPEAT;\n      }\n\n      var filter = this.config.antialias ? gl.LINEAR : gl.NEAREST;\n      dstTexture = this.createTexture2D(0, filter, filter, wrapping, wrapping, gl.RGBA, srcCanvas, srcCanvas.width, srcCanvas.height, true);\n    } else {\n      this.setTexture2D(dstTexture, 0);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);\n      dstTexture.width = srcCanvas.width;\n      dstTexture.height = srcCanvas.height;\n      this.setTexture2D(null, 0);\n    }\n\n    return dstTexture;\n  },\n\n  /**\r\n   * Sets the minification and magnification filter for a texture.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setTextureFilter\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} texture - The texture to set the filter for.\r\n   * @param {integer} filter - The filter to set. 0 for linear filtering, 1 for nearest neighbor (blocky) filtering.\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setTextureFilter: function setTextureFilter(texture, filter) {\n    var gl = this.gl;\n    var glFilter = [gl.LINEAR, gl.NEAREST][filter];\n    this.setTexture2D(texture, 0);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter);\n    this.setTexture2D(null, 0);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat1\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {number} x - [description]\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat1: function setFloat1(program, name, x) {\n    this.setProgram(program);\n    this.gl.uniform1f(this.gl.getUniformLocation(program, name), x);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat2\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat2: function setFloat2(program, name, x, y) {\n    this.setProgram(program);\n    this.gl.uniform2f(this.gl.getUniformLocation(program, name), x, y);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat3\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   * @param {number} z - [description]\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat3: function setFloat3(program, name, x, y, z) {\n    this.setProgram(program);\n    this.gl.uniform3f(this.gl.getUniformLocation(program, name), x, y, z);\n    return this;\n  },\n\n  /**\r\n   * Sets uniform of a WebGLProgram\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat4\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {number} x - X component\r\n   * @param {number} y - Y component\r\n   * @param {number} z - Z component\r\n   * @param {number} w - W component\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat4: function setFloat4(program, name, x, y, z, w) {\n    this.setProgram(program);\n    this.gl.uniform4f(this.gl.getUniformLocation(program, name), x, y, z, w);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat1v\r\n   * @since 3.13.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat1v: function setFloat1v(program, name, arr) {\n    this.setProgram(program);\n    this.gl.uniform1fv(this.gl.getUniformLocation(program, name), arr);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat2v\r\n   * @since 3.13.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat2v: function setFloat2v(program, name, arr) {\n    this.setProgram(program);\n    this.gl.uniform2fv(this.gl.getUniformLocation(program, name), arr);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat3v\r\n   * @since 3.13.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat3v: function setFloat3v(program, name, arr) {\n    this.setProgram(program);\n    this.gl.uniform3fv(this.gl.getUniformLocation(program, name), arr);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat4v\r\n   * @since 3.13.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat4v: function setFloat4v(program, name, arr) {\n    this.setProgram(program);\n    this.gl.uniform4fv(this.gl.getUniformLocation(program, name), arr);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt1\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {integer} x - [description]\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setInt1: function setInt1(program, name, x) {\n    this.setProgram(program);\n    this.gl.uniform1i(this.gl.getUniformLocation(program, name), x);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt2\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {integer} x - The new X component\r\n   * @param {integer} y - The new Y component\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setInt2: function setInt2(program, name, x, y) {\n    this.setProgram(program);\n    this.gl.uniform2i(this.gl.getUniformLocation(program, name), x, y);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt3\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {integer} x - The new X component\r\n   * @param {integer} y - The new Y component\r\n   * @param {integer} z - The new Z component\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setInt3: function setInt3(program, name, x, y, z) {\n    this.setProgram(program);\n    this.gl.uniform3i(this.gl.getUniformLocation(program, name), x, y, z);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt4\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {integer} x - X component\r\n   * @param {integer} y - Y component\r\n   * @param {integer} z - Z component\r\n   * @param {integer} w - W component\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setInt4: function setInt4(program, name, x, y, z, w) {\n    this.setProgram(program);\n    this.gl.uniform4i(this.gl.getUniformLocation(program, name), x, y, z, w);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a 2x2 matrix uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix2\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {boolean} transpose - The value indicating whether to transpose the matrix. Must be false.\r\n   * @param {Float32Array} matrix - The new matrix value.\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setMatrix2: function setMatrix2(program, name, transpose, matrix) {\n    this.setProgram(program);\n    this.gl.uniformMatrix2fv(this.gl.getUniformLocation(program, name), transpose, matrix);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix3\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {boolean} transpose - [description]\r\n   * @param {Float32Array} matrix - [description]\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setMatrix3: function setMatrix3(program, name, transpose, matrix) {\n    this.setProgram(program);\n    this.gl.uniformMatrix3fv(this.gl.getUniformLocation(program, name), transpose, matrix);\n    return this;\n  },\n\n  /**\r\n   * Sets uniform of a WebGLProgram\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix4\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {boolean} transpose - Is the matrix transposed\r\n   * @param {Float32Array} matrix - Matrix data\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setMatrix4: function setMatrix4(program, name, transpose, matrix) {\n    this.setProgram(program);\n    this.gl.uniformMatrix4fv(this.gl.getUniformLocation(program, name), transpose, matrix);\n    return this;\n  },\n\n  /**\r\n   * Returns the maximum number of texture units that can be used in a fragment shader.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#getMaxTextures\r\n   * @since 3.8.0\r\n   *\r\n   * @return {integer} The maximum number of textures WebGL supports.\r\n   */\n  getMaxTextures: function getMaxTextures() {\n    return this.config.maxTextures;\n  },\n\n  /**\r\n   * Returns the largest texture size (either width or height) that can be created.\r\n   * Note that VRAM may not allow a texture of any given size, it just expresses\r\n   * hardware / driver support for a given size.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#getMaxTextureSize\r\n   * @since 3.8.0\r\n   *\r\n   * @return {integer} The maximum supported texture size.\r\n   */\n  getMaxTextureSize: function getMaxTextureSize() {\n    return this.config.maxTextureSize;\n  },\n\n  /**\r\n   * Destroy this WebGLRenderer, cleaning up all related resources such as pipelines, native textures, etc.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    //  Clear-up anything that should be cleared :)\n    for (var key in this.pipelines) {\n      this.pipelines[key].destroy();\n      delete this.pipelines[key];\n    }\n\n    for (var index = 0; index < this.nativeTextures.length; index++) {\n      this.deleteTexture(this.nativeTextures[index]);\n      delete this.nativeTextures[index];\n    }\n\n    delete this.gl;\n    delete this.game;\n    this.contextLost = true;\n    this.extensions = {};\n    this.nativeTextures.length = 0;\n  }\n});\nmodule.exports = WebGLRenderer;","map":null,"metadata":{},"sourceType":"script"}