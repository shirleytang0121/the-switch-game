{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Angle = require('../math/angle/Between');\n\nvar Class = require('../utils/Class');\n\nvar Distance = require('../math/distance/DistanceBetween');\n\nvar FuzzyEqual = require('../math/fuzzy/Equal');\n\nvar SmoothStepInterpolation = require('../math/interpolation/SmoothStepInterpolation');\n\nvar Vector2 = require('../math/Vector2');\n/**\r\n * @classdesc\r\n * A Pointer object encapsulates both mouse and touch input within Phaser.\r\n *\r\n * By default, Phaser will create 2 pointers for your game to use. If you require more, i.e. for a multi-touch\r\n * game, then use the `InputPlugin.addPointer` method to do so, rather than instantiating this class directly,\r\n * otherwise it won't be managed by the input system.\r\n *\r\n * You can reference the current active pointer via `InputPlugin.activePointer`. You can also use the properties\r\n * `InputPlugin.pointer1` through to `pointer10`, for each pointer you have enabled in your game.\r\n *\r\n * The properties of this object are set by the Input Plugin during processing. This object is then sent in all\r\n * input related events that the Input Plugin emits, so you can reference properties from it directly in your\r\n * callbacks.\r\n *\r\n * @class Pointer\r\n * @memberof Phaser.Input\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.InputManager} manager - A reference to the Input Manager.\r\n * @param {integer} id - The internal ID of this Pointer.\r\n */\n\n\nvar Pointer = new Class({\n  initialize: function Pointer(manager, id) {\n    /**\r\n     * A reference to the Input Manager.\r\n     *\r\n     * @name Phaser.Input.Pointer#manager\r\n     * @type {Phaser.Input.InputManager}\r\n     * @since 3.0.0\r\n     */\n    this.manager = manager;\n    /**\r\n     * The internal ID of this Pointer.\r\n     *\r\n     * @name Phaser.Input.Pointer#id\r\n     * @type {integer}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\n\n    this.id = id;\n    /**\r\n     * The most recent native DOM Event this Pointer has processed.\r\n     *\r\n     * @name Phaser.Input.Pointer#event\r\n     * @type {(TouchEvent|MouseEvent)}\r\n     * @since 3.0.0\r\n     */\n\n    this.event;\n    /**\r\n     * The DOM element the Pointer was pressed down on, taken from the DOM event.\r\n     *\r\n     * @name Phaser.Input.Pointer#downElement\r\n     * @type {any}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\n\n    this.downElement;\n    /**\r\n     * The DOM element the Pointer was released on, taken from the DOM event.\r\n     *\r\n     * @name Phaser.Input.Pointer#upElement\r\n     * @type {any}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\n\n    this.upElement;\n    /**\r\n     * The camera the Pointer interacted with during its last update.\r\n     * \r\n     * A Pointer can only ever interact with one camera at once, which will be the top-most camera\r\n     * in the list should multiple cameras be positioned on-top of each other.\r\n     *\r\n     * @name Phaser.Input.Pointer#camera\r\n     * @type {Phaser.Cameras.Scene2D.Camera}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.camera = null;\n    /**\r\n     * 0: No button or un-initialized\r\n     * 1: Left button\r\n     * 2: Right button\r\n     * 4: Wheel button or middle button\r\n     * 8: 4th button (typically the \"Browser Back\" button)\r\n     * 16: 5th button (typically the \"Browser Forward\" button)\r\n     * \r\n     * For a mouse configured for left-handed use, the button actions are reversed.\r\n     * In this case, the values are read from right to left.\r\n     *\r\n     * @name Phaser.Input.Pointer#buttons\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.buttons = 0;\n    /**\r\n     * The position of the Pointer in screen space.\r\n     *\r\n     * @name Phaser.Input.Pointer#position\r\n     * @type {Phaser.Math.Vector2}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\n\n    this.position = new Vector2();\n    /**\r\n     * The previous position of the Pointer in screen space.\r\n     * \r\n     * The old x and y values are stored in here during the InputManager.transformPointer call.\r\n     * \r\n     * Use the properties `velocity`, `angle` and `distance` to create your own gesture recognition.\r\n     *\r\n     * @name Phaser.Input.Pointer#prevPosition\r\n     * @type {Phaser.Math.Vector2}\r\n     * @readonly\r\n     * @since 3.11.0\r\n     */\n\n    this.prevPosition = new Vector2();\n    /**\r\n     * An internal vector used for calculations of the pointer speed and angle.\r\n     *\r\n     * @name Phaser.Input.Pointer#midPoint\r\n     * @type {Phaser.Math.Vector2}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this.midPoint = new Vector2(-1, -1);\n    /**\r\n     * The current velocity of the Pointer, based on its current and previous positions.\r\n     * \r\n     * This value is smoothed out each frame, according to the `motionFactor` property.\r\n     * \r\n     * This property is updated whenever the Pointer moves, regardless of any button states. In other words,\r\n     * it changes based on movement alone - a button doesn't have to be pressed first.\r\n     *\r\n     * @name Phaser.Input.Pointer#velocity\r\n     * @type {Phaser.Math.Vector2}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\n\n    this.velocity = new Vector2();\n    /**\r\n     * The current angle the Pointer is moving, in radians, based on its previous and current position.\r\n     * \r\n     * The angle is based on the old position facing to the current position.\r\n     * \r\n     * This property is updated whenever the Pointer moves, regardless of any button states. In other words,\r\n     * it changes based on movement alone - a button doesn't have to be pressed first.\r\n     *\r\n     * @name Phaser.Input.Pointer#angle\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\n\n    this.angle = 0;\n    /**\r\n     * The distance the Pointer has moved, based on its previous and current position.\r\n     * \r\n     * This value is smoothed out each frame, according to the `motionFactor` property.\r\n     * \r\n     * This property is updated whenever the Pointer moves, regardless of any button states. In other words,\r\n     * it changes based on movement alone - a button doesn't have to be pressed first.\r\n     * \r\n     * If you need the total distance travelled since the primary buttons was pressed down,\r\n     * then use the `Pointer.getDistance` method.\r\n     *\r\n     * @name Phaser.Input.Pointer#distance\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\n\n    this.distance = 0;\n    /**\r\n     * The smoothing factor to apply to the Pointer position.\r\n     * \r\n     * Due to their nature, pointer positions are inherently noisy. While this is fine for lots of games, if you need cleaner positions\r\n     * then you can set this value to apply an automatic smoothing to the positions as they are recorded.\r\n     * \r\n     * The default value of zero means 'no smoothing'.\r\n     * Set to a small value, such as 0.2, to apply an average level of smoothing between positions. You can do this by changing this\r\n     * value directly, or by setting the `input.smoothFactor` property in the Game Config.\r\n     * \r\n     * Positions are only smoothed when the pointer moves. If the primary button on this Pointer enters an Up or Down state, then the position\r\n     * is always precise, and not smoothed.\r\n     *\r\n     * @name Phaser.Input.Pointer#smoothFactor\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.16.0\r\n     */\n\n    this.smoothFactor = 0;\n    /**\r\n     * The factor applied to the motion smoothing each frame.\r\n     * \r\n     * This value is passed to the Smooth Step Interpolation that is used to calculate the velocity,\r\n     * angle and distance of the Pointer. It's applied every frame, until the midPoint reaches the current\r\n     * position of the Pointer. 0.2 provides a good average but can be increased if you need a\r\n     * quicker update and are working in a high performance environment. Never set this value to\r\n     * zero.\r\n     *\r\n     * @name Phaser.Input.Pointer#motionFactor\r\n     * @type {number}\r\n     * @default 0.2\r\n     * @since 3.16.0\r\n     */\n\n    this.motionFactor = 0.2;\n    /**\r\n     * The x position of this Pointer, translated into the coordinate space of the most recent Camera it interacted with.\r\n     *\r\n     * @name Phaser.Input.Pointer#worldX\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.10.0\r\n     */\n\n    this.worldX = 0;\n    /**\r\n     * The y position of this Pointer, translated into the coordinate space of the most recent Camera it interacted with.\r\n     *\r\n     * @name Phaser.Input.Pointer#worldY\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.10.0\r\n     */\n\n    this.worldY = 0;\n    /**\r\n     * Time when this Pointer was most recently moved (regardless of the state of its buttons, if any)\r\n     *\r\n     * @name Phaser.Input.Pointer#moveTime\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.moveTime = 0;\n    /**\r\n     * X coordinate of the Pointer when Button 1 (left button), or Touch, was pressed, used for dragging objects.\r\n     *\r\n     * @name Phaser.Input.Pointer#downX\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.downX = 0;\n    /**\r\n     * Y coordinate of the Pointer when Button 1 (left button), or Touch, was pressed, used for dragging objects.\r\n     *\r\n     * @name Phaser.Input.Pointer#downY\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.downY = 0;\n    /**\r\n     * Time when Button 1 (left button), or Touch, was pressed, used for dragging objects.\r\n     *\r\n     * @name Phaser.Input.Pointer#downTime\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.downTime = 0;\n    /**\r\n     * X coordinate of the Pointer when Button 1 (left button), or Touch, was released, used for dragging objects.\r\n     *\r\n     * @name Phaser.Input.Pointer#upX\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.upX = 0;\n    /**\r\n     * Y coordinate of the Pointer when Button 1 (left button), or Touch, was released, used for dragging objects.\r\n     *\r\n     * @name Phaser.Input.Pointer#upY\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.upY = 0;\n    /**\r\n     * Time when Button 1 (left button), or Touch, was released, used for dragging objects.\r\n     *\r\n     * @name Phaser.Input.Pointer#upTime\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.upTime = 0;\n    /**\r\n     * Is the primary button down? (usually button 0, the left mouse button)\r\n     *\r\n     * @name Phaser.Input.Pointer#primaryDown\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.primaryDown = false;\n    /**\r\n     * Is _any_ button on this pointer considered as being down?\r\n     *\r\n     * @name Phaser.Input.Pointer#isDown\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.isDown = false;\n    /**\r\n     * A dirty flag for this Pointer, used internally by the Input Plugin.\r\n     *\r\n     * @name Phaser.Input.Pointer#dirty\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.dirty = false;\n    /**\r\n     * Is this Pointer considered as being \"just down\" or not?\r\n     *\r\n     * @name Phaser.Input.Pointer#justDown\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.justDown = false;\n    /**\r\n     * Is this Pointer considered as being \"just up\" or not?\r\n     *\r\n     * @name Phaser.Input.Pointer#justUp\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.justUp = false;\n    /**\r\n     * Is this Pointer considered as being \"just moved\" or not?\r\n     *\r\n     * @name Phaser.Input.Pointer#justMoved\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.justMoved = false;\n    /**\r\n     * Did the previous input event come from a Touch input (true) or Mouse? (false)\r\n     *\r\n     * @name Phaser.Input.Pointer#wasTouch\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.wasTouch = false;\n    /**\r\n     * Did this Pointer get canceled by a touchcancel event?\r\n     * \r\n     * Note: \"canceled\" is the American-English spelling of \"cancelled\". Please don't submit PRs correcting it!\r\n     *\r\n     * @name Phaser.Input.Pointer#wasCanceled\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.15.0\r\n     */\n\n    this.wasCanceled = false;\n    /**\r\n     * If the mouse is locked, the horizontal relative movement of the Pointer in pixels since last frame.\r\n     *\r\n     * @name Phaser.Input.Pointer#movementX\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.movementX = 0;\n    /**\r\n     * If the mouse is locked, the vertical relative movement of the Pointer in pixels since last frame.\r\n     *\r\n     * @name Phaser.Input.Pointer#movementY\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.movementY = 0;\n    /**\r\n     * The identifier property of the Pointer as set by the DOM event when this Pointer is started.\r\n     *\r\n     * @name Phaser.Input.Pointer#identifier\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\n\n    this.identifier = 0;\n    /**\r\n     * The pointerId property of the Pointer as set by the DOM event when this Pointer is started.\r\n     * The browser can and will recycle this value.\r\n     *\r\n     * @name Phaser.Input.Pointer#pointerId\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\n\n    this.pointerId = null;\n    /**\r\n     * An active Pointer is one that is currently pressed down on the display.\r\n     * A Mouse is always considered as active.\r\n     *\r\n     * @name Phaser.Input.Pointer#active\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\n\n    this.active = id === 0 ? true : false;\n    /**\r\n     * Time when this Pointer was most recently updated by the Game step.\r\n     *\r\n     * @name Phaser.Input.Pointer#time\r\n     * @type {number}\r\n     * @since 3.16.0\r\n     */\n\n    this.time = 0;\n  },\n\n  /**\r\n   * Takes a Camera and returns a Vector2 containing the translated position of this Pointer\r\n   * within that Camera. This can be used to convert this Pointers position into camera space.\r\n   *\r\n   * @method Phaser.Input.Pointer#positionToCamera\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use for the translation.\r\n   * @param {(Phaser.Math.Vector2|object)} [output] - A Vector2-like object in which to store the translated position.\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} A Vector2 containing the translated coordinates of this Pointer, based on the given camera.\r\n   */\n  positionToCamera: function positionToCamera(camera, output) {\n    return camera.getWorldPoint(this.x, this.y, output);\n  },\n\n  /**\r\n   * Resets the temporal properties of this Pointer.\r\n   * This method is called automatically each frame by the Input Manager.\r\n   *\r\n   * @method Phaser.Input.Pointer#reset\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  reset: function reset(time) {\n    this.dirty = false;\n    this.justDown = false;\n    this.justUp = false;\n    this.justMoved = false;\n    this.time = time;\n    this.movementX = 0;\n    this.movementY = 0;\n  },\n\n  /**\r\n   * Calculates the motion of this Pointer, including its velocity and angle of movement.\r\n   * This method is called automatically each frame by the Input Manager.\r\n   *\r\n   * @method Phaser.Input.Pointer#updateMotion\r\n   * @private\r\n   * @since 3.16.0\r\n   */\n  updateMotion: function updateMotion() {\n    var cx = this.position.x;\n    var cy = this.position.y;\n    var mx = this.midPoint.x;\n    var my = this.midPoint.y;\n\n    if (cx === mx && cy === my) {\n      //  Nothing to do here\n      return;\n    } //  Moving towards our goal ...\n\n\n    var vx = SmoothStepInterpolation(this.motionFactor, mx, cx);\n    var vy = SmoothStepInterpolation(this.motionFactor, my, cy);\n\n    if (FuzzyEqual(vx, cx, 0.1)) {\n      vx = cx;\n    }\n\n    if (FuzzyEqual(vy, cy, 0.1)) {\n      vy = cy;\n    }\n\n    this.midPoint.set(vx, vy);\n    var dx = cx - vx;\n    var dy = cy - vy;\n    this.velocity.set(dx, dy);\n    this.angle = Angle(vx, vy, cx, cy);\n    this.distance = Math.sqrt(dx * dx + dy * dy);\n  },\n\n  /**\r\n   * Internal method to handle a Mouse Up Event.\r\n   *\r\n   * @method Phaser.Input.Pointer#up\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {MouseEvent} event - The Mouse Event to process.\r\n   * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n   */\n  up: function up(event, time) {\n    if ('buttons' in event) {\n      this.buttons = event.buttons;\n    }\n\n    this.event = event;\n    this.upElement = event.target; //  Sets the local x/y properties\n\n    this.manager.transformPointer(this, event.pageX, event.pageY, false); //  0: Main button pressed, usually the left button or the un-initialized state\n\n    if (event.button === 0) {\n      this.primaryDown = false;\n      this.upX = this.x;\n      this.upY = this.y;\n      this.upTime = time;\n    }\n\n    this.justUp = true;\n    this.isDown = false;\n    this.dirty = true;\n    this.wasTouch = false;\n  },\n\n  /**\r\n   * Internal method to handle a Mouse Down Event.\r\n   *\r\n   * @method Phaser.Input.Pointer#down\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {MouseEvent} event - The Mouse Event to process.\r\n   * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n   */\n  down: function down(event, time) {\n    if ('buttons' in event) {\n      this.buttons = event.buttons;\n    }\n\n    this.event = event;\n    this.downElement = event.target; //  Sets the local x/y properties\n\n    this.manager.transformPointer(this, event.pageX, event.pageY, false); //  0: Main button pressed, usually the left button or the un-initialized state\n\n    if (event.button === 0) {\n      this.primaryDown = true;\n      this.downX = this.x;\n      this.downY = this.y;\n      this.downTime = time;\n    }\n\n    this.justDown = true;\n    this.isDown = true;\n    this.dirty = true;\n    this.wasTouch = false;\n  },\n\n  /**\r\n   * Internal method to handle a Mouse Move Event.\r\n   *\r\n   * @method Phaser.Input.Pointer#move\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {MouseEvent} event - The Mouse Event to process.\r\n   * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n   */\n  move: function move(event, time) {\n    if ('buttons' in event) {\n      this.buttons = event.buttons;\n    }\n\n    this.event = event; //  Sets the local x/y properties\n\n    this.manager.transformPointer(this, event.pageX, event.pageY, true);\n\n    if (this.manager.mouse.locked) {\n      // Multiple DOM events may occur within one frame, but only one Phaser event will fire\n      this.movementX += event.movementX || event.mozMovementX || event.webkitMovementX || 0;\n      this.movementY += event.movementY || event.mozMovementY || event.webkitMovementY || 0;\n    }\n\n    this.justMoved = true;\n    this.moveTime = time;\n    this.dirty = true;\n    this.wasTouch = false;\n  },\n\n  /**\r\n   * Internal method to handle a Touch Start Event.\r\n   *\r\n   * @method Phaser.Input.Pointer#touchstart\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {TouchEvent} event - The Touch Event to process.\r\n   * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n   */\n  touchstart: function touchstart(event, time) {\n    if (event['pointerId']) {\n      this.pointerId = event.pointerId;\n    }\n\n    this.identifier = event.identifier;\n    this.target = event.target;\n    this.active = true;\n    this.buttons = 1;\n    this.event = event;\n    this.downElement = event.target; //  Sets the local x/y properties\n\n    this.manager.transformPointer(this, event.pageX, event.pageY, false);\n    this.primaryDown = true;\n    this.downX = this.x;\n    this.downY = this.y;\n    this.downTime = time;\n    this.justDown = true;\n    this.isDown = true;\n    this.dirty = true;\n    this.wasTouch = true;\n    this.wasCanceled = false;\n  },\n\n  /**\r\n   * Internal method to handle a Touch Move Event.\r\n   *\r\n   * @method Phaser.Input.Pointer#touchmove\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {TouchEvent} event - The Touch Event to process.\r\n   * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n   */\n  touchmove: function touchmove(event, time) {\n    this.event = event; //  Sets the local x/y properties\n\n    this.manager.transformPointer(this, event.pageX, event.pageY, true);\n    this.justMoved = true;\n    this.moveTime = time;\n    this.dirty = true;\n    this.wasTouch = true;\n  },\n\n  /**\r\n   * Internal method to handle a Touch End Event.\r\n   *\r\n   * @method Phaser.Input.Pointer#touchend\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {TouchEvent} event - The Touch Event to process.\r\n   * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n   */\n  touchend: function touchend(event, time) {\n    this.buttons = 0;\n    this.event = event;\n    this.upElement = event.target; //  Sets the local x/y properties\n\n    this.manager.transformPointer(this, event.pageX, event.pageY, false);\n    this.primaryDown = false;\n    this.upX = this.x;\n    this.upY = this.y;\n    this.upTime = time;\n    this.justUp = true;\n    this.isDown = false;\n    this.dirty = true;\n    this.wasTouch = true;\n    this.wasCanceled = false;\n    this.active = false;\n  },\n\n  /**\r\n   * Internal method to handle a Touch Cancel Event.\r\n   *\r\n   * @method Phaser.Input.Pointer#touchcancel\r\n   * @private\r\n   * @since 3.15.0\r\n   *\r\n   * @param {TouchEvent} event - The Touch Event to process.\r\n   */\n  touchcancel: function touchcancel(event) {\n    this.buttons = 0;\n    this.event = event;\n    this.primaryDown = false;\n    this.justUp = false;\n    this.isDown = false;\n    this.dirty = true;\n    this.wasTouch = true;\n    this.wasCanceled = true;\n    this.active = false;\n  },\n\n  /**\r\n   * Checks to see if any buttons are being held down on this Pointer.\r\n   *\r\n   * @method Phaser.Input.Pointer#noButtonDown\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` if no buttons are being held down.\r\n   */\n  noButtonDown: function noButtonDown() {\n    return this.buttons === 0;\n  },\n\n  /**\r\n   * Checks to see if the left button is being held down on this Pointer.\r\n   *\r\n   * @method Phaser.Input.Pointer#leftButtonDown\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` if the left button is being held down.\r\n   */\n  leftButtonDown: function leftButtonDown() {\n    return this.buttons & 1 ? true : false;\n  },\n\n  /**\r\n   * Checks to see if the right button is being held down on this Pointer.\r\n   *\r\n   * @method Phaser.Input.Pointer#rightButtonDown\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` if the right button is being held down.\r\n   */\n  rightButtonDown: function rightButtonDown() {\n    return this.buttons & 2 ? true : false;\n  },\n\n  /**\r\n   * Checks to see if the middle button is being held down on this Pointer.\r\n   *\r\n   * @method Phaser.Input.Pointer#middleButtonDown\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` if the middle button is being held down.\r\n   */\n  middleButtonDown: function middleButtonDown() {\n    return this.buttons & 4 ? true : false;\n  },\n\n  /**\r\n   * Checks to see if the back button is being held down on this Pointer.\r\n   *\r\n   * @method Phaser.Input.Pointer#backButtonDown\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` if the back button is being held down.\r\n   */\n  backButtonDown: function backButtonDown() {\n    return this.buttons & 8 ? true : false;\n  },\n\n  /**\r\n   * Checks to see if the forward button is being held down on this Pointer.\r\n   *\r\n   * @method Phaser.Input.Pointer#forwardButtonDown\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` if the forward button is being held down.\r\n   */\n  forwardButtonDown: function forwardButtonDown() {\n    return this.buttons & 16 ? true : false;\n  },\n\n  /**\r\n   * If the Pointer has a button pressed down at the time this method is called, it will return the\r\n   * distance between the Pointer's `downX` and `downY` values and the current position.\r\n   * \r\n   * If no button is held down, it will return the last recorded distance, based on where\r\n   * the Pointer was when the button was released.\r\n   * \r\n   * If you wish to get the distance being travelled currently, based on the velocity of the Pointer,\r\n   * then see the `Pointer.distance` property.\r\n   *\r\n   * @method Phaser.Input.Pointer#getDistance\r\n   * @since 3.13.0\r\n   *\r\n   * @return {number} The distance the Pointer moved.\r\n   */\n  getDistance: function getDistance() {\n    if (this.isDown) {\n      return Distance(this.downX, this.downY, this.x, this.y);\n    } else {\n      return Distance(this.downX, this.downY, this.upX, this.upY);\n    }\n  },\n\n  /**\r\n   * If the Pointer has a button pressed down at the time this method is called, it will return the\r\n   * horizontal distance between the Pointer's `downX` and `downY` values and the current position.\r\n   * \r\n   * If no button is held down, it will return the last recorded horizontal distance, based on where\r\n   * the Pointer was when the button was released.\r\n   *\r\n   * @method Phaser.Input.Pointer#getDistanceX\r\n   * @since 3.16.0\r\n   *\r\n   * @return {number} The horizontal distance the Pointer moved.\r\n   */\n  getDistanceX: function getDistanceX() {\n    if (this.isDown) {\n      return Math.abs(this.downX - this.x);\n    } else {\n      return Math.abs(this.downX - this.upX);\n    }\n  },\n\n  /**\r\n   * If the Pointer has a button pressed down at the time this method is called, it will return the\r\n   * vertical distance between the Pointer's `downX` and `downY` values and the current position.\r\n   * \r\n   * If no button is held down, it will return the last recorded vertical distance, based on where\r\n   * the Pointer was when the button was released.\r\n   *\r\n   * @method Phaser.Input.Pointer#getDistanceY\r\n   * @since 3.16.0\r\n   *\r\n   * @return {number} The vertical distance the Pointer moved.\r\n   */\n  getDistanceY: function getDistanceY() {\n    if (this.isDown) {\n      return Math.abs(this.downY - this.y);\n    } else {\n      return Math.abs(this.downY - this.upY);\n    }\n  },\n\n  /**\r\n   * If the Pointer has a button pressed down at the time this method is called, it will return the\r\n   * duration since the Pointer's was pressed down.\r\n   * \r\n   * If no button is held down, it will return the last recorded duration, based on the time\r\n   * the Pointer button was released.\r\n   *\r\n   * @method Phaser.Input.Pointer#getDuration\r\n   * @since 3.16.0\r\n   *\r\n   * @return {number} The duration the Pointer was held down for in milliseconds.\r\n   */\n  getDuration: function getDuration() {\n    if (this.isDown) {\n      return this.time - this.downTime;\n    } else {\n      return this.upTime - this.downTime;\n    }\n  },\n\n  /**\r\n   * If the Pointer has a button pressed down at the time this method is called, it will return the\r\n   * angle between the Pointer's `downX` and `downY` values and the current position.\r\n   * \r\n   * If no button is held down, it will return the last recorded angle, based on where\r\n   * the Pointer was when the button was released.\r\n   * \r\n   * The angle is based on the old position facing to the current position.\r\n   * \r\n   * If you wish to get the current angle, based on the velocity of the Pointer, then\r\n   * see the `Pointer.angle` property.\r\n   *\r\n   * @method Phaser.Input.Pointer#getAngle\r\n   * @since 3.16.0\r\n   *\r\n   * @return {number} The angle between the Pointer's coordinates in radians.\r\n   */\n  getAngle: function getAngle() {\n    if (this.isDown) {\n      return Angle(this.downX, this.downY, this.x, this.y);\n    } else {\n      return Angle(this.downX, this.downY, this.upX, this.upY);\n    }\n  },\n\n  /**\r\n   * Takes the previous and current Pointer positions and then generates an array of interpolated values between\r\n   * the two. The array will be populated up to the size of the `steps` argument.\r\n   * \r\n   * ```javaScript\r\n   * var points = pointer.getInterpolatedPosition(4);\r\n   * \r\n   * // points[0] = { x: 0, y: 0 }\r\n   * // points[1] = { x: 2, y: 1 }\r\n   * // points[2] = { x: 3, y: 2 }\r\n   * // points[3] = { x: 6, y: 3 }\r\n   * ```\r\n   * \r\n   * Use this if you need to get smoothed values between the previous and current pointer positions. DOM pointer\r\n   * events can often fire faster than the main browser loop, and this will help you avoid janky movement\r\n   * especially if you have an object following a Pointer.\r\n   * \r\n   * Note that if you provide an output array it will only be populated up to the number of steps provided.\r\n   * It will not clear any previous data that may have existed beyond the range of the steps count.\r\n   * \r\n   * Internally it uses the Smooth Step interpolation calculation.\r\n   *\r\n   * @method Phaser.Input.Pointer#getInterpolatedPosition\r\n   * @since 3.11.0\r\n   * \r\n   * @param {integer} [steps=10] - The number of interpolation steps to use.\r\n   * @param {array} [out] - An array to store the results in. If not provided a new one will be created.\r\n   * \r\n   * @return {array} An array of interpolated values.\r\n   */\n  getInterpolatedPosition: function getInterpolatedPosition(steps, out) {\n    if (steps === undefined) {\n      steps = 10;\n    }\n\n    if (out === undefined) {\n      out = [];\n    }\n\n    var prevX = this.prevPosition.x;\n    var prevY = this.prevPosition.y;\n    var curX = this.position.x;\n    var curY = this.position.y;\n\n    for (var i = 0; i < steps; i++) {\n      var t = 1 / steps * i;\n      out[i] = {\n        x: SmoothStepInterpolation(t, prevX, curX),\n        y: SmoothStepInterpolation(t, prevY, curY)\n      };\n    }\n\n    return out;\n  },\n\n  /**\r\n   * Destroys this Pointer instance and resets its external references.\r\n   *\r\n   * @method Phaser.Input.Pointer#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    this.camera = null;\n    this.manager = null;\n    this.position = null;\n  },\n\n  /**\r\n   * The x position of this Pointer.\r\n   * The value is in screen space.\r\n   * See `worldX` to get a camera converted position.\r\n   *\r\n   * @name Phaser.Input.Pointer#x\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  x: {\n    get: function get() {\n      return this.position.x;\n    },\n    set: function set(value) {\n      this.position.x = value;\n    }\n  },\n\n  /**\r\n   * The y position of this Pointer.\r\n   * The value is in screen space.\r\n   * See `worldY` to get a camera converted position.\r\n   *\r\n   * @name Phaser.Input.Pointer#y\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  y: {\n    get: function get() {\n      return this.position.y;\n    },\n    set: function set(value) {\n      this.position.y = value;\n    }\n  }\n});\nmodule.exports = Pointer;","map":null,"metadata":{},"sourceType":"script"}