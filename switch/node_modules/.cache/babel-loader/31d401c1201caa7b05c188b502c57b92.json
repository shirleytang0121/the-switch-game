{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar Clamp = require('../math/Clamp');\n\nvar Color = require('../display/color/Color');\n\nvar IsSizePowerOfTwo = require('../math/pow2/IsSizePowerOfTwo');\n\nvar Texture = require('./Texture');\n/**\r\n * @classdesc\r\n * A Canvas Texture is a special kind of Texture that is backed by an HTML Canvas Element as its source.\r\n *\r\n * You can use the properties of this texture to draw to the canvas element directly, using all of the standard\r\n * canvas operations available in the browser. Any Game Object can be given this texture and will render with it.\r\n *\r\n * Note: When running under WebGL the Canvas Texture needs to re-generate its base WebGLTexture and reupload it to\r\n * the GPU every time you modify it, otherwise the changes you make to this texture will not be visible. To do this\r\n * you should call `CanvasTexture.refresh()` once you are finished with your changes to the canvas. Try and keep\r\n * this to a minimum, especially on large canvas sizes, or you may inadvertently thrash the GPU by constantly uploading\r\n * texture data to it. This restriction does not apply if using the Canvas Renderer.\r\n * \r\n * It starts with only one frame that covers the whole of the canvas. You can add further frames, that specify\r\n * sections of the canvas using the `add` method.\r\n * \r\n * Should you need to resize the canvas use the `setSize` method so that it accurately updates all of the underlying\r\n * texture data as well. Forgetting to do this (i.e. by changing the canvas size directly from your code) could cause\r\n * graphical errors.\r\n *\r\n * @class CanvasTexture\r\n * @extends Phaser.Textures.Texture\r\n * @memberof Phaser.Textures\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Textures.CanvasTexture} manager - A reference to the Texture Manager this Texture belongs to.\r\n * @param {string} key - The unique string-based key of this Texture.\r\n * @param {HTMLCanvasElement} source - The canvas element that is used as the base of this texture.\r\n * @param {integer} width - The width of the canvas.\r\n * @param {integer} height - The height of the canvas.\r\n */\n\n\nvar CanvasTexture = new Class({\n  Extends: Texture,\n  initialize: function CanvasTexture(manager, key, source, width, height) {\n    Texture.call(this, manager, key, source, width, height);\n    this.add('__BASE', 0, 0, 0, width, height);\n    /**\r\n     * A reference to the Texture Source of this Canvas.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#_source\r\n     * @type {Phaser.Textures.TextureSource}\r\n     * @private\r\n     * @since 3.7.0\r\n     */\n\n    this._source = this.frames['__BASE'].source;\n    /**\r\n     * The source Canvas Element.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#canvas\r\n     * @readonly\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.7.0\r\n     */\n\n    this.canvas = this._source.image;\n    /**\r\n     * The 2D Canvas Rendering Context.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#context\r\n     * @readonly\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.7.0\r\n     */\n\n    this.context = this.canvas.getContext('2d');\n    /**\r\n     * The width of the Canvas.\r\n     * This property is read-only, if you wish to change it use the `setSize` method.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#width\r\n     * @readonly\r\n     * @type {integer}\r\n     * @since 3.7.0\r\n     */\n\n    this.width = width;\n    /**\r\n     * The height of the Canvas.\r\n     * This property is read-only, if you wish to change it use the `setSize` method.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#height\r\n     * @readonly\r\n     * @type {integer}\r\n     * @since 3.7.0\r\n     */\n\n    this.height = height;\n    /**\r\n     * The context image data.\r\n     * Use the `update` method to populate this when the canvas changes.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#imageData\r\n     * @type {ImageData}\r\n     * @since 3.13.0\r\n     */\n\n    this.imageData = this.context.getImageData(0, 0, width, height);\n    /**\r\n     * A Uint8ClampedArray view into the `buffer`.\r\n     * Use the `update` method to populate this when the canvas changes.\r\n     * Note that this is unavailable in some browsers, such as Epic Browser, due to their security restrictions.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#data\r\n     * @type {Uint8ClampedArray}\r\n     * @since 3.13.0\r\n     */\n\n    this.data = null;\n\n    if (this.imageData) {\n      this.data = this.imageData.data;\n    }\n    /**\r\n     * An Uint32Array view into the `buffer`.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#pixels\r\n     * @type {Uint32Array}\r\n     * @since 3.13.0\r\n     */\n\n\n    this.pixels = null;\n    /**\r\n     * An ArrayBuffer the same size as the context ImageData.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#buffer\r\n     * @type {ArrayBuffer}\r\n     * @since 3.13.0\r\n     */\n\n    this.buffer;\n\n    if (this.data) {\n      if (this.imageData.data.buffer) {\n        this.buffer = this.imageData.data.buffer;\n        this.pixels = new Uint32Array(this.buffer);\n      } else if (window.ArrayBuffer) {\n        this.buffer = new ArrayBuffer(this.imageData.data.length);\n        this.pixels = new Uint32Array(this.buffer);\n      } else {\n        this.pixels = this.imageData.data;\n      }\n    }\n  },\n\n  /**\r\n   * This re-creates the `imageData` from the current context.\r\n   * It then re-builds the ArrayBuffer, the `data` Uint8ClampedArray reference and the `pixels` Int32Array.\r\n   *\r\n   * Warning: This is a very expensive operation, so use it sparingly.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#update\r\n   * @since 3.13.0\r\n   *\r\n   * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n   */\n  update: function update() {\n    this.imageData = this.context.getImageData(0, 0, this.width, this.height);\n    this.data = this.imageData.data;\n\n    if (this.imageData.data.buffer) {\n      this.buffer = this.imageData.data.buffer;\n      this.pixels = new Uint32Array(this.buffer);\n    } else if (window.ArrayBuffer) {\n      this.buffer = new ArrayBuffer(this.imageData.data.length);\n      this.pixels = new Uint32Array(this.buffer);\n    } else {\n      this.pixels = this.imageData.data;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Draws the given Image or Canvas element to this CanvasTexture, then updates the internal\r\n   * ImageData buffer and arrays.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#draw\r\n   * @since 3.13.0\r\n   * \r\n   * @param {integer} x - The x coordinate to draw the source at.\r\n   * @param {integer} y - The y coordinate to draw the source at.\r\n   * @param {(HTMLImageElement|HTMLCanvasElement)} source - The element to draw to this canvas.\r\n   * \r\n   * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n   */\n  draw: function draw(x, y, source) {\n    this.context.drawImage(source, x, y);\n    return this.update();\n  },\n\n  /**\r\n   * Draws the given texture frame to this CanvasTexture, then updates the internal\r\n   * ImageData buffer and arrays.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#drawFrame\r\n   * @since 3.16.0\r\n   * \r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(string|integer)} [frame] - The string-based name, or integer based index, of the Frame to get from the Texture.\r\n   * @param {integer} [x=0] - The x coordinate to draw the source at.\r\n   * @param {integer} [y=0] - The y coordinate to draw the source at.\r\n   * \r\n   * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n   */\n  drawFrame: function drawFrame(key, frame, x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    var textureFrame = this.manager.getFrame(key, frame);\n\n    if (textureFrame) {\n      var cd = textureFrame.canvasData;\n      var width = textureFrame.cutWidth;\n      var height = textureFrame.cutHeight;\n      var res = textureFrame.source.resolution;\n      this.context.drawImage(textureFrame.source.image, cd.x, cd.y, width, height, x, y, width / res, height / res);\n      return this.update();\n    } else {\n      return this;\n    }\n  },\n\n  /**\r\n   * Sets a pixel in the CanvasTexture to the given color and alpha values.\r\n   *\r\n   * This is an expensive operation to run in large quantities, so use sparingly.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#setPixel\r\n   * @since 3.16.0\r\n   * \r\n   * @param {integer} x - The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} y - The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} red - The red color value. A number between 0 and 255.\r\n   * @param {integer} green - The green color value. A number between 0 and 255.\r\n   * @param {integer} blue - The blue color value. A number between 0 and 255.\r\n   * @param {integer} [alpha=255] - The alpha value. A number between 0 and 255.\r\n   * \r\n   * @return {this} This CanvasTexture.\r\n   */\n  setPixel: function setPixel(x, y, red, green, blue, alpha) {\n    if (alpha === undefined) {\n      alpha = 255;\n    }\n\n    x = Math.abs(Math.floor(x));\n    y = Math.abs(Math.floor(y));\n    var index = this.getIndex(x, y);\n\n    if (index > -1) {\n      var imageData = this.context.getImageData(x, y, 1, 1);\n      imageData.data[0] = red;\n      imageData.data[1] = green;\n      imageData.data[2] = blue;\n      imageData.data[3] = alpha;\n      this.context.putImageData(imageData, x, y);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Puts the ImageData into the context of this CanvasTexture at the given coordinates.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#putData\r\n   * @since 3.16.0\r\n   * \r\n   * @param {ImageData} imageData - The ImageData to put at the given location.\r\n   * @param {integer} x - The x coordinate to put the imageData. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} y - The y coordinate to put the imageData. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} [dirtyX=0] - Horizontal position (x coordinate) of the top-left corner from which the image data will be extracted.\r\n   * @param {integer} [dirtyY=0] - Vertical position (x coordinate) of the top-left corner from which the image data will be extracted.\r\n   * @param {integer} [dirtyWidth] - Width of the rectangle to be painted. Defaults to the width of the image data.\r\n   * @param {integer} [dirtyHeight] - Height of the rectangle to be painted. Defaults to the height of the image data.\r\n   * \r\n   * @return {this} This CanvasTexture.\r\n   */\n  putData: function putData(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {\n    if (dirtyX === undefined) {\n      dirtyX = 0;\n    }\n\n    if (dirtyY === undefined) {\n      dirtyY = 0;\n    }\n\n    if (dirtyWidth === undefined) {\n      dirtyWidth = imageData.width;\n    }\n\n    if (dirtyHeight === undefined) {\n      dirtyHeight = imageData.height;\n    }\n\n    this.context.putImageData(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\n    return this;\n  },\n\n  /**\r\n   * Gets an ImageData region from this CanvasTexture from the position and size specified.\r\n   * You can write this back using `CanvasTexture.putData`, or manipulate it.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#getData\r\n   * @since 3.16.0\r\n   * \r\n   * @param {integer} x - The x coordinate of the top-left of the area to get the ImageData from. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} y - The y coordinate of the top-left of the area to get the ImageData from. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} width - The width of the rectangle from which the ImageData will be extracted. Positive values are to the right, and negative to the left.\r\n   * @param {integer} height - The height of the rectangle from which the ImageData will be extracted. Positive values are down, and negative are up.\r\n   * \r\n   * @return {ImageData} The ImageData extracted from this CanvasTexture.\r\n   */\n  getData: function getData(x, y, width, height) {\n    x = Clamp(Math.floor(x), 0, this.width - 1);\n    y = Clamp(Math.floor(y), 0, this.height - 1);\n    width = Clamp(width, 1, this.width - x);\n    height = Clamp(height, 1, this.height - y);\n    var imageData = this.context.getImageData(x, y, width, height);\n    return imageData;\n  },\n\n  /**\r\n   * Get the color of a specific pixel from this texture and store it in a Color object.\r\n   * \r\n   * If you have drawn anything to this CanvasTexture since it was created you must call `CanvasTexture.update` to refresh the array buffer,\r\n   * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#getPixel\r\n   * @since 3.13.0\r\n   * \r\n   * @param {integer} x - The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} y - The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {Phaser.Display.Color} [out] - A Color object to store the pixel values in. If not provided a new Color object will be created.\r\n   * \r\n   * @return {Phaser.Display.Color} An object with the red, green, blue and alpha values set in the r, g, b and a properties.\r\n   */\n  getPixel: function getPixel(x, y, out) {\n    if (!out) {\n      out = new Color();\n    }\n\n    var index = this.getIndex(x, y);\n\n    if (index > -1) {\n      var data = this.data;\n      var r = data[index + 0];\n      var g = data[index + 1];\n      var b = data[index + 2];\n      var a = data[index + 3];\n      out.setTo(r, g, b, a);\n    }\n\n    return out;\n  },\n\n  /**\r\n   * An object containing the position and color data for a single pixel in a CanvasTexture.\r\n   *\r\n   * @typedef {object} PixelConfig\r\n   *\r\n   * @property {integer} x - The x-coordinate of the pixel.\r\n   * @property {integer} y - The y-coordinate of the pixel.\r\n   * @property {integer} color - The color of the pixel, not including the alpha channel.\r\n   * @property {float} alpha - The alpha of the pixel, between 0 and 1.\r\n   */\n\n  /**\r\n   * Returns an array containing all of the pixels in the given region.\r\n   *\r\n   * If the requested region extends outside the bounds of this CanvasTexture,\r\n   * the region is truncated to fit.\r\n   * \r\n   * If you have drawn anything to this CanvasTexture since it was created you must call `CanvasTexture.update` to refresh the array buffer,\r\n   * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#getPixels\r\n   * @since 3.16.0\r\n   * \r\n   * @param {integer} x - The x coordinate of the top-left of the region. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} y - The y coordinate of the top-left of the region. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} width - The width of the region to get. Must be an integer.\r\n   * @param {integer} [height] - The height of the region to get. Must be an integer. If not given will be set to the `width`.\r\n   * \r\n   * @return {PixelConfig[]} An array of Pixel objects.\r\n   */\n  getPixels: function getPixels(x, y, width, height) {\n    if (height === undefined) {\n      height = width;\n    }\n\n    x = Math.abs(Math.round(x));\n    y = Math.abs(Math.round(y));\n    var left = Clamp(x, 0, this.width);\n    var right = Clamp(x + width, 0, this.width);\n    var top = Clamp(y, 0, this.height);\n    var bottom = Clamp(y + height, 0, this.height);\n    var pixel = new Color();\n    var out = [];\n\n    for (var py = top; py < bottom; py++) {\n      var row = [];\n\n      for (var px = left; px < right; px++) {\n        pixel = this.getPixel(px, py, pixel);\n        row.push({\n          x: px,\n          y: py,\n          color: pixel.color,\n          alpha: pixel.alphaGL\n        });\n      }\n\n      out.push(row);\n    }\n\n    return out;\n  },\n\n  /**\r\n   * Returns the Image Data index for the given pixel in this CanvasTexture.\r\n   *\r\n   * The index can be used to read directly from the `this.data` array.\r\n   *\r\n   * The index points to the red value in the array. The subsequent 3 indexes\r\n   * point to green, blue and alpha respectively.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#getIndex\r\n   * @since 3.16.0\r\n   * \r\n   * @param {integer} x - The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} y - The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * \r\n   * @return {integer} \r\n   */\n  getIndex: function getIndex(x, y) {\n    x = Math.abs(Math.round(x));\n    y = Math.abs(Math.round(y));\n\n    if (x < this.width && y < this.height) {\n      return (x + y * this.width) * 4;\n    } else {\n      return -1;\n    }\n  },\n\n  /**\r\n   * This should be called manually if you are running under WebGL.\r\n   * It will refresh the WebGLTexture from the Canvas source. Only call this if you know that the\r\n   * canvas has changed, as there is a significant GPU texture allocation cost involved in doing so.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#refresh\r\n   * @since 3.7.0\r\n   *\r\n   * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n   */\n  refresh: function refresh() {\n    this._source.update();\n\n    return this;\n  },\n\n  /**\r\n   * Gets the Canvas Element.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#getCanvas\r\n   * @since 3.7.0\r\n   *\r\n   * @return {HTMLCanvasElement} The Canvas DOM element this texture is using.\r\n   */\n  getCanvas: function getCanvas() {\n    return this.canvas;\n  },\n\n  /**\r\n   * Gets the 2D Canvas Rendering Context.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#getContext\r\n   * @since 3.7.0\r\n   *\r\n   * @return {CanvasRenderingContext2D} The Canvas Rendering Context this texture is using.\r\n   */\n  getContext: function getContext() {\n    return this.context;\n  },\n\n  /**\r\n   * Clears the given region of this Canvas Texture, resetting it back to transparent.\r\n   * If no region is given, the whole Canvas Texture is cleared.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#clear\r\n   * @since 3.7.0\r\n   * \r\n   * @param {integer} [x=0] - The x coordinate of the top-left of the region to clear.\r\n   * @param {integer} [y=0] - The y coordinate of the top-left of the region to clear.\r\n   * @param {integer} [width] - The width of the region.\r\n   * @param {integer} [height] - The height of the region.\r\n   *\r\n   * @return {Phaser.Textures.CanvasTexture} The Canvas Texture.\r\n   */\n  clear: function clear(x, y, width, height) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = this.width;\n    }\n\n    if (height === undefined) {\n      height = this.height;\n    }\n\n    this.context.clearRect(x, y, width, height);\n    return this.update();\n  },\n\n  /**\r\n   * Changes the size of this Canvas Texture.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#setSize\r\n   * @since 3.7.0\r\n   *\r\n   * @param {integer} width - The new width of the Canvas.\r\n   * @param {integer} [height] - The new height of the Canvas. If not given it will use the width as the height.\r\n   *\r\n   * @return {Phaser.Textures.CanvasTexture} The Canvas Texture.\r\n   */\n  setSize: function setSize(width, height) {\n    if (height === undefined) {\n      height = width;\n    }\n\n    if (width !== this.width || height !== this.height) {\n      //  Update the Canvas\n      this.canvas.width = width;\n      this.canvas.height = height; //  Update the Texture Source\n\n      this._source.width = width;\n      this._source.height = height;\n      this._source.isPowerOf2 = IsSizePowerOfTwo(width, height); //  Update the Frame\n\n      this.frames['__BASE'].setSize(width, height, 0, 0);\n      this.refresh();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Destroys this Texture and releases references to its sources and frames.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#destroy\r\n   * @since 3.16.0\r\n   */\n  destroy: function destroy() {\n    Texture.prototype.destroy.call(this);\n    this._source = null;\n    this.canvas = null;\n    this.context = null;\n    this.imageData = null;\n    this.data = null;\n    this.pixels = null;\n    this.buffer = null;\n  }\n});\nmodule.exports = CanvasTexture;","map":null,"metadata":{},"sourceType":"script"}