{"ast":null,"code":"/**\r\n* The `Matter.Bodies` module contains factory methods for creating rigid body models \r\n* with commonly used body configurations (such as rectangles, circles and other polygons).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Bodies\r\n*/\n// TODO: true circle bodies\nvar Bodies = {};\nmodule.exports = Bodies;\n\nvar Vertices = require('../geometry/Vertices');\n\nvar Common = require('../core/Common');\n\nvar Body = require('../body/Body');\n\nvar Bounds = require('../geometry/Bounds');\n\nvar Vector = require('../geometry/Vector');\n\nvar decomp = require('../../poly-decomp');\n\n(function () {\n  /**\r\n   * Creates a new rigid body model with a rectangle hull. \r\n   * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n   * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n   * @method rectangle\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} width\r\n   * @param {number} height\r\n   * @param {object} [options]\r\n   * @return {body} A new rectangle body\r\n   */\n  Bodies.rectangle = function (x, y, width, height, options) {\n    options = options || {};\n    var rectangle = {\n      label: 'Rectangle Body',\n      position: {\n        x: x,\n        y: y\n      },\n      vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)\n    };\n\n    if (options.chamfer) {\n      var chamfer = options.chamfer;\n      rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n      delete options.chamfer;\n    }\n\n    return Body.create(Common.extend({}, rectangle, options));\n  };\n  /**\r\n   * Creates a new rigid body model with a trapezoid hull. \r\n   * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n   * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n   * @method trapezoid\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} width\r\n   * @param {number} height\r\n   * @param {number} slope\r\n   * @param {object} [options]\r\n   * @return {body} A new trapezoid body\r\n   */\n\n\n  Bodies.trapezoid = function (x, y, width, height, slope, options) {\n    options = options || {};\n    slope *= 0.5;\n    var roof = (1 - slope * 2) * width;\n    var x1 = width * slope,\n        x2 = x1 + roof,\n        x3 = x2 + x1,\n        verticesPath;\n\n    if (slope < 0.5) {\n      verticesPath = 'L 0 0 L ' + x1 + ' ' + -height + ' L ' + x2 + ' ' + -height + ' L ' + x3 + ' 0';\n    } else {\n      verticesPath = 'L 0 0 L ' + x2 + ' ' + -height + ' L ' + x3 + ' 0';\n    }\n\n    var trapezoid = {\n      label: 'Trapezoid Body',\n      position: {\n        x: x,\n        y: y\n      },\n      vertices: Vertices.fromPath(verticesPath)\n    };\n\n    if (options.chamfer) {\n      var chamfer = options.chamfer;\n      trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n      delete options.chamfer;\n    }\n\n    return Body.create(Common.extend({}, trapezoid, options));\n  };\n  /**\r\n   * Creates a new rigid body model with a circle hull. \r\n   * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n   * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n   * @method circle\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} radius\r\n   * @param {object} [options]\r\n   * @param {number} [maxSides]\r\n   * @return {body} A new circle body\r\n   */\n\n\n  Bodies.circle = function (x, y, radius, options, maxSides) {\n    options = options || {};\n    var circle = {\n      label: 'Circle Body',\n      circleRadius: radius\n    }; // approximate circles with polygons until true circles implemented in SAT\n\n    maxSides = maxSides || 25;\n    var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius))); // optimisation: always use even number of sides (half the number of unique axes)\n\n    if (sides % 2 === 1) sides += 1;\n    return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));\n  };\n  /**\r\n   * Creates a new rigid body model with a regular polygon hull with the given number of sides. \r\n   * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n   * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n   * @method polygon\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} sides\r\n   * @param {number} radius\r\n   * @param {object} [options]\r\n   * @return {body} A new regular polygon body\r\n   */\n\n\n  Bodies.polygon = function (x, y, sides, radius, options) {\n    options = options || {};\n    if (sides < 3) return Bodies.circle(x, y, radius, options);\n    var theta = 2 * Math.PI / sides,\n        path = '',\n        offset = theta * 0.5;\n\n    for (var i = 0; i < sides; i += 1) {\n      var angle = offset + i * theta,\n          xx = Math.cos(angle) * radius,\n          yy = Math.sin(angle) * radius;\n      path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';\n    }\n\n    var polygon = {\n      label: 'Polygon Body',\n      position: {\n        x: x,\n        y: y\n      },\n      vertices: Vertices.fromPath(path)\n    };\n\n    if (options.chamfer) {\n      var chamfer = options.chamfer;\n      polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n      delete options.chamfer;\n    }\n\n    return Body.create(Common.extend({}, polygon, options));\n  };\n  /**\r\n   * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).\r\n   * If the vertices are convex, they will pass through as supplied.\r\n   * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.\r\n   * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).\r\n   * By default the decomposition will discard collinear edges (to improve performance).\r\n   * It can also optionally discard any parts that have an area less than `minimumArea`.\r\n   * If the vertices can not be decomposed, the result will fall back to using the convex hull.\r\n   * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.\r\n   * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n   * @method fromVertices\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param [[vector]] vertexSets\r\n   * @param {object} [options]\r\n   * @param {bool} [flagInternal=false]\r\n   * @param {number} [removeCollinear=0.01]\r\n   * @param {number} [minimumArea=10]\r\n   * @return {body}\r\n   */\n\n\n  Bodies.fromVertices = function (x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {\n    var body, parts, isConvex, vertices, i, j, k, v, z;\n    options = options || {};\n    parts = [];\n    flagInternal = typeof flagInternal !== 'undefined' ? flagInternal : false;\n    removeCollinear = typeof removeCollinear !== 'undefined' ? removeCollinear : 0.01;\n    minimumArea = typeof minimumArea !== 'undefined' ? minimumArea : 10;\n\n    if (!decomp) {\n      Common.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.');\n    } // ensure vertexSets is an array of arrays\n\n\n    if (!Common.isArray(vertexSets[0])) {\n      vertexSets = [vertexSets];\n    }\n\n    for (v = 0; v < vertexSets.length; v += 1) {\n      vertices = vertexSets[v];\n      isConvex = Vertices.isConvex(vertices);\n\n      if (isConvex || !decomp) {\n        if (isConvex) {\n          vertices = Vertices.clockwiseSort(vertices);\n        } else {\n          // fallback to convex hull when decomposition is not possible\n          vertices = Vertices.hull(vertices);\n        }\n\n        parts.push({\n          position: {\n            x: x,\n            y: y\n          },\n          vertices: vertices\n        });\n      } else {\n        // initialise a decomposition\n        var concave = vertices.map(function (vertex) {\n          return [vertex.x, vertex.y];\n        }); // vertices are concave and simple, we can decompose into parts\n\n        decomp.makeCCW(concave);\n        if (removeCollinear !== false) decomp.removeCollinearPoints(concave, removeCollinear); // use the quick decomposition algorithm (Bayazit)\n\n        var decomposed = decomp.quickDecomp(concave); // for each decomposed chunk\n\n        for (i = 0; i < decomposed.length; i++) {\n          var chunk = decomposed[i]; // convert vertices into the correct structure\n\n          var chunkVertices = chunk.map(function (vertices) {\n            return {\n              x: vertices[0],\n              y: vertices[1]\n            };\n          }); // skip small chunks\n\n          if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea) continue; // create a compound part\n\n          parts.push({\n            position: Vertices.centre(chunkVertices),\n            vertices: chunkVertices\n          });\n        }\n      }\n    } // create body parts\n\n\n    for (i = 0; i < parts.length; i++) {\n      parts[i] = Body.create(Common.extend(parts[i], options));\n    } // flag internal edges (coincident part edges)\n\n\n    if (flagInternal) {\n      var coincident_max_dist = 5;\n\n      for (i = 0; i < parts.length; i++) {\n        var partA = parts[i];\n\n        for (j = i + 1; j < parts.length; j++) {\n          var partB = parts[j];\n\n          if (Bounds.overlaps(partA.bounds, partB.bounds)) {\n            var pav = partA.vertices,\n                pbv = partB.vertices; // iterate vertices of both parts\n\n            for (k = 0; k < partA.vertices.length; k++) {\n              for (z = 0; z < partB.vertices.length; z++) {\n                // find distances between the vertices\n                var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])),\n                    db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length])); // if both vertices are very close, consider the edge concident (internal)\n\n                if (da < coincident_max_dist && db < coincident_max_dist) {\n                  pav[k].isInternal = true;\n                  pbv[z].isInternal = true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (parts.length > 1) {\n      // create the parent body to be returned, that contains generated compound parts\n      body = Body.create(Common.extend({\n        parts: parts.slice(0)\n      }, options));\n      Body.setPosition(body, {\n        x: x,\n        y: y\n      });\n      return body;\n    } else {\n      return parts[0];\n    }\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}