{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../../../utils/Class');\n\nvar ShaderSourceFS = require('../shaders/BitmapMask-frag.js');\n\nvar ShaderSourceVS = require('../shaders/BitmapMask-vert.js');\n\nvar WebGLPipeline = require('../WebGLPipeline');\n/**\r\n * @classdesc\r\n * BitmapMaskPipeline handles all bitmap masking rendering in WebGL. It works by using \r\n * sampling two texture on the fragment shader and using the fragment's alpha to clip the region.\r\n * The config properties are:\r\n * - game: Current game instance.\r\n * - renderer: Current WebGL renderer.\r\n * - topology: This indicates how the primitives are rendered. The default value is GL_TRIANGLES.\r\n *              Here is the full list of rendering primitives (https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants).\r\n * - vertShader: Source for vertex shader as a string.\r\n * - fragShader: Source for fragment shader as a string.\r\n * - vertexCapacity: The amount of vertices that shall be allocated\r\n * - vertexSize: The size of a single vertex in bytes.\r\n *\r\n * @class BitmapMaskPipeline\r\n * @extends Phaser.Renderer.WebGL.WebGLPipeline\r\n * @memberof Phaser.Renderer.WebGL.Pipelines\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - Used for overriding shader an pipeline properties if extending this pipeline.\r\n */\n\n\nvar BitmapMaskPipeline = new Class({\n  Extends: WebGLPipeline,\n  initialize: function BitmapMaskPipeline(config) {\n    WebGLPipeline.call(this, {\n      game: config.game,\n      renderer: config.renderer,\n      gl: config.renderer.gl,\n      topology: config.topology ? config.topology : config.renderer.gl.TRIANGLES,\n      vertShader: config.vertShader ? config.vertShader : ShaderSourceVS,\n      fragShader: config.fragShader ? config.fragShader : ShaderSourceFS,\n      vertexCapacity: config.vertexCapacity ? config.vertexCapacity : 3,\n      vertexSize: config.vertexSize ? config.vertexSize : Float32Array.BYTES_PER_ELEMENT * 2,\n      vertices: new Float32Array([-1, +1, -1, -7, +7, +1]).buffer,\n      attributes: [{\n        name: 'inPosition',\n        size: 2,\n        type: config.renderer.gl.FLOAT,\n        normalized: false,\n        offset: 0\n      }]\n    });\n    /**\r\n     * Float32 view of the array buffer containing the pipeline's vertices.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#vertexViewF32\r\n     * @type {Float32Array}\r\n     * @since 3.0.0\r\n     */\n\n    this.vertexViewF32 = new Float32Array(this.vertexData);\n    /**\r\n     * Size of the batch.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#maxQuads\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\n\n    this.maxQuads = 1;\n    /**\r\n     * Dirty flag to check if resolution properties need to be updated on the \r\n     * masking shader.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#resolutionDirty\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.resolutionDirty = true;\n  },\n\n  /**\r\n   * Called every time the pipeline needs to be used.\r\n   * It binds all necessary resources.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#onBind\r\n   * @since 3.0.0\r\n   *\r\n   * @return {this} This WebGLPipeline instance.\r\n   */\n  onBind: function onBind() {\n    WebGLPipeline.prototype.onBind.call(this);\n    var renderer = this.renderer;\n    var program = this.program;\n\n    if (this.resolutionDirty) {\n      renderer.setFloat2(program, 'uResolution', this.width, this.height);\n      renderer.setInt1(program, 'uMainSampler', 0);\n      renderer.setInt1(program, 'uMaskSampler', 1);\n      this.resolutionDirty = false;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#resize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} width - [description]\r\n   * @param {number} height - [description]\r\n   * @param {number} resolution - [description]\r\n   *\r\n   * @return {this} This WebGLPipeline instance.\r\n   */\n  resize: function resize(width, height, resolution) {\n    WebGLPipeline.prototype.resize.call(this, width, height, resolution);\n    this.resolutionDirty = true;\n    return this;\n  },\n\n  /**\r\n   * Binds necessary resources and renders the mask to a separated framebuffer.\r\n   * The framebuffer for the masked object is also bound for further use.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#beginMask\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} mask - GameObject used as mask.\r\n   * @param {Phaser.GameObjects.GameObject} maskedObject - GameObject masked by the mask GameObject.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n   */\n  beginMask: function beginMask(mask, maskedObject, camera) {\n    var renderer = this.renderer;\n    var gl = this.gl; //  The renderable Game Object that is being used for the bitmap mask\n\n    var bitmapMask = mask.bitmapMask;\n\n    if (bitmapMask && gl) {\n      renderer.flush(); // First we clear the mask framebuffer\n\n      renderer.setFramebuffer(mask.maskFramebuffer);\n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(gl.COLOR_BUFFER_BIT); // We render our mask source\n\n      bitmapMask.renderWebGL(renderer, bitmapMask, 0, camera);\n      renderer.flush(); // Bind and clear our main source (masked object)\n\n      renderer.setFramebuffer(mask.mainFramebuffer);\n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n  },\n\n  /**\r\n   * The masked game object's framebuffer is unbound and it's texture \r\n   * is bound together with the mask texture and the mask shader and \r\n   * a draw call with a single quad is processed. Here is where the\r\n   * masking effect is applied.  \r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#endMask\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} mask - GameObject used as a mask.\r\n   */\n  endMask: function endMask(mask) {\n    var renderer = this.renderer;\n    var gl = this.gl; //  The renderable Game Object that is being used for the bitmap mask\n\n    var bitmapMask = mask.bitmapMask;\n\n    if (bitmapMask && gl) {\n      // Return to default framebuffer\n      renderer.setFramebuffer(null); // Bind bitmap mask pipeline and draw\n\n      renderer.setPipeline(this);\n      renderer.setTexture2D(mask.maskTexture, 1);\n      renderer.setTexture2D(mask.mainTexture, 0);\n      renderer.setInt1(this.program, 'uInvertMaskAlpha', mask.invertAlpha); // Finally draw a triangle filling the whole screen\n\n      gl.drawArrays(this.topology, 0, 3);\n    }\n  }\n});\nmodule.exports = BitmapMaskPipeline;","map":null,"metadata":{},"sourceType":"script"}