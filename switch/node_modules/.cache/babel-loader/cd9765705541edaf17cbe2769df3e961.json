{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\n\n/**\r\n * @typedef {object} BitmapTextSize\r\n *\r\n * @property {GlobalBitmapTextSize} global - The position and size of the BitmapText, taking into account the position and scale of the Game Object.\r\n * @property {LocalBitmapTextSize} local - The position and size of the BitmapText, taking just the font size into account.\r\n */\n\n/**\r\n * The position and size of the Bitmap Text in global space, taking into account the Game Object's scale and world position.\r\n *\r\n * @typedef {object} GlobalBitmapTextSize\r\n *\r\n * @property {number} x - The x position of the BitmapText, taking into account the x position and scale of the Game Object.\r\n * @property {number} y - The y position of the BitmapText, taking into account the y position and scale of the Game Object.\r\n * @property {number} width - The width of the BitmapText, taking into account the x scale of the Game Object.\r\n * @property {number} height - The height of the BitmapText, taking into account the y scale of the Game Object.\r\n */\n\n/**\r\n * The position and size of the Bitmap Text in local space, taking just the font size into account.\r\n *\r\n * @typedef {object} LocalBitmapTextSize\r\n *\r\n * @property {number} x - The x position of the BitmapText.\r\n * @property {number} y - The y position of the BitmapText.\r\n * @property {number} width - The width of the BitmapText.\r\n * @property {number} height - The height of the BitmapText.\r\n */\n\n/**\r\n * Calculate the position, width and height of a BitmapText Game Object.\r\n *\r\n * Returns a BitmapTextSize object that contains global and local variants of the Game Objects x and y coordinates and\r\n * its width and height.\r\n *\r\n * The global position and size take into account the Game Object's position and scale.\r\n *\r\n * The local position and size just takes into account the font data.\r\n *\r\n * @function GetBitmapTextSize\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {(Phaser.GameObjects.DynamicBitmapText|Phaser.GameObjects.BitmapText)} src - The BitmapText to calculate the position, width and height of.\r\n * @param {boolean} [round] - Whether to round the results to the nearest integer.\r\n * @param {object} [out] - Optional object to store the results in, to save constant object creation.\r\n *\r\n * @return {BitmapTextSize} The calculated position, width and height of the BitmapText.\r\n */\nvar GetBitmapTextSize = function GetBitmapTextSize(src, round, out) {\n  if (out === undefined) {\n    out = {\n      local: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      },\n      global: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      },\n      lines: {\n        shortest: 0,\n        longest: 0,\n        lengths: null\n      }\n    };\n  }\n\n  var text = src.text;\n  var textLength = text.length;\n  var bx = Number.MAX_VALUE;\n  var by = Number.MAX_VALUE;\n  var bw = 0;\n  var bh = 0;\n  var chars = src.fontData.chars;\n  var lineHeight = src.fontData.lineHeight;\n  var letterSpacing = src.letterSpacing;\n  var xAdvance = 0;\n  var yAdvance = 0;\n  var charCode = 0;\n  var glyph = null;\n  var x = 0;\n  var y = 0;\n  var scale = src.fontSize / src.fontData.size;\n  var sx = scale * src.scaleX;\n  var sy = scale * src.scaleY;\n  var lastGlyph = null;\n  var lastCharCode = 0;\n  var lineWidths = [];\n  var shortestLine = Number.MAX_VALUE;\n  var longestLine = 0;\n  var currentLine = 0;\n  var currentLineWidth = 0;\n\n  for (var i = 0; i < textLength; i++) {\n    charCode = text.charCodeAt(i);\n\n    if (charCode === 10) {\n      xAdvance = 0;\n      yAdvance += lineHeight;\n      lastGlyph = null;\n      lineWidths[currentLine] = currentLineWidth;\n\n      if (currentLineWidth > longestLine) {\n        longestLine = currentLineWidth;\n      }\n\n      if (currentLineWidth < shortestLine) {\n        shortestLine = currentLineWidth;\n      }\n\n      currentLine++;\n      currentLineWidth = 0;\n      continue;\n    }\n\n    glyph = chars[charCode];\n\n    if (!glyph) {\n      continue;\n    }\n\n    x = xAdvance;\n    y = yAdvance;\n\n    if (lastGlyph !== null) {\n      var kerningOffset = glyph.kerning[lastCharCode];\n      x += kerningOffset !== undefined ? kerningOffset : 0;\n    }\n\n    if (bx > x) {\n      bx = x;\n    }\n\n    if (by > y) {\n      by = y;\n    }\n\n    var gw = x + glyph.xAdvance;\n    var gh = y + lineHeight;\n\n    if (bw < gw) {\n      bw = gw;\n    }\n\n    if (bh < gh) {\n      bh = gh;\n    }\n\n    xAdvance += glyph.xAdvance + letterSpacing;\n    lastGlyph = glyph;\n    lastCharCode = charCode;\n    currentLineWidth = gw * scale;\n  }\n\n  lineWidths[currentLine] = currentLineWidth;\n\n  if (currentLineWidth > longestLine) {\n    longestLine = currentLineWidth;\n  }\n\n  if (currentLineWidth < shortestLine) {\n    shortestLine = currentLineWidth;\n  }\n\n  var local = out.local;\n  var global = out.global;\n  var lines = out.lines;\n  local.x = bx * scale;\n  local.y = by * scale;\n  local.width = bw * scale;\n  local.height = bh * scale;\n  global.x = src.x - src.displayOriginX + bx * sx;\n  global.y = src.y - src.displayOriginY + by * sy;\n  global.width = bw * sx;\n  global.height = bh * sy;\n  lines.shortest = shortestLine;\n  lines.longest = longestLine;\n  lines.lengths = lineWidths;\n\n  if (round) {\n    local.x = Math.round(local.x);\n    local.y = Math.round(local.y);\n    local.width = Math.round(local.width);\n    local.height = Math.round(local.height);\n    global.x = Math.round(global.x);\n    global.y = Math.round(global.y);\n    global.width = Math.round(global.width);\n    global.height = Math.round(global.height);\n    lines.shortest = Math.round(shortestLine);\n    lines.longest = Math.round(longestLine);\n  }\n\n  return out;\n};\n\nmodule.exports = GetBitmapTextSize;","map":null,"metadata":{},"sourceType":"script"}