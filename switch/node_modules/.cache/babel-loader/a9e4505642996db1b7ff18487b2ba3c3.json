{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Clamp = require('../math/Clamp');\n\nvar Class = require('../utils/Class');\n\nvar Events = require('./events');\n\nvar GetFastValue = require('../utils/object/GetFastValue');\n\nvar PluginCache = require('../plugins/PluginCache');\n/**\r\n * @classdesc\r\n * A proxy class to the Global Scene Manager.\r\n *\r\n * @class ScenePlugin\r\n * @memberof Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that this ScenePlugin belongs to.\r\n */\n\n\nvar ScenePlugin = new Class({\n  initialize: function ScenePlugin(scene) {\n    /**\r\n     * The Scene that this ScenePlugin belongs to.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n    this.scene = scene;\n    /**\r\n     * The Scene Systems instance of the Scene that this ScenePlugin belongs to.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#systems\r\n     * @type {Phaser.Scenes.Systems}\r\n     * @since 3.0.0\r\n     */\n\n    this.systems = scene.sys;\n    /**\r\n     * The settings of the Scene this ScenePlugin belongs to.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#settings\r\n     * @type {Phaser.Scenes.Settings.Object}\r\n     * @since 3.0.0\r\n     */\n\n    this.settings = scene.sys.settings;\n    /**\r\n     * The key of the Scene this ScenePlugin belongs to.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#key\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n\n    this.key = scene.sys.settings.key;\n    /**\r\n     * The Game's SceneManager.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#manager\r\n     * @type {Phaser.Scenes.SceneManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.manager = scene.sys.game.scene;\n    /**\r\n     * If this Scene is currently transitioning to another, this holds\r\n     * the current percentage of the transition progress, between 0 and 1.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#transitionProgress\r\n     * @type {number}\r\n     * @since 3.5.0\r\n     */\n\n    this.transitionProgress = 0;\n    /**\r\n     * Transition elapsed timer.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#_elapsed\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.5.0\r\n     */\n\n    this._elapsed = 0;\n    /**\r\n     * Transition elapsed timer.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#_target\r\n     * @type {?Phaser.Scenes.Scene}\r\n     * @private\r\n     * @since 3.5.0\r\n     */\n\n    this._target = null;\n    /**\r\n     * Transition duration.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#_duration\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.5.0\r\n     */\n\n    this._duration = 0;\n    /**\r\n     * Transition callback.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#_onUpdate\r\n     * @type {function}\r\n     * @private\r\n     * @since 3.5.0\r\n     */\n\n    this._onUpdate;\n    /**\r\n     * Transition callback scope.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#_onUpdateScope\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.5.0\r\n     */\n\n    this._onUpdateScope;\n    /**\r\n     * Will this Scene sleep (true) after the transition, or stop (false)\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#_willSleep\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.5.0\r\n     */\n\n    this._willSleep = false;\n    /**\r\n     * Will this Scene be removed from the Scene Manager after the transition completes?\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#_willRemove\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.5.0\r\n     */\n\n    this._willRemove = false;\n    scene.sys.events.once(Events.BOOT, this.boot, this);\n    scene.sys.events.on(Events.START, this.pluginStart, this);\n  },\n\n  /**\r\n   * This method is called automatically, only once, when the Scene is first created.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#boot\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  boot: function boot() {\n    this.systems.events.once(Events.DESTROY, this.destroy, this);\n  },\n\n  /**\r\n   * This method is called automatically by the Scene when it is starting up.\r\n   * It is responsible for creating local systems, properties and listening for Scene events.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#pluginStart\r\n   * @private\r\n   * @since 3.5.0\r\n   */\n  pluginStart: function pluginStart() {\n    this._target = null;\n    this.systems.events.once(Events.SHUTDOWN, this.shutdown, this);\n  },\n\n  /**\r\n   * Shutdown this Scene and run the given one.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#start\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to start.\r\n   * @param {object} [data] - The Scene data.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  start: function start(key, data) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.queueOp('stop', this.key);\n    this.manager.queueOp('start', key, data);\n    return this;\n  },\n\n  /**\r\n   * Restarts this Scene.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#restart\r\n   * @since 3.4.0\r\n   *\r\n   * @param {object} [data] - The Scene data.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  restart: function restart(data) {\n    var key = this.key;\n    this.manager.queueOp('stop', key);\n    this.manager.queueOp('start', key, data);\n    return this;\n  },\n\n  /**\r\n   * @typedef {object} SceneTransitionConfig\r\n   *\r\n   * @property {string} target - The Scene key to transition to.\r\n   * @property {integer} [duration=1000] - The duration, in ms, for the transition to last.\r\n   * @property {boolean} [sleep=false] - Will the Scene responsible for the transition be sent to sleep on completion (`true`), or stopped? (`false`)\r\n   * @property {boolean} [allowInput=false] - Will the Scenes Input system be able to process events while it is transitioning in or out?\r\n   * @property {boolean} [moveAbove] - Move the target Scene to be above this one before the transition starts.\r\n   * @property {boolean} [moveBelow] - Move the target Scene to be below this one before the transition starts.\r\n   * @property {function} [onUpdate] - This callback is invoked every frame for the duration of the transition.\r\n   * @property {any} [onUpdateScope] - The context in which the callback is invoked.\r\n   * @property {any} [data] - An object containing any data you wish to be passed to the target Scenes init / create methods.\r\n   */\n\n  /**\r\n   * This will start a transition from the current Scene to the target Scene given.\r\n   *\r\n   * The transition will last for the duration specified in milliseconds.\r\n   *\r\n   * You can have the target Scene moved above or below this one in the display list.\r\n   *\r\n   * You can specify an update callback. This callback will be invoked _every frame_ for the duration\r\n   * of the transition.\r\n   *\r\n   * This Scene can either be sent to sleep at the end of the transition, or stopped. The default is to stop.\r\n   *\r\n   * There are also 5 transition related events: This scene will emit the event `transitionout` when\r\n   * the transition begins, which is typically the frame after calling this method.\r\n   *\r\n   * The target Scene will emit the event `transitioninit` when that Scene's `init` method is called.\r\n   * It will then emit the event `transitionstart` when its `create` method is called.\r\n   * If the Scene was sleeping and has been woken up, it will emit the event `transitionwake` instead of these two,\r\n   * as the Scenes `init` and `create` methods are not invoked when a Scene wakes up.\r\n   *\r\n   * When the duration of the transition has elapsed it will emit the event `transitioncomplete`.\r\n   * These events are cleared of all listeners when the Scene shuts down, but not if it is sent to sleep.\r\n   *\r\n   * It's important to understand that the duration of the transition begins the moment you call this method.\r\n   * If the Scene you are transitioning to includes delayed processes, such as waiting for files to load, the\r\n   * time still counts down even while that is happening. If the game itself pauses, or something else causes\r\n   * this Scenes update loop to stop, then the transition will also pause for that duration. There are\r\n   * checks in place to prevent you accidentally stopping a transitioning Scene but if you've got code to\r\n   * override this understand that until the target Scene completes it might never be unlocked for input events.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#transition\r\n   * @fires Phaser.Scenes.Events#TRANSITION_OUT\r\n   * @since 3.5.0\r\n   *\r\n   * @param {SceneTransitionConfig} config - The transition configuration object.\r\n   *\r\n   * @return {boolean} `true` is the transition was started, otherwise `false`.\r\n   */\n  transition: function transition(config) {\n    if (config === undefined) {\n      config = {};\n    }\n\n    var key = GetFastValue(config, 'target', false);\n    var target = this.manager.getScene(key);\n\n    if (!key || !this.checkValidTransition(target)) {\n      return false;\n    }\n\n    var duration = GetFastValue(config, 'duration', 1000);\n    this._elapsed = 0;\n    this._target = target;\n    this._duration = duration;\n    this._willSleep = GetFastValue(config, 'sleep', false);\n    this._willRemove = GetFastValue(config, 'remove', false);\n    var callback = GetFastValue(config, 'onUpdate', null);\n\n    if (callback) {\n      this._onUpdate = callback;\n      this._onUpdateScope = GetFastValue(config, 'onUpdateScope', this.scene);\n    }\n\n    var allowInput = GetFastValue(config, 'allowInput', false);\n    this.settings.transitionAllowInput = allowInput;\n    var targetSettings = target.sys.settings;\n    targetSettings.isTransition = true;\n    targetSettings.transitionFrom = this.scene;\n    targetSettings.transitionDuration = duration;\n    targetSettings.transitionAllowInput = allowInput;\n\n    if (GetFastValue(config, 'moveAbove', false)) {\n      this.manager.moveAbove(this.key, key);\n    } else if (GetFastValue(config, 'moveBelow', false)) {\n      this.manager.moveBelow(this.key, key);\n    }\n\n    if (target.sys.isSleeping()) {\n      target.sys.wake();\n    } else {\n      this.manager.start(key, GetFastValue(config, 'data'));\n    }\n\n    this.systems.events.emit(Events.TRANSITION_OUT, target, duration);\n    this.systems.events.on(Events.UPDATE, this.step, this);\n    return true;\n  },\n\n  /**\r\n   * Checks to see if this Scene can transition to the target Scene or not.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#checkValidTransition\r\n   * @private\r\n   * @since 3.5.0\r\n   *\r\n   * @param {Phaser.Scene} target - The Scene to test against.\r\n   *\r\n   * @return {boolean} `true` if this Scene can transition, otherwise `false`.\r\n   */\n  checkValidTransition: function checkValidTransition(target) {\n    //  Not a valid target if it doesn't exist, isn't active or is already transitioning in or out\n    if (!target || target.sys.isActive() || target.sys.isTransitioning() || target === this.scene || this.systems.isTransitioning()) {\n      return false;\n    }\n\n    return true;\n  },\n\n  /**\r\n   * A single game step. This is only called if the parent Scene is transitioning\r\n   * out to another Scene.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#step\r\n   * @private\r\n   * @since 3.5.0\r\n   *\r\n   * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n   * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n   */\n  step: function step(time, delta) {\n    this._elapsed += delta;\n    this.transitionProgress = Clamp(this._elapsed / this._duration, 0, 1);\n\n    if (this._onUpdate) {\n      this._onUpdate.call(this._onUpdateScope, this.transitionProgress);\n    }\n\n    if (this._elapsed >= this._duration) {\n      this.transitionComplete();\n    }\n  },\n\n  /**\r\n   * Called by `step` when the transition out of this scene to another is over.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#transitionComplete\r\n   * @private\r\n   * @fires Phaser.Scenes.Events#TRANSITION_COMPLETE\r\n   * @since 3.5.0\r\n   */\n  transitionComplete: function transitionComplete() {\n    var targetSys = this._target.sys;\n    var targetSettings = this._target.sys.settings; //  Stop the step\n\n    this.systems.events.off(Events.UPDATE, this.step, this); //  Notify target scene\n\n    targetSys.events.emit(Events.TRANSITION_COMPLETE, this.scene); //  Clear target scene settings\n\n    targetSettings.isTransition = false;\n    targetSettings.transitionFrom = null; //  Clear local settings\n\n    this._duration = 0;\n    this._target = null;\n    this._onUpdate = null;\n    this._onUpdateScope = null; //  Now everything is clear we can handle what happens to this Scene\n\n    if (this._willRemove) {\n      this.manager.remove(this.key);\n    } else if (this._willSleep) {\n      this.systems.sleep();\n    } else {\n      this.manager.stop(this.key);\n    }\n  },\n\n  /**\r\n   * Add the Scene into the Scene Manager and start it if 'autoStart' is true or the Scene config 'active' property is set.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#add\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene key.\r\n   * @param {(Phaser.Scene|Phaser.Scenes.Settings.Config|function)} sceneConfig - The config for the Scene.\r\n   * @param {boolean} autoStart - Whether to start the Scene after it's added.\r\n   * @param {object} [data] - Optional data object. This will be set as Scene.settings.data and passed to `Scene.init`.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  add: function add(key, sceneConfig, autoStart, data) {\n    this.manager.add(key, sceneConfig, autoStart, data);\n    return this;\n  },\n\n  /**\r\n   * Launch the given Scene and run it in parallel with this one.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#launch\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to launch.\r\n   * @param {object} [data] - The Scene data.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  launch: function launch(key, data) {\n    if (key && key !== this.key) {\n      this.manager.queueOp('start', key, data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Runs the given Scene, but does not change the state of this Scene.\r\n   *\r\n   * If the given Scene is paused, it will resume it. If sleeping, it will wake it.\r\n   * If not running at all, it will be started.\r\n   *\r\n   * Use this if you wish to open a modal Scene by calling `pause` on the current\r\n   * Scene, then `run` on the modal Scene.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#run\r\n   * @since 3.10.0\r\n   *\r\n   * @param {string} key - The Scene to run.\r\n   * @param {object} [data] - A data object that will be passed to the Scene and emitted in its ready, wake, or resume events.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  run: function run(key, data) {\n    if (key && key !== this.key) {\n      this.manager.queueOp('run', key, data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Pause the Scene - this stops the update step from happening but it still renders.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#pause\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to pause.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its pause event.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  pause: function pause(key, data) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.queueOp('pause', key, data);\n    return this;\n  },\n\n  /**\r\n   * Resume the Scene - starts the update loop again.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#resume\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to resume.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its resume event.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  resume: function resume(key, data) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.queueOp('resume', key, data);\n    return this;\n  },\n\n  /**\r\n   * Makes the Scene sleep (no update, no render) but doesn't shutdown.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#sleep\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to put to sleep.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its sleep event.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  sleep: function sleep(key, data) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.queueOp('sleep', key, data);\n    return this;\n  },\n\n  /**\r\n   * Makes the Scene wake-up (starts update and render)\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#wake\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to wake up.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its wake event.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  wake: function wake(key, data) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.queueOp('wake', key, data);\n    return this;\n  },\n\n  /**\r\n   * Makes this Scene sleep then starts the Scene given.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#switch\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to start.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  switch: function _switch(key) {\n    if (key !== this.key) {\n      this.manager.queueOp('switch', this.key, key);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Shutdown the Scene, clearing display list, timers, etc.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#stop\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to stop.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  stop: function stop(key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.queueOp('stop', key);\n    return this;\n  },\n\n  /**\r\n   * Sets the active state of the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#setActive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - If `true` the Scene will be resumed. If `false` it will be paused.\r\n   * @param {string} [key] - The Scene to set the active state of.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted with its events.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  setActive: function setActive(value, key, data) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    var scene = this.manager.getScene(key);\n\n    if (scene) {\n      scene.sys.setActive(value, data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the visible state of the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#setVisible\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - The visible value.\r\n   * @param {string} [key] - The Scene to set the visible state for.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  setVisible: function setVisible(value, key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    var scene = this.manager.getScene(key);\n\n    if (scene) {\n      scene.sys.setVisible(value);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Checks if the given Scene is sleeping or not?\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#isSleeping\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to check.\r\n   *\r\n   * @return {boolean} Whether the Scene is sleeping.\r\n   */\n  isSleeping: function isSleeping(key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    return this.manager.isSleeping(key);\n  },\n\n  /**\r\n   * Checks if the given Scene is active or not?\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#isActive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to check.\r\n   *\r\n   * @return {boolean} Whether the Scene is active.\r\n   */\n  isActive: function isActive(key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    return this.manager.isActive(key);\n  },\n\n  /**\r\n   * Checks if the given Scene is visible or not?\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#isVisible\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to check.\r\n   *\r\n   * @return {boolean} Whether the Scene is visible.\r\n   */\n  isVisible: function isVisible(key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    return this.manager.isVisible(key);\n  },\n\n  /**\r\n   * Swaps the position of two scenes in the Scenes list.\r\n   *\r\n   * This controls the order in which they are rendered and updated.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#swapPosition\r\n   * @since 3.2.0\r\n   *\r\n   * @param {string} keyA - The first Scene to swap.\r\n   * @param {string} [keyB] - The second Scene to swap. If none is given it defaults to this Scene.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  swapPosition: function swapPosition(keyA, keyB) {\n    if (keyB === undefined) {\n      keyB = this.key;\n    }\n\n    if (keyA !== keyB) {\n      this.manager.swapPosition(keyA, keyB);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Swaps the position of two scenes in the Scenes list, so that Scene B is directly above Scene A.\r\n   *\r\n   * This controls the order in which they are rendered and updated.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#moveAbove\r\n   * @since 3.2.0\r\n   *\r\n   * @param {string} keyA - The Scene that Scene B will be moved to be above.\r\n   * @param {string} [keyB] - The Scene to be moved. If none is given it defaults to this Scene.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  moveAbove: function moveAbove(keyA, keyB) {\n    if (keyB === undefined) {\n      keyB = this.key;\n    }\n\n    if (keyA !== keyB) {\n      this.manager.moveAbove(keyA, keyB);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Swaps the position of two scenes in the Scenes list, so that Scene B is directly below Scene A.\r\n   *\r\n   * This controls the order in which they are rendered and updated.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#moveBelow\r\n   * @since 3.2.0\r\n   *\r\n   * @param {string} keyA - The Scene that Scene B will be moved to be below.\r\n   * @param {string} [keyB] - The Scene to be moved. If none is given it defaults to this Scene.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  moveBelow: function moveBelow(keyA, keyB) {\n    if (keyB === undefined) {\n      keyB = this.key;\n    }\n\n    if (keyA !== keyB) {\n      this.manager.moveBelow(keyA, keyB);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes a Scene from the SceneManager.\r\n   *\r\n   * The Scene is removed from the local scenes array, it's key is cleared from the keys\r\n   * cache and Scene.Systems.destroy is then called on it.\r\n   *\r\n   * If the SceneManager is processing the Scenes when this method is called it wil\r\n   * queue the operation for the next update sequence.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#remove\r\n   * @since 3.2.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} [key] - The Scene to be removed.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  remove: function remove(key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.remove(key);\n    return this;\n  },\n\n  /**\r\n   * Moves a Scene up one position in the Scenes list.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#moveUp\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  moveUp: function moveUp(key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.moveUp(key);\n    return this;\n  },\n\n  /**\r\n   * Moves a Scene down one position in the Scenes list.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#moveDown\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  moveDown: function moveDown(key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.moveDown(key);\n    return this;\n  },\n\n  /**\r\n   * Brings a Scene to the top of the Scenes list.\r\n   *\r\n   * This means it will render above all other Scenes.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#bringToTop\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  bringToTop: function bringToTop(key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.bringToTop(key);\n    return this;\n  },\n\n  /**\r\n   * Sends a Scene to the back of the Scenes list.\r\n   *\r\n   * This means it will render below all other Scenes.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#sendToBack\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  sendToBack: function sendToBack(key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.sendToBack(key);\n    return this;\n  },\n\n  /**\r\n   * Retrieve a Scene.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#get\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to retrieve.\r\n   *\r\n   * @return {Phaser.Scene} The Scene.\r\n   */\n  get: function get(key) {\n    return this.manager.getScene(key);\n  },\n\n  /**\r\n   * Retrieves the numeric index of a Scene in the Scenes list.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#getIndex\r\n   * @since 3.7.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} [key] - The Scene to get the index of.\r\n   *\r\n   * @return {integer} The index of the Scene.\r\n   */\n  getIndex: function getIndex(key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    return this.manager.getIndex(key);\n  },\n\n  /**\r\n   * The Scene that owns this plugin is shutting down.\r\n   * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#shutdown\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  shutdown: function shutdown() {\n    var eventEmitter = this.systems.events;\n    eventEmitter.off(Events.SHUTDOWN, this.shutdown, this);\n    eventEmitter.off(Events.POST_UPDATE, this.step, this);\n    eventEmitter.off(Events.TRANSITION_OUT);\n  },\n\n  /**\r\n   * The Scene that owns this plugin is being destroyed.\r\n   * We need to shutdown and then kill off all external references.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#destroy\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    this.shutdown();\n    this.scene.sys.events.off(Events.START, this.start, this);\n    this.scene = null;\n    this.systems = null;\n    this.settings = null;\n    this.manager = null;\n  }\n});\nPluginCache.register('ScenePlugin', ScenePlugin, 'scenePlugin');\nmodule.exports = ScenePlugin;","map":null,"metadata":{},"sourceType":"script"}