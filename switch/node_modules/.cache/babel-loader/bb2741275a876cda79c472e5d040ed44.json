{"ast":null,"code":"/**\r\n* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.\r\n*\r\n* @class SAT\r\n*/\n// TODO: true circles and curves\nvar SAT = {};\nmodule.exports = SAT;\n\nvar Vertices = require('../geometry/Vertices');\n\nvar Vector = require('../geometry/Vector');\n\n(function () {\n  /**\r\n   * Detect collision between two bodies using the Separating Axis Theorem.\r\n   * @method collides\r\n   * @param {body} bodyA\r\n   * @param {body} bodyB\r\n   * @param {collision} previousCollision\r\n   * @return {collision} collision\r\n   */\n  SAT.collides = function (bodyA, bodyB, previousCollision) {\n    var overlapAB,\n        overlapBA,\n        minOverlap,\n        collision,\n        canReusePrevCol = false;\n\n    if (previousCollision) {\n      // estimate total motion\n      var parentA = bodyA.parent,\n          parentB = bodyB.parent,\n          motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed; // we may be able to (partially) reuse collision result \n      // but only safe if collision was resting\n\n      canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2; // reuse collision object\n\n      collision = previousCollision;\n    } else {\n      collision = {\n        collided: false,\n        bodyA: bodyA,\n        bodyB: bodyB\n      };\n    }\n\n    if (previousCollision && canReusePrevCol) {\n      // if we can reuse the collision result\n      // we only need to test the previously found axis\n      var axisBodyA = collision.axisBody,\n          axisBodyB = axisBodyA === bodyA ? bodyB : bodyA,\n          axes = [axisBodyA.axes[previousCollision.axisNumber]];\n      minOverlap = SAT._overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);\n      collision.reused = true;\n\n      if (minOverlap.overlap <= 0) {\n        collision.collided = false;\n        return collision;\n      }\n    } else {\n      // if we can't reuse a result, perform a full SAT test\n      overlapAB = SAT._overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);\n\n      if (overlapAB.overlap <= 0) {\n        collision.collided = false;\n        return collision;\n      }\n\n      overlapBA = SAT._overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);\n\n      if (overlapBA.overlap <= 0) {\n        collision.collided = false;\n        return collision;\n      }\n\n      if (overlapAB.overlap < overlapBA.overlap) {\n        minOverlap = overlapAB;\n        collision.axisBody = bodyA;\n      } else {\n        minOverlap = overlapBA;\n        collision.axisBody = bodyB;\n      } // important for reuse later\n\n\n      collision.axisNumber = minOverlap.axisNumber;\n    }\n\n    collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;\n    collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;\n    collision.collided = true;\n    collision.depth = minOverlap.overlap;\n    collision.parentA = collision.bodyA.parent;\n    collision.parentB = collision.bodyB.parent;\n    bodyA = collision.bodyA;\n    bodyB = collision.bodyB; // ensure normal is facing away from bodyA\n\n    if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {\n      collision.normal = {\n        x: minOverlap.axis.x,\n        y: minOverlap.axis.y\n      };\n    } else {\n      collision.normal = {\n        x: -minOverlap.axis.x,\n        y: -minOverlap.axis.y\n      };\n    }\n\n    collision.tangent = Vector.perp(collision.normal);\n    collision.penetration = collision.penetration || {};\n    collision.penetration.x = collision.normal.x * collision.depth;\n    collision.penetration.y = collision.normal.y * collision.depth; // find support points, there is always either exactly one or two\n\n    var verticesB = SAT._findSupports(bodyA, bodyB, collision.normal),\n        supports = []; // find the supports from bodyB that are inside bodyA\n\n\n    if (Vertices.contains(bodyA.vertices, verticesB[0])) supports.push(verticesB[0]);\n    if (Vertices.contains(bodyA.vertices, verticesB[1])) supports.push(verticesB[1]); // find the supports from bodyA that are inside bodyB\n\n    if (supports.length < 2) {\n      var verticesA = SAT._findSupports(bodyB, bodyA, Vector.neg(collision.normal));\n\n      if (Vertices.contains(bodyB.vertices, verticesA[0])) supports.push(verticesA[0]);\n      if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1])) supports.push(verticesA[1]);\n    } // account for the edge case of overlapping but no vertex containment\n\n\n    if (supports.length < 1) supports = [verticesB[0]];\n    collision.supports = supports;\n    return collision;\n  };\n  /**\r\n   * Find the overlap between two sets of vertices.\r\n   * @method _overlapAxes\r\n   * @private\r\n   * @param {} verticesA\r\n   * @param {} verticesB\r\n   * @param {} axes\r\n   * @return result\r\n   */\n\n\n  SAT._overlapAxes = function (verticesA, verticesB, axes) {\n    var projectionA = Vector._temp[0],\n        projectionB = Vector._temp[1],\n        result = {\n      overlap: Number.MAX_VALUE\n    },\n        overlap,\n        axis;\n\n    for (var i = 0; i < axes.length; i++) {\n      axis = axes[i];\n\n      SAT._projectToAxis(projectionA, verticesA, axis);\n\n      SAT._projectToAxis(projectionB, verticesB, axis);\n\n      overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);\n\n      if (overlap <= 0) {\n        result.overlap = overlap;\n        return result;\n      }\n\n      if (overlap < result.overlap) {\n        result.overlap = overlap;\n        result.axis = axis;\n        result.axisNumber = i;\n      }\n    }\n\n    return result;\n  };\n  /**\r\n   * Projects vertices on an axis and returns an interval.\r\n   * @method _projectToAxis\r\n   * @private\r\n   * @param {} projection\r\n   * @param {} vertices\r\n   * @param {} axis\r\n   */\n\n\n  SAT._projectToAxis = function (projection, vertices, axis) {\n    var min = Vector.dot(vertices[0], axis),\n        max = min;\n\n    for (var i = 1; i < vertices.length; i += 1) {\n      var dot = Vector.dot(vertices[i], axis);\n\n      if (dot > max) {\n        max = dot;\n      } else if (dot < min) {\n        min = dot;\n      }\n    }\n\n    projection.min = min;\n    projection.max = max;\n  };\n  /**\r\n   * Finds supporting vertices given two bodies along a given direction using hill-climbing.\r\n   * @method _findSupports\r\n   * @private\r\n   * @param {} bodyA\r\n   * @param {} bodyB\r\n   * @param {} normal\r\n   * @return [vector]\r\n   */\n\n\n  SAT._findSupports = function (bodyA, bodyB, normal) {\n    var nearestDistance = Number.MAX_VALUE,\n        vertexToBody = Vector._temp[0],\n        vertices = bodyB.vertices,\n        bodyAPosition = bodyA.position,\n        distance,\n        vertex,\n        vertexA,\n        vertexB; // find closest vertex on bodyB\n\n    for (var i = 0; i < vertices.length; i++) {\n      vertex = vertices[i];\n      vertexToBody.x = vertex.x - bodyAPosition.x;\n      vertexToBody.y = vertex.y - bodyAPosition.y;\n      distance = -Vector.dot(normal, vertexToBody);\n\n      if (distance < nearestDistance) {\n        nearestDistance = distance;\n        vertexA = vertex;\n      }\n    } // find next closest vertex using the two connected to it\n\n\n    var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;\n    vertex = vertices[prevIndex];\n    vertexToBody.x = vertex.x - bodyAPosition.x;\n    vertexToBody.y = vertex.y - bodyAPosition.y;\n    nearestDistance = -Vector.dot(normal, vertexToBody);\n    vertexB = vertex;\n    var nextIndex = (vertexA.index + 1) % vertices.length;\n    vertex = vertices[nextIndex];\n    vertexToBody.x = vertex.x - bodyAPosition.x;\n    vertexToBody.y = vertex.y - bodyAPosition.y;\n    distance = -Vector.dot(normal, vertexToBody);\n\n    if (distance < nearestDistance) {\n      vertexB = vertex;\n    }\n\n    return [vertexA, vertexB];\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}