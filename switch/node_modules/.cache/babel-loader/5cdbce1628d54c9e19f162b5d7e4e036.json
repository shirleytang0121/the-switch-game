{"ast":null,"code":"/**\r\n* The `Matter.Composite` module contains methods for creating and manipulating composite bodies.\r\n* A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.\r\n* It is important to use the functions in this module to modify composites, rather than directly modifying their properties.\r\n* Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Composite\r\n*/\nvar Composite = {};\nmodule.exports = Composite;\n\nvar Events = require('../core/Events');\n\nvar Common = require('../core/Common');\n\nvar Bounds = require('../geometry/Bounds');\n\nvar Body = require('./Body');\n\n(function () {\n  /**\r\n   * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n   * See the properites section below for detailed information on what you can pass via the `options` object.\r\n   * @method create\r\n   * @param {} [options]\r\n   * @return {composite} A new composite\r\n   */\n  Composite.create = function (options) {\n    return Common.extend({\n      id: Common.nextId(),\n      type: 'composite',\n      parent: null,\n      isModified: false,\n      bodies: [],\n      constraints: [],\n      composites: [],\n      label: 'Composite',\n      plugin: {}\n    }, options);\n  };\n  /**\r\n   * Sets the composite's `isModified` flag. \r\n   * If `updateParents` is true, all parents will be set (default: false).\r\n   * If `updateChildren` is true, all children will be set (default: false).\r\n   * @method setModified\r\n   * @param {composite} composite\r\n   * @param {boolean} isModified\r\n   * @param {boolean} [updateParents=false]\r\n   * @param {boolean} [updateChildren=false]\r\n   */\n\n\n  Composite.setModified = function (composite, isModified, updateParents, updateChildren) {\n    composite.isModified = isModified;\n\n    if (updateParents && composite.parent) {\n      Composite.setModified(composite.parent, isModified, updateParents, updateChildren);\n    }\n\n    if (updateChildren) {\n      for (var i = 0; i < composite.composites.length; i++) {\n        var childComposite = composite.composites[i];\n        Composite.setModified(childComposite, isModified, updateParents, updateChildren);\n      }\n    }\n  };\n  /**\r\n   * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.\r\n   * Triggers `beforeAdd` and `afterAdd` events on the `composite`.\r\n   * @method add\r\n   * @param {composite} composite\r\n   * @param {} object\r\n   * @return {composite} The original composite with the objects added\r\n   */\n\n\n  Composite.add = function (composite, object) {\n    var objects = [].concat(object);\n    Events.trigger(composite, 'beforeAdd', {\n      object: object\n    });\n\n    for (var i = 0; i < objects.length; i++) {\n      var obj = objects[i];\n\n      switch (obj.type) {\n        case 'body':\n          // skip adding compound parts\n          if (obj.parent !== obj) {\n            Common.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)');\n            break;\n          }\n\n          Composite.addBody(composite, obj);\n          break;\n\n        case 'constraint':\n          Composite.addConstraint(composite, obj);\n          break;\n\n        case 'composite':\n          Composite.addComposite(composite, obj);\n          break;\n\n        case 'mouseConstraint':\n          Composite.addConstraint(composite, obj.constraint);\n          break;\n      }\n    }\n\n    Events.trigger(composite, 'afterAdd', {\n      object: object\n    });\n    return composite;\n  };\n  /**\r\n   * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.\r\n   * Optionally searching its children recursively.\r\n   * Triggers `beforeRemove` and `afterRemove` events on the `composite`.\r\n   * @method remove\r\n   * @param {composite} composite\r\n   * @param {} object\r\n   * @param {boolean} [deep=false]\r\n   * @return {composite} The original composite with the objects removed\r\n   */\n\n\n  Composite.remove = function (composite, object, deep) {\n    var objects = [].concat(object);\n    Events.trigger(composite, 'beforeRemove', {\n      object: object\n    });\n\n    for (var i = 0; i < objects.length; i++) {\n      var obj = objects[i];\n\n      switch (obj.type) {\n        case 'body':\n          Composite.removeBody(composite, obj, deep);\n          break;\n\n        case 'constraint':\n          Composite.removeConstraint(composite, obj, deep);\n          break;\n\n        case 'composite':\n          Composite.removeComposite(composite, obj, deep);\n          break;\n\n        case 'mouseConstraint':\n          Composite.removeConstraint(composite, obj.constraint);\n          break;\n      }\n    }\n\n    Events.trigger(composite, 'afterRemove', {\n      object: object\n    });\n    return composite;\n  };\n  /**\r\n   * Adds a composite to the given composite.\r\n   * @private\r\n   * @method addComposite\r\n   * @param {composite} compositeA\r\n   * @param {composite} compositeB\r\n   * @return {composite} The original compositeA with the objects from compositeB added\r\n   */\n\n\n  Composite.addComposite = function (compositeA, compositeB) {\n    compositeA.composites.push(compositeB);\n    compositeB.parent = compositeA;\n    Composite.setModified(compositeA, true, true, false);\n    return compositeA;\n  };\n  /**\r\n   * Removes a composite from the given composite, and optionally searching its children recursively.\r\n   * @private\r\n   * @method removeComposite\r\n   * @param {composite} compositeA\r\n   * @param {composite} compositeB\r\n   * @param {boolean} [deep=false]\r\n   * @return {composite} The original compositeA with the composite removed\r\n   */\n\n\n  Composite.removeComposite = function (compositeA, compositeB, deep) {\n    var position = compositeA.composites.indexOf(compositeB);\n\n    if (position !== -1) {\n      Composite.removeCompositeAt(compositeA, position);\n      Composite.setModified(compositeA, true, true, false);\n    }\n\n    if (deep) {\n      for (var i = 0; i < compositeA.composites.length; i++) {\n        Composite.removeComposite(compositeA.composites[i], compositeB, true);\n      }\n    }\n\n    return compositeA;\n  };\n  /**\r\n   * Removes a composite from the given composite.\r\n   * @private\r\n   * @method removeCompositeAt\r\n   * @param {composite} composite\r\n   * @param {number} position\r\n   * @return {composite} The original composite with the composite removed\r\n   */\n\n\n  Composite.removeCompositeAt = function (composite, position) {\n    composite.composites.splice(position, 1);\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Adds a body to the given composite.\r\n   * @private\r\n   * @method addBody\r\n   * @param {composite} composite\r\n   * @param {body} body\r\n   * @return {composite} The original composite with the body added\r\n   */\n\n\n  Composite.addBody = function (composite, body) {\n    composite.bodies.push(body);\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Removes a body from the given composite, and optionally searching its children recursively.\r\n   * @private\r\n   * @method removeBody\r\n   * @param {composite} composite\r\n   * @param {body} body\r\n   * @param {boolean} [deep=false]\r\n   * @return {composite} The original composite with the body removed\r\n   */\n\n\n  Composite.removeBody = function (composite, body, deep) {\n    var position = composite.bodies.indexOf(body);\n\n    if (position !== -1) {\n      Composite.removeBodyAt(composite, position);\n      Composite.setModified(composite, true, true, false);\n    }\n\n    if (deep) {\n      for (var i = 0; i < composite.composites.length; i++) {\n        Composite.removeBody(composite.composites[i], body, true);\n      }\n    }\n\n    return composite;\n  };\n  /**\r\n   * Removes a body from the given composite.\r\n   * @private\r\n   * @method removeBodyAt\r\n   * @param {composite} composite\r\n   * @param {number} position\r\n   * @return {composite} The original composite with the body removed\r\n   */\n\n\n  Composite.removeBodyAt = function (composite, position) {\n    composite.bodies.splice(position, 1);\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Adds a constraint to the given composite.\r\n   * @private\r\n   * @method addConstraint\r\n   * @param {composite} composite\r\n   * @param {constraint} constraint\r\n   * @return {composite} The original composite with the constraint added\r\n   */\n\n\n  Composite.addConstraint = function (composite, constraint) {\n    composite.constraints.push(constraint);\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Removes a constraint from the given composite, and optionally searching its children recursively.\r\n   * @private\r\n   * @method removeConstraint\r\n   * @param {composite} composite\r\n   * @param {constraint} constraint\r\n   * @param {boolean} [deep=false]\r\n   * @return {composite} The original composite with the constraint removed\r\n   */\n\n\n  Composite.removeConstraint = function (composite, constraint, deep) {\n    var position = composite.constraints.indexOf(constraint);\n\n    if (position !== -1) {\n      Composite.removeConstraintAt(composite, position);\n    }\n\n    if (deep) {\n      for (var i = 0; i < composite.composites.length; i++) {\n        Composite.removeConstraint(composite.composites[i], constraint, true);\n      }\n    }\n\n    return composite;\n  };\n  /**\r\n   * Removes a body from the given composite.\r\n   * @private\r\n   * @method removeConstraintAt\r\n   * @param {composite} composite\r\n   * @param {number} position\r\n   * @return {composite} The original composite with the constraint removed\r\n   */\n\n\n  Composite.removeConstraintAt = function (composite, position) {\n    composite.constraints.splice(position, 1);\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Removes all bodies, constraints and composites from the given composite.\r\n   * Optionally clearing its children recursively.\r\n   * @method clear\r\n   * @param {composite} composite\r\n   * @param {boolean} keepStatic\r\n   * @param {boolean} [deep=false]\r\n   */\n\n\n  Composite.clear = function (composite, keepStatic, deep) {\n    if (deep) {\n      for (var i = 0; i < composite.composites.length; i++) {\n        Composite.clear(composite.composites[i], keepStatic, true);\n      }\n    }\n\n    if (keepStatic) {\n      composite.bodies = composite.bodies.filter(function (body) {\n        return body.isStatic;\n      });\n    } else {\n      composite.bodies.length = 0;\n    }\n\n    composite.constraints.length = 0;\n    composite.composites.length = 0;\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Returns all bodies in the given composite, including all bodies in its children, recursively.\r\n   * @method allBodies\r\n   * @param {composite} composite\r\n   * @return {body[]} All the bodies\r\n   */\n\n\n  Composite.allBodies = function (composite) {\n    var bodies = [].concat(composite.bodies);\n\n    for (var i = 0; i < composite.composites.length; i++) {\n      bodies = bodies.concat(Composite.allBodies(composite.composites[i]));\n    }\n\n    return bodies;\n  };\n  /**\r\n   * Returns all constraints in the given composite, including all constraints in its children, recursively.\r\n   * @method allConstraints\r\n   * @param {composite} composite\r\n   * @return {constraint[]} All the constraints\r\n   */\n\n\n  Composite.allConstraints = function (composite) {\n    var constraints = [].concat(composite.constraints);\n\n    for (var i = 0; i < composite.composites.length; i++) {\n      constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));\n    }\n\n    return constraints;\n  };\n  /**\r\n   * Returns all composites in the given composite, including all composites in its children, recursively.\r\n   * @method allComposites\r\n   * @param {composite} composite\r\n   * @return {composite[]} All the composites\r\n   */\n\n\n  Composite.allComposites = function (composite) {\n    var composites = [].concat(composite.composites);\n\n    for (var i = 0; i < composite.composites.length; i++) {\n      composites = composites.concat(Composite.allComposites(composite.composites[i]));\n    }\n\n    return composites;\n  };\n  /**\r\n   * Searches the composite recursively for an object matching the type and id supplied, null if not found.\r\n   * @method get\r\n   * @param {composite} composite\r\n   * @param {number} id\r\n   * @param {string} type\r\n   * @return {object} The requested object, if found\r\n   */\n\n\n  Composite.get = function (composite, id, type) {\n    var objects, object;\n\n    switch (type) {\n      case 'body':\n        objects = Composite.allBodies(composite);\n        break;\n\n      case 'constraint':\n        objects = Composite.allConstraints(composite);\n        break;\n\n      case 'composite':\n        objects = Composite.allComposites(composite).concat(composite);\n        break;\n    }\n\n    if (!objects) return null;\n    object = objects.filter(function (object) {\n      return object.id.toString() === id.toString();\n    });\n    return object.length === 0 ? null : object[0];\n  };\n  /**\r\n   * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).\r\n   * @method move\r\n   * @param {compositeA} compositeA\r\n   * @param {object[]} objects\r\n   * @param {compositeB} compositeB\r\n   * @return {composite} Returns compositeA\r\n   */\n\n\n  Composite.move = function (compositeA, objects, compositeB) {\n    Composite.remove(compositeA, objects);\n    Composite.add(compositeB, objects);\n    return compositeA;\n  };\n  /**\r\n   * Assigns new ids for all objects in the composite, recursively.\r\n   * @method rebase\r\n   * @param {composite} composite\r\n   * @return {composite} Returns composite\r\n   */\n\n\n  Composite.rebase = function (composite) {\n    var objects = Composite.allBodies(composite).concat(Composite.allConstraints(composite)).concat(Composite.allComposites(composite));\n\n    for (var i = 0; i < objects.length; i++) {\n      objects[i].id = Common.nextId();\n    }\n\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Translates all children in the composite by a given vector relative to their current positions, \r\n   * without imparting any velocity.\r\n   * @method translate\r\n   * @param {composite} composite\r\n   * @param {vector} translation\r\n   * @param {bool} [recursive=true]\r\n   */\n\n\n  Composite.translate = function (composite, translation, recursive) {\n    var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n    for (var i = 0; i < bodies.length; i++) {\n      Body.translate(bodies[i], translation);\n    }\n\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.\r\n   * @method rotate\r\n   * @param {composite} composite\r\n   * @param {number} rotation\r\n   * @param {vector} point\r\n   * @param {bool} [recursive=true]\r\n   */\n\n\n  Composite.rotate = function (composite, rotation, point, recursive) {\n    var cos = Math.cos(rotation),\n        sin = Math.sin(rotation),\n        bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i],\n          dx = body.position.x - point.x,\n          dy = body.position.y - point.y;\n      Body.setPosition(body, {\n        x: point.x + (dx * cos - dy * sin),\n        y: point.y + (dx * sin + dy * cos)\n      });\n      Body.rotate(body, rotation);\n    }\n\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.\r\n   * @method scale\r\n   * @param {composite} composite\r\n   * @param {number} scaleX\r\n   * @param {number} scaleY\r\n   * @param {vector} point\r\n   * @param {bool} [recursive=true]\r\n   */\n\n\n  Composite.scale = function (composite, scaleX, scaleY, point, recursive) {\n    var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i],\n          dx = body.position.x - point.x,\n          dy = body.position.y - point.y;\n      Body.setPosition(body, {\n        x: point.x + dx * scaleX,\n        y: point.y + dy * scaleY\n      });\n      Body.scale(body, scaleX, scaleY);\n    }\n\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Returns the union of the bounds of all of the composite's bodies.\r\n   * @method bounds\r\n   * @param {composite} composite The composite.\r\n   * @returns {bounds} The composite bounds.\r\n   */\n\n\n  Composite.bounds = function (composite) {\n    var bodies = Composite.allBodies(composite),\n        vertices = [];\n\n    for (var i = 0; i < bodies.length; i += 1) {\n      var body = bodies[i];\n      vertices.push(body.bounds.min, body.bounds.max);\n    }\n\n    return Bounds.create(vertices);\n  };\n  /*\r\n  *\r\n  *  Events Documentation\r\n  *\r\n  */\n\n  /**\r\n  * Fired when a call to `Composite.add` is made, before objects have been added.\r\n  *\r\n  * @event beforeAdd\r\n  * @param {} event An event object\r\n  * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired when a call to `Composite.add` is made, after objects have been added.\r\n  *\r\n  * @event afterAdd\r\n  * @param {} event An event object\r\n  * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired when a call to `Composite.remove` is made, before objects have been removed.\r\n  *\r\n  * @event beforeRemove\r\n  * @param {} event An event object\r\n  * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired when a call to `Composite.remove` is made, after objects have been removed.\r\n  *\r\n  * @event afterRemove\r\n  * @param {} event An event object\r\n  * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /*\r\n  *\r\n  *  Properties Documentation\r\n  *\r\n  */\n\n  /**\r\n   * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\r\n   *\r\n   * @property id\r\n   * @type number\r\n   */\n\n  /**\r\n   * A `String` denoting the type of object.\r\n   *\r\n   * @property type\r\n   * @type string\r\n   * @default \"composite\"\r\n   * @readOnly\r\n   */\n\n  /**\r\n   * An arbitrary `String` name to help the user identify and manage composites.\r\n   *\r\n   * @property label\r\n   * @type string\r\n   * @default \"Composite\"\r\n   */\n\n  /**\r\n   * A flag that specifies whether the composite has been modified during the current step.\r\n   * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.\r\n   * If you need to change it manually, you should use the `Composite.setModified` method.\r\n   *\r\n   * @property isModified\r\n   * @type boolean\r\n   * @default false\r\n   */\n\n  /**\r\n   * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.\r\n   *\r\n   * @property parent\r\n   * @type composite\r\n   * @default null\r\n   */\n\n  /**\r\n   * An array of `Body` that are _direct_ children of this composite.\r\n   * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\r\n   * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.\r\n   *\r\n   * @property bodies\r\n   * @type body[]\r\n   * @default []\r\n   */\n\n  /**\r\n   * An array of `Constraint` that are _direct_ children of this composite.\r\n   * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\r\n   * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.\r\n   *\r\n   * @property constraints\r\n   * @type constraint[]\r\n   * @default []\r\n   */\n\n  /**\r\n   * An array of `Composite` that are _direct_ children of this composite.\r\n   * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\r\n   * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.\r\n   *\r\n   * @property composites\r\n   * @type composite[]\r\n   * @default []\r\n   */\n\n  /**\r\n   * An object reserved for storing plugin-specific properties.\r\n   *\r\n   * @property plugin\r\n   * @type {}\r\n   */\n\n})();","map":null,"metadata":{},"sourceType":"script"}