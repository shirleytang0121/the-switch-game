{"ast":null,"code":"/**\r\n* The `Matter.Common` module contains utility functions that are common to all modules.\r\n*\r\n* @class Common\r\n*/\nvar Common = {};\nmodule.exports = Common;\n\n(function () {\n  Common._nextId = 0;\n  Common._seed = 0;\n  Common._nowStartTime = +new Date();\n  /**\r\n   * Extends the object in the first argument using the object in the second argument.\r\n   * @method extend\r\n   * @param {} obj\r\n   * @param {boolean} deep\r\n   * @return {} obj extended\r\n   */\n\n  Common.extend = function (obj, deep) {\n    var argsStart, args, deepClone;\n\n    if (typeof deep === 'boolean') {\n      argsStart = 2;\n      deepClone = deep;\n    } else {\n      argsStart = 1;\n      deepClone = true;\n    }\n\n    for (var i = argsStart; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      if (source) {\n        for (var prop in source) {\n          if (deepClone && source[prop] && source[prop].constructor === Object) {\n            if (!obj[prop] || obj[prop].constructor === Object) {\n              obj[prop] = obj[prop] || {};\n              Common.extend(obj[prop], deepClone, source[prop]);\n            } else {\n              obj[prop] = source[prop];\n            }\n          } else {\n            obj[prop] = source[prop];\n          }\n        }\n      }\n    }\n\n    return obj;\n  };\n  /**\r\n   * Creates a new clone of the object, if deep is true references will also be cloned.\r\n   * @method clone\r\n   * @param {} obj\r\n   * @param {bool} deep\r\n   * @return {} obj cloned\r\n   */\n\n\n  Common.clone = function (obj, deep) {\n    return Common.extend({}, deep, obj);\n  };\n  /**\r\n   * Returns the list of keys for the given object.\r\n   * @method keys\r\n   * @param {} obj\r\n   * @return {string[]} keys\r\n   */\n\n\n  Common.keys = function (obj) {\n    if (Object.keys) return Object.keys(obj); // avoid hasOwnProperty for performance\n\n    var keys = [];\n\n    for (var key in obj) {\n      keys.push(key);\n    }\n\n    return keys;\n  };\n  /**\r\n   * Returns the list of values for the given object.\r\n   * @method values\r\n   * @param {} obj\r\n   * @return {array} Array of the objects property values\r\n   */\n\n\n  Common.values = function (obj) {\n    var values = [];\n\n    if (Object.keys) {\n      var keys = Object.keys(obj);\n\n      for (var i = 0; i < keys.length; i++) {\n        values.push(obj[keys[i]]);\n      }\n\n      return values;\n    } // avoid hasOwnProperty for performance\n\n\n    for (var key in obj) {\n      values.push(obj[key]);\n    }\n\n    return values;\n  };\n  /**\r\n   * Gets a value from `base` relative to the `path` string.\r\n   * @method get\r\n   * @param {} obj The base object\r\n   * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\r\n   * @param {number} [begin] Path slice begin\r\n   * @param {number} [end] Path slice end\r\n   * @return {} The object at the given path\r\n   */\n\n\n  Common.get = function (obj, path, begin, end) {\n    path = path.split('.').slice(begin, end);\n\n    for (var i = 0; i < path.length; i += 1) {\n      obj = obj[path[i]];\n    }\n\n    return obj;\n  };\n  /**\r\n   * Sets a value on `base` relative to the given `path` string.\r\n   * @method set\r\n   * @param {} obj The base object\r\n   * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\r\n   * @param {} val The value to set\r\n   * @param {number} [begin] Path slice begin\r\n   * @param {number} [end] Path slice end\r\n   * @return {} Pass through `val` for chaining\r\n   */\n\n\n  Common.set = function (obj, path, val, begin, end) {\n    var parts = path.split('.').slice(begin, end);\n    Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;\n    return val;\n  };\n  /**\r\n   * Shuffles the given array in-place.\r\n   * The function uses a seeded random generator.\r\n   * @method shuffle\r\n   * @param {array} array\r\n   * @return {array} array shuffled randomly\r\n   */\n\n\n  Common.shuffle = function (array) {\n    for (var i = array.length - 1; i > 0; i--) {\n      var j = Math.floor(Common.random() * (i + 1));\n      var temp = array[i];\n      array[i] = array[j];\n      array[j] = temp;\n    }\n\n    return array;\n  };\n  /**\r\n   * Randomly chooses a value from a list with equal probability.\r\n   * The function uses a seeded random generator.\r\n   * @method choose\r\n   * @param {array} choices\r\n   * @return {object} A random choice object from the array\r\n   */\n\n\n  Common.choose = function (choices) {\n    return choices[Math.floor(Common.random() * choices.length)];\n  };\n  /**\r\n   * Returns true if the object is a HTMLElement, otherwise false.\r\n   * @method isElement\r\n   * @param {object} obj\r\n   * @return {boolean} True if the object is a HTMLElement, otherwise false\r\n   */\n\n\n  Common.isElement = function (obj) {\n    if (typeof HTMLElement !== 'undefined') {\n      return obj instanceof HTMLElement;\n    }\n\n    return !!(obj && obj.nodeType && obj.nodeName);\n  };\n  /**\r\n   * Returns true if the object is an array.\r\n   * @method isArray\r\n   * @param {object} obj\r\n   * @return {boolean} True if the object is an array, otherwise false\r\n   */\n\n\n  Common.isArray = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n  /**\r\n   * Returns true if the object is a function.\r\n   * @method isFunction\r\n   * @param {object} obj\r\n   * @return {boolean} True if the object is a function, otherwise false\r\n   */\n\n\n  Common.isFunction = function (obj) {\n    return typeof obj === \"function\";\n  };\n  /**\r\n   * Returns true if the object is a plain object.\r\n   * @method isPlainObject\r\n   * @param {object} obj\r\n   * @return {boolean} True if the object is a plain object, otherwise false\r\n   */\n\n\n  Common.isPlainObject = function (obj) {\n    return typeof obj === 'object' && obj.constructor === Object;\n  };\n  /**\r\n   * Returns true if the object is a string.\r\n   * @method isString\r\n   * @param {object} obj\r\n   * @return {boolean} True if the object is a string, otherwise false\r\n   */\n\n\n  Common.isString = function (obj) {\n    return toString.call(obj) === '[object String]';\n  };\n  /**\r\n   * Returns the given value clamped between a minimum and maximum value.\r\n   * @method clamp\r\n   * @param {number} value\r\n   * @param {number} min\r\n   * @param {number} max\r\n   * @return {number} The value clamped between min and max inclusive\r\n   */\n\n\n  Common.clamp = function (value, min, max) {\n    if (value < min) return min;\n    if (value > max) return max;\n    return value;\n  };\n  /**\r\n   * Returns the sign of the given value.\r\n   * @method sign\r\n   * @param {number} value\r\n   * @return {number} -1 if negative, +1 if 0 or positive\r\n   */\n\n\n  Common.sign = function (value) {\n    return value < 0 ? -1 : 1;\n  };\n  /**\r\n   * Returns the current timestamp since the time origin (e.g. from page load).\r\n   * The result will be high-resolution including decimal places if available.\r\n   * @method now\r\n   * @return {number} the current timestamp\r\n   */\n\n\n  Common.now = function () {\n    if (window.performance) {\n      if (window.performance.now) {\n        return window.performance.now();\n      } else if (window.performance.webkitNow) {\n        return window.performance.webkitNow();\n      }\n    }\n\n    return new Date() - Common._nowStartTime;\n  };\n  /**\r\n   * Returns a random value between a minimum and a maximum value inclusive.\r\n   * The function uses a seeded random generator.\r\n   * @method random\r\n   * @param {number} min\r\n   * @param {number} max\r\n   * @return {number} A random number between min and max inclusive\r\n   */\n\n\n  Common.random = function (min, max) {\n    min = typeof min !== \"undefined\" ? min : 0;\n    max = typeof max !== \"undefined\" ? max : 1;\n    return min + _seededRandom() * (max - min);\n  };\n\n  var _seededRandom = function _seededRandom() {\n    // https://en.wikipedia.org/wiki/Linear_congruential_generator\n    Common._seed = (Common._seed * 9301 + 49297) % 233280;\n    return Common._seed / 233280;\n  };\n  /**\r\n   * Converts a CSS hex colour string into an integer.\r\n   * @method colorToNumber\r\n   * @param {string} colorString\r\n   * @return {number} An integer representing the CSS hex string\r\n   */\n\n\n  Common.colorToNumber = function (colorString) {\n    colorString = colorString.replace('#', '');\n\n    if (colorString.length == 3) {\n      colorString = colorString.charAt(0) + colorString.charAt(0) + colorString.charAt(1) + colorString.charAt(1) + colorString.charAt(2) + colorString.charAt(2);\n    }\n\n    return parseInt(colorString, 16);\n  };\n  /**\r\n   * The console logging level to use, where each level includes all levels above and excludes the levels below.\r\n   * The default level is 'debug' which shows all console messages.  \r\n   *\r\n   * Possible level values are:\r\n   * - 0 = None\r\n   * - 1 = Debug\r\n   * - 2 = Info\r\n   * - 3 = Warn\r\n   * - 4 = Error\r\n   * @property Common.logLevel\r\n   * @type {Number}\r\n   * @default 1\r\n   */\n\n\n  Common.logLevel = 1;\n  /**\r\n   * Shows a `console.log` message only if the current `Common.logLevel` allows it.\r\n   * The message will be prefixed with 'matter-js' to make it easily identifiable.\r\n   * @method log\r\n   * @param ...objs {} The objects to log.\r\n   */\n\n  Common.log = function () {\n    if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n      console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n    }\n  };\n  /**\r\n   * Shows a `console.info` message only if the current `Common.logLevel` allows it.\r\n   * The message will be prefixed with 'matter-js' to make it easily identifiable.\r\n   * @method info\r\n   * @param ...objs {} The objects to log.\r\n   */\n\n\n  Common.info = function () {\n    if (console && Common.logLevel > 0 && Common.logLevel <= 2) {\n      console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n    }\n  };\n  /**\r\n   * Shows a `console.warn` message only if the current `Common.logLevel` allows it.\r\n   * The message will be prefixed with 'matter-js' to make it easily identifiable.\r\n   * @method warn\r\n   * @param ...objs {} The objects to log.\r\n   */\n\n\n  Common.warn = function () {\n    if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n      console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n    }\n  };\n  /**\r\n   * Returns the next unique sequential ID.\r\n   * @method nextId\r\n   * @return {Number} Unique sequential ID\r\n   */\n\n\n  Common.nextId = function () {\n    return Common._nextId++;\n  };\n  /**\r\n   * A cross browser compatible indexOf implementation.\r\n   * @method indexOf\r\n   * @param {array} haystack\r\n   * @param {object} needle\r\n   * @return {number} The position of needle in haystack, otherwise -1.\r\n   */\n\n\n  Common.indexOf = function (haystack, needle) {\n    if (haystack.indexOf) return haystack.indexOf(needle);\n\n    for (var i = 0; i < haystack.length; i++) {\n      if (haystack[i] === needle) return i;\n    }\n\n    return -1;\n  };\n  /**\r\n   * A cross browser compatible array map implementation.\r\n   * @method map\r\n   * @param {array} list\r\n   * @param {function} func\r\n   * @return {array} Values from list transformed by func.\r\n   */\n\n\n  Common.map = function (list, func) {\n    if (list.map) {\n      return list.map(func);\n    }\n\n    var mapped = [];\n\n    for (var i = 0; i < list.length; i += 1) {\n      mapped.push(func(list[i]));\n    }\n\n    return mapped;\n  };\n  /**\r\n   * Takes a directed graph and returns the partially ordered set of vertices in topological order.\r\n   * Circular dependencies are allowed.\r\n   * @method topologicalSort\r\n   * @param {object} graph\r\n   * @return {array} Partially ordered set of vertices in topological order.\r\n   */\n\n\n  Common.topologicalSort = function (graph) {\n    // https://github.com/mgechev/javascript-algorithms\n    // Copyright (c) Minko Gechev (MIT license)\n    // Modifications: tidy formatting and naming\n    var result = [],\n        visited = [],\n        temp = [];\n\n    for (var node in graph) {\n      if (!visited[node] && !temp[node]) {\n        Common._topologicalSort(node, visited, temp, graph, result);\n      }\n    }\n\n    return result;\n  };\n\n  Common._topologicalSort = function (node, visited, temp, graph, result) {\n    var neighbors = graph[node] || [];\n    temp[node] = true;\n\n    for (var i = 0; i < neighbors.length; i += 1) {\n      var neighbor = neighbors[i];\n\n      if (temp[neighbor]) {\n        // skip circular dependencies\n        continue;\n      }\n\n      if (!visited[neighbor]) {\n        Common._topologicalSort(neighbor, visited, temp, graph, result);\n      }\n    }\n\n    temp[node] = false;\n    visited[node] = true;\n    result.push(node);\n  };\n  /**\r\n   * Takes _n_ functions as arguments and returns a new function that calls them in order.\r\n   * The arguments applied when calling the new function will also be applied to every function passed.\r\n   * The value of `this` refers to the last value returned in the chain that was not `undefined`.\r\n   * Therefore if a passed function does not return a value, the previously returned value is maintained.\r\n   * After all passed functions have been called the new function returns the last returned value (if any).\r\n   * If any of the passed functions are a chain, then the chain will be flattened.\r\n   * @method chain\r\n   * @param ...funcs {function} The functions to chain.\r\n   * @return {function} A new function that calls the passed functions in order.\r\n   */\n\n\n  Common.chain = function () {\n    var funcs = [];\n\n    for (var i = 0; i < arguments.length; i += 1) {\n      var func = arguments[i];\n\n      if (func._chained) {\n        // flatten already chained functions\n        funcs.push.apply(funcs, func._chained);\n      } else {\n        funcs.push(func);\n      }\n    }\n\n    var chain = function chain() {\n      // https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358\n      var lastResult,\n          args = new Array(arguments.length);\n\n      for (var i = 0, l = arguments.length; i < l; i++) {\n        args[i] = arguments[i];\n      }\n\n      for (i = 0; i < funcs.length; i += 1) {\n        var result = funcs[i].apply(lastResult, args);\n\n        if (typeof result !== 'undefined') {\n          lastResult = result;\n        }\n      }\n\n      return lastResult;\n    };\n\n    chain._chained = funcs;\n    return chain;\n  };\n  /**\r\n   * Chains a function to excute before the original function on the given `path` relative to `base`.\r\n   * See also docs for `Common.chain`.\r\n   * @method chainPathBefore\r\n   * @param {} base The base object\r\n   * @param {string} path The path relative to `base`\r\n   * @param {function} func The function to chain before the original\r\n   * @return {function} The chained function that replaced the original\r\n   */\n\n\n  Common.chainPathBefore = function (base, path, func) {\n    return Common.set(base, path, Common.chain(func, Common.get(base, path)));\n  };\n  /**\r\n   * Chains a function to excute after the original function on the given `path` relative to `base`.\r\n   * See also docs for `Common.chain`.\r\n   * @method chainPathAfter\r\n   * @param {} base The base object\r\n   * @param {string} path The path relative to `base`\r\n   * @param {function} func The function to chain after the original\r\n   * @return {function} The chained function that replaced the original\r\n   */\n\n\n  Common.chainPathAfter = function (base, path, func) {\n    return Common.set(base, path, Common.chain(Common.get(base, path), func));\n  };\n  /**\r\n   * Used to require external libraries outside of the bundle.\r\n   * It first looks for the `globalName` on the environment's global namespace.\r\n   * If the global is not found, it will fall back to using the standard `require` using the `moduleName`.\r\n   * @private\r\n   * @method _requireGlobal\r\n   * @param {string} globalName The global module name\r\n   * @param {string} moduleName The fallback CommonJS module name\r\n   * @return {} The loaded module\r\n   */\n\n\n  Common._requireGlobal = function (globalName, moduleName) {\n    var obj = typeof window !== 'undefined' ? window[globalName] : typeof global !== 'undefined' ? global[globalName] : null; //  Breaks webpack :(\n    // return obj || require(moduleName);\n\n    return obj;\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}