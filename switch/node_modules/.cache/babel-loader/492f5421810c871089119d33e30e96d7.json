{"ast":null,"code":"var AWS = require('./core');\n/**\r\n * @api private\r\n * @!method on(eventName, callback)\r\n *   Registers an event listener callback for the event given by `eventName`.\r\n *   Parameters passed to the callback function depend on the individual event\r\n *   being triggered. See the event documentation for those parameters.\r\n *\r\n *   @param eventName [String] the event name to register the listener for\r\n *   @param callback [Function] the listener callback function\r\n *   @param toHead [Boolean] attach the listener callback to the head of callback array if set to true.\r\n *     Default to be false.\r\n *   @return [AWS.SequentialExecutor] the same object for chaining\r\n */\n\n\nAWS.SequentialExecutor = AWS.util.inherit({\n  constructor: function SequentialExecutor() {\n    this._events = {};\n  },\n\n  /**\r\n   * @api private\r\n   */\n  listeners: function listeners(eventName) {\n    return this._events[eventName] ? this._events[eventName].slice(0) : [];\n  },\n  on: function on(eventName, listener, toHead) {\n    if (this._events[eventName]) {\n      toHead ? this._events[eventName].unshift(listener) : this._events[eventName].push(listener);\n    } else {\n      this._events[eventName] = [listener];\n    }\n\n    return this;\n  },\n\n  /**\r\n   * @api private\r\n   */\n  onAsync: function onAsync(eventName, listener, toHead) {\n    listener._isAsync = true;\n    return this.on(eventName, listener, toHead);\n  },\n  removeListener: function removeListener(eventName, listener) {\n    var listeners = this._events[eventName];\n\n    if (listeners) {\n      var length = listeners.length;\n      var position = -1;\n\n      for (var i = 0; i < length; ++i) {\n        if (listeners[i] === listener) {\n          position = i;\n        }\n      }\n\n      if (position > -1) {\n        listeners.splice(position, 1);\n      }\n    }\n\n    return this;\n  },\n  removeAllListeners: function removeAllListeners(eventName) {\n    if (eventName) {\n      delete this._events[eventName];\n    } else {\n      this._events = {};\n    }\n\n    return this;\n  },\n\n  /**\r\n   * @api private\r\n   */\n  emit: function emit(eventName, eventArgs, doneCallback) {\n    if (!doneCallback) doneCallback = function doneCallback() {};\n    var listeners = this.listeners(eventName);\n    var count = listeners.length;\n    this.callListeners(listeners, eventArgs, doneCallback);\n    return count > 0;\n  },\n\n  /**\r\n   * @api private\r\n   */\n  callListeners: function callListeners(listeners, args, doneCallback, prevError) {\n    var self = this;\n    var error = prevError || null;\n\n    function callNextListener(err) {\n      if (err) {\n        error = AWS.util.error(error || new Error(), err);\n\n        if (self._haltHandlersOnError) {\n          return doneCallback.call(self, error);\n        }\n      }\n\n      self.callListeners(listeners, args, doneCallback, error);\n    }\n\n    while (listeners.length > 0) {\n      var listener = listeners.shift();\n\n      if (listener._isAsync) {\n        // asynchronous listener\n        listener.apply(self, args.concat([callNextListener]));\n        return; // stop here, callNextListener will continue\n      } else {\n        // synchronous listener\n        try {\n          listener.apply(self, args);\n        } catch (err) {\n          error = AWS.util.error(error || new Error(), err);\n        }\n\n        if (error && self._haltHandlersOnError) {\n          doneCallback.call(self, error);\n          return;\n        }\n      }\n    }\n\n    doneCallback.call(self, error);\n  },\n\n  /**\r\n   * Adds or copies a set of listeners from another list of\r\n   * listeners or SequentialExecutor object.\r\n   *\r\n   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]\r\n   *   a list of events and callbacks, or an event emitter object\r\n   *   containing listeners to add to this emitter object.\r\n   * @return [AWS.SequentialExecutor] the emitter object, for chaining.\r\n   * @example Adding listeners from a map of listeners\r\n   *   emitter.addListeners({\r\n   *     event1: [function() { ... }, function() { ... }],\r\n   *     event2: [function() { ... }]\r\n   *   });\r\n   *   emitter.emit('event1'); // emitter has event1\r\n   *   emitter.emit('event2'); // emitter has event2\r\n   * @example Adding listeners from another emitter object\r\n   *   var emitter1 = new AWS.SequentialExecutor();\r\n   *   emitter1.on('event1', function() { ... });\r\n   *   emitter1.on('event2', function() { ... });\r\n   *   var emitter2 = new AWS.SequentialExecutor();\r\n   *   emitter2.addListeners(emitter1);\r\n   *   emitter2.emit('event1'); // emitter2 has event1\r\n   *   emitter2.emit('event2'); // emitter2 has event2\r\n   */\n  addListeners: function addListeners(listeners) {\n    var self = this; // extract listeners if parameter is an SequentialExecutor object\n\n    if (listeners._events) listeners = listeners._events;\n    AWS.util.each(listeners, function (event, callbacks) {\n      if (typeof callbacks === 'function') callbacks = [callbacks];\n      AWS.util.arrayEach(callbacks, function (callback) {\n        self.on(event, callback);\n      });\n    });\n    return self;\n  },\n\n  /**\r\n   * Registers an event with {on} and saves the callback handle function\r\n   * as a property on the emitter object using a given `name`.\r\n   *\r\n   * @param name [String] the property name to set on this object containing\r\n   *   the callback function handle so that the listener can be removed in\r\n   *   the future.\r\n   * @param (see on)\r\n   * @return (see on)\r\n   * @example Adding a named listener DATA_CALLBACK\r\n   *   var listener = function() { doSomething(); };\r\n   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);\r\n   *\r\n   *   // the following prints: true\r\n   *   console.log(emitter.DATA_CALLBACK == listener);\r\n   */\n  addNamedListener: function addNamedListener(name, eventName, callback, toHead) {\n    this[name] = callback;\n    this.addListener(eventName, callback, toHead);\n    return this;\n  },\n\n  /**\r\n   * @api private\r\n   */\n  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback) {\n    callback._isAsync = true;\n    return this.addNamedListener(name, eventName, callback);\n  },\n\n  /**\r\n   * Helper method to add a set of named listeners using\r\n   * {addNamedListener}. The callback contains a parameter\r\n   * with a handle to the `addNamedListener` method.\r\n   *\r\n   * @callback callback function(add)\r\n   *   The callback function is called immediately in order to provide\r\n   *   the `add` function to the block. This simplifies the addition of\r\n   *   a large group of named listeners.\r\n   *   @param add [Function] the {addNamedListener} function to call\r\n   *     when registering listeners.\r\n   * @example Adding a set of named listeners\r\n   *   emitter.addNamedListeners(function(add) {\r\n   *     add('DATA_CALLBACK', 'data', function() { ... });\r\n   *     add('OTHER', 'otherEvent', function() { ... });\r\n   *     add('LAST', 'lastEvent', function() { ... });\r\n   *   });\r\n   *\r\n   *   // these properties are now set:\r\n   *   emitter.DATA_CALLBACK;\r\n   *   emitter.OTHER;\r\n   *   emitter.LAST;\r\n   */\n  addNamedListeners: function addNamedListeners(callback) {\n    var self = this;\n    callback(function () {\n      self.addNamedListener.apply(self, arguments);\n    }, function () {\n      self.addNamedAsyncListener.apply(self, arguments);\n    });\n    return this;\n  }\n});\n/**\r\n * {on} is the prefered method.\r\n * @api private\r\n */\n\nAWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;\n/**\r\n * @api private\r\n */\n\nmodule.exports = AWS.SequentialExecutor;","map":null,"metadata":{},"sourceType":"script"}