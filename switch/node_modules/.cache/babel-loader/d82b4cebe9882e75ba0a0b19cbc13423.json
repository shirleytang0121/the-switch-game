{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar Clamp = require('../math/Clamp');\n\nvar Extend = require('../utils/object/Extend');\n/**\r\n * @classdesc\r\n * A Frame is a section of a Texture.\r\n *\r\n * @class Frame\r\n * @memberof Phaser.Textures\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture this Frame is a part of.\r\n * @param {(integer|string)} name - The name of this Frame. The name is unique within the Texture.\r\n * @param {integer} sourceIndex - The index of the TextureSource that this Frame is a part of.\r\n * @param {number} x - The x coordinate of the top-left of this Frame.\r\n * @param {number} y - The y coordinate of the top-left of this Frame.\r\n * @param {number} width - The width of this Frame.\r\n * @param {number} height - The height of this Frame.\r\n */\n\n\nvar Frame = new Class({\n  initialize: function Frame(texture, name, sourceIndex, x, y, width, height) {\n    /**\r\n     * The Texture this Frame is a part of.\r\n     *\r\n     * @name Phaser.Textures.Frame#texture\r\n     * @type {Phaser.Textures.Texture}\r\n     * @since 3.0.0\r\n     */\n    this.texture = texture;\n    /**\r\n     * The name of this Frame.\r\n     * The name is unique within the Texture.\r\n     *\r\n     * @name Phaser.Textures.Frame#name\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n\n    this.name = name;\n    /**\r\n     * The TextureSource this Frame is part of.\r\n     *\r\n     * @name Phaser.Textures.Frame#source\r\n     * @type {Phaser.Textures.TextureSource}\r\n     * @since 3.0.0\r\n     */\n\n    this.source = texture.source[sourceIndex];\n    /**\r\n     * The index of the TextureSource in the Texture sources array.\r\n     *\r\n     * @name Phaser.Textures.Frame#sourceIndex\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.sourceIndex = sourceIndex;\n    /**\r\n     * A reference to the Texture Source WebGL Texture that this Frame is using.\r\n     *\r\n     * @name Phaser.Textures.Frame#glTexture\r\n     * @type {?WebGLTexture}\r\n     * @default null\r\n     * @since 3.11.0\r\n     */\n\n    this.glTexture = this.source.glTexture;\n    /**\r\n     * X position within the source image to cut from.\r\n     *\r\n     * @name Phaser.Textures.Frame#cutX\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.cutX;\n    /**\r\n     * Y position within the source image to cut from.\r\n     *\r\n     * @name Phaser.Textures.Frame#cutY\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.cutY;\n    /**\r\n     * The width of the area in the source image to cut.\r\n     *\r\n     * @name Phaser.Textures.Frame#cutWidth\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.cutWidth;\n    /**\r\n     * The height of the area in the source image to cut.\r\n     *\r\n     * @name Phaser.Textures.Frame#cutHeight\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.cutHeight;\n    /**\r\n     * The X rendering offset of this Frame, taking trim into account.\r\n     *\r\n     * @name Phaser.Textures.Frame#x\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.x = 0;\n    /**\r\n     * The Y rendering offset of this Frame, taking trim into account.\r\n     *\r\n     * @name Phaser.Textures.Frame#y\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.y = 0;\n    /**\r\n     * The rendering width of this Frame, taking trim into account.\r\n     *\r\n     * @name Phaser.Textures.Frame#width\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.width;\n    /**\r\n     * The rendering height of this Frame, taking trim into account.\r\n     *\r\n     * @name Phaser.Textures.Frame#height\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.height;\n    /**\r\n     * Half the width, floored.\r\n     * Precalculated for the renderer.\r\n     *\r\n     * @name Phaser.Textures.Frame#halfWidth\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.halfWidth;\n    /**\r\n     * Half the height, floored.\r\n     * Precalculated for the renderer.\r\n     *\r\n     * @name Phaser.Textures.Frame#halfHeight\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.halfHeight;\n    /**\r\n     * The x center of this frame, floored.\r\n     *\r\n     * @name Phaser.Textures.Frame#centerX\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.centerX;\n    /**\r\n     * The y center of this frame, floored.\r\n     *\r\n     * @name Phaser.Textures.Frame#centerY\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.centerY;\n    /**\r\n     * The horizontal pivot point of this Frame.\r\n     *\r\n     * @name Phaser.Textures.Frame#pivotX\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.pivotX = 0;\n    /**\r\n     * The vertical pivot point of this Frame.\r\n     *\r\n     * @name Phaser.Textures.Frame#pivotY\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.pivotY = 0;\n    /**\r\n     * Does this Frame have a custom pivot point?\r\n     *\r\n     * @name Phaser.Textures.Frame#customPivot\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.customPivot = false;\n    /**\r\n     * **CURRENTLY UNSUPPORTED**\r\n     *\r\n     * Is this frame is rotated or not in the Texture?\r\n     * Rotation allows you to use rotated frames in texture atlas packing.\r\n     * It has nothing to do with Sprite rotation.\r\n     *\r\n     * @name Phaser.Textures.Frame#rotated\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.rotated = false;\n    /**\r\n     * Over-rides the Renderer setting.\r\n     * -1 = use Renderer Setting\r\n     * 0 = No rounding\r\n     * 1 = Round\r\n     *\r\n     * @name Phaser.Textures.Frame#autoRound\r\n     * @type {integer}\r\n     * @default -1\r\n     * @since 3.0.0\r\n     */\n\n    this.autoRound = -1;\n    /**\r\n     * Any Frame specific custom data can be stored here.\r\n     *\r\n     * @name Phaser.Textures.Frame#customData\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.customData = {};\n    /**\r\n     * WebGL UV u0 value.\r\n     *\r\n     * @name Phaser.Textures.Frame#u0\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.11.0\r\n     */\n\n    this.u0 = 0;\n    /**\r\n     * WebGL UV v0 value.\r\n     *\r\n     * @name Phaser.Textures.Frame#v0\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.11.0\r\n     */\n\n    this.v0 = 0;\n    /**\r\n     * WebGL UV u1 value.\r\n     *\r\n     * @name Phaser.Textures.Frame#u1\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.11.0\r\n     */\n\n    this.u1 = 0;\n    /**\r\n     * WebGL UV v1 value.\r\n     *\r\n     * @name Phaser.Textures.Frame#v1\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.11.0\r\n     */\n\n    this.v1 = 0;\n    /**\r\n     * The un-modified source frame, trim and UV data.\r\n     *\r\n     * @name Phaser.Textures.Frame#data\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this.data = {\n      cut: {\n        x: 0,\n        y: 0,\n        w: 0,\n        h: 0,\n        r: 0,\n        b: 0\n      },\n      trim: false,\n      sourceSize: {\n        w: 0,\n        h: 0\n      },\n      spriteSourceSize: {\n        x: 0,\n        y: 0,\n        w: 0,\n        h: 0,\n        r: 0,\n        b: 0\n      },\n      radius: 0,\n      drawImage: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      }\n    };\n    this.setSize(width, height, x, y);\n  },\n\n  /**\r\n   * Sets the width, height, x and y of this Frame.\r\n   * \r\n   * This is called automatically by the constructor\r\n   * and should rarely be changed on-the-fly.\r\n   *\r\n   * @method Phaser.Textures.Frame#setSize\r\n   * @since 3.7.0\r\n   *\r\n   * @param {integer} width - The width of the frame before being trimmed.\r\n   * @param {integer} height - The height of the frame before being trimmed.\r\n   * @param {integer} [x=0] - The x coordinate of the top-left of this Frame.\r\n   * @param {integer} [y=0] - The y coordinate of the top-left of this Frame.\r\n   *\r\n   * @return {Phaser.Textures.Frame} This Frame object.\r\n   */\n  setSize: function setSize(width, height, x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    this.cutX = x;\n    this.cutY = y;\n    this.cutWidth = width;\n    this.cutHeight = height;\n    this.width = width;\n    this.height = height;\n    this.halfWidth = Math.floor(width * 0.5);\n    this.halfHeight = Math.floor(height * 0.5);\n    this.centerX = Math.floor(width / 2);\n    this.centerY = Math.floor(height / 2);\n    var data = this.data;\n    var cut = data.cut;\n    cut.x = x;\n    cut.y = y;\n    cut.w = width;\n    cut.h = height;\n    cut.r = x + width;\n    cut.b = y + height;\n    data.sourceSize.w = width;\n    data.sourceSize.h = height;\n    data.spriteSourceSize.w = width;\n    data.spriteSourceSize.h = height;\n    data.radius = 0.5 * Math.sqrt(width * width + height * height);\n    var drawImage = data.drawImage;\n    drawImage.x = x;\n    drawImage.y = y;\n    drawImage.width = width;\n    drawImage.height = height;\n    return this.updateUVs();\n  },\n\n  /**\r\n   * If the frame was trimmed when added to the Texture Atlas, this records the trim and source data.\r\n   *\r\n   * @method Phaser.Textures.Frame#setTrim\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} actualWidth - The width of the frame before being trimmed.\r\n   * @param {number} actualHeight - The height of the frame before being trimmed.\r\n   * @param {number} destX - The destination X position of the trimmed frame for display.\r\n   * @param {number} destY - The destination Y position of the trimmed frame for display.\r\n   * @param {number} destWidth - The destination width of the trimmed frame for display.\r\n   * @param {number} destHeight - The destination height of the trimmed frame for display.\r\n   *\r\n   * @return {Phaser.Textures.Frame} This Frame object.\r\n   */\n  setTrim: function setTrim(actualWidth, actualHeight, destX, destY, destWidth, destHeight) {\n    var data = this.data;\n    var ss = data.spriteSourceSize; //  Store actual values\n\n    data.trim = true;\n    data.sourceSize.w = actualWidth;\n    data.sourceSize.h = actualHeight;\n    ss.x = destX;\n    ss.y = destY;\n    ss.w = destWidth;\n    ss.h = destHeight;\n    ss.r = destX + destWidth;\n    ss.b = destY + destHeight; //  Adjust properties\n\n    this.x = destX;\n    this.y = destY;\n    this.width = destWidth;\n    this.height = destHeight;\n    this.halfWidth = destWidth * 0.5;\n    this.halfHeight = destHeight * 0.5;\n    this.centerX = Math.floor(destWidth / 2);\n    this.centerY = Math.floor(destHeight / 2);\n    return this.updateUVs();\n  },\n\n  /**\r\n   * Takes a crop data object and, based on the rectangular region given, calculates the\r\n   * required UV coordinates in order to crop this Frame for WebGL and Canvas rendering.\r\n   * \r\n   * This is called directly by the Game Object Texture Components `setCrop` method.\r\n   * Please use that method to crop a Game Object.\r\n   *\r\n   * @method Phaser.Textures.Frame#setCropUVs\r\n   * @since 3.11.0\r\n   * \r\n   * @param {object} crop - The crop data object. This is the `GameObject._crop` property.\r\n   * @param {number} x - The x coordinate to start the crop from. Cannot be negative or exceed the Frame width.\r\n   * @param {number} y - The y coordinate to start the crop from. Cannot be negative or exceed the Frame height.\r\n   * @param {number} width - The width of the crop rectangle. Cannot exceed the Frame width.\r\n   * @param {number} height - The height of the crop rectangle. Cannot exceed the Frame height.\r\n   * @param {boolean} flipX - Does the parent Game Object have flipX set?\r\n   * @param {boolean} flipY - Does the parent Game Object have flipY set?\r\n   *\r\n   * @return {object} The updated crop data object.\r\n   */\n  setCropUVs: function setCropUVs(crop, x, y, width, height, flipX, flipY) {\n    //  Clamp the input values\n    var cx = this.cutX;\n    var cy = this.cutY;\n    var cw = this.cutWidth;\n    var ch = this.cutHeight;\n    var rw = this.realWidth;\n    var rh = this.realHeight;\n    x = Clamp(x, 0, rw);\n    y = Clamp(y, 0, rh);\n    width = Clamp(width, 0, rw - x);\n    height = Clamp(height, 0, rh - y);\n    var ox = cx + x;\n    var oy = cy + y;\n    var ow = width;\n    var oh = height;\n    var data = this.data;\n\n    if (data.trim) {\n      var ss = data.spriteSourceSize; //  Need to check for intersection between the cut area and the crop area\n      //  If there is none, we set UV to be empty, otherwise set it to be the intersection area\n\n      width = Clamp(width, 0, cw - x);\n      height = Clamp(height, 0, ch - y);\n      var cropRight = x + width;\n      var cropBottom = y + height;\n      var intersects = !(ss.r < x || ss.b < y || ss.x > cropRight || ss.y > cropBottom);\n\n      if (intersects) {\n        var ix = Math.max(ss.x, x);\n        var iy = Math.max(ss.y, y);\n        var iw = Math.min(ss.r, cropRight) - ix;\n        var ih = Math.min(ss.b, cropBottom) - iy;\n        ow = iw;\n        oh = ih;\n\n        if (flipX) {\n          ox = cx + (cw - (ix - ss.x) - iw);\n        } else {\n          ox = cx + (ix - ss.x);\n        }\n\n        if (flipY) {\n          oy = cy + (ch - (iy - ss.y) - ih);\n        } else {\n          oy = cy + (iy - ss.y);\n        }\n\n        x = ix;\n        y = iy;\n        width = iw;\n        height = ih;\n      } else {\n        ox = 0;\n        oy = 0;\n        ow = 0;\n        oh = 0;\n      }\n    } else {\n      if (flipX) {\n        ox = cx + (cw - x - width);\n      }\n\n      if (flipY) {\n        oy = cy + (ch - y - height);\n      }\n    }\n\n    var tw = this.source.width;\n    var th = this.source.height; //  Map the given coordinates into UV space, clamping to the 0-1 range.\n\n    crop.u0 = Math.max(0, ox / tw);\n    crop.v0 = Math.max(0, oy / th);\n    crop.u1 = Math.min(1, (ox + ow) / tw);\n    crop.v1 = Math.min(1, (oy + oh) / th);\n    crop.x = x;\n    crop.y = y;\n    crop.cx = ox;\n    crop.cy = oy;\n    crop.cw = ow;\n    crop.ch = oh;\n    crop.width = width;\n    crop.height = height;\n    crop.flipX = flipX;\n    crop.flipY = flipY;\n    return crop;\n  },\n\n  /**\r\n   * Takes a crop data object and recalculates the UVs based on the dimensions inside the crop object.\r\n   * Called automatically by `setFrame`.\r\n   *\r\n   * @method Phaser.Textures.Frame#updateCropUVs\r\n   * @since 3.11.0\r\n   * \r\n   * @param {object} crop - The crop data object. This is the `GameObject._crop` property.\r\n   * @param {boolean} flipX - Does the parent Game Object have flipX set?\r\n   * @param {boolean} flipY - Does the parent Game Object have flipY set?\r\n   *\r\n   * @return {object} The updated crop data object.\r\n   */\n  updateCropUVs: function updateCropUVs(crop, flipX, flipY) {\n    return this.setCropUVs(crop, crop.x, crop.y, crop.width, crop.height, flipX, flipY);\n  },\n\n  /**\r\n   * Updates the internal WebGL UV cache and the drawImage cache.\r\n   *\r\n   * @method Phaser.Textures.Frame#updateUVs\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Textures.Frame} This Frame object.\r\n   */\n  updateUVs: function updateUVs() {\n    var cx = this.cutX;\n    var cy = this.cutY;\n    var cw = this.cutWidth;\n    var ch = this.cutHeight; //  Canvas data\n\n    var cd = this.data.drawImage;\n    cd.width = cw;\n    cd.height = ch; //  WebGL data\n\n    var tw = this.source.width;\n    var th = this.source.height;\n    this.u0 = cx / tw;\n    this.v0 = cy / th;\n    this.u1 = (cx + cw) / tw;\n    this.v1 = (cy + ch) / th;\n    return this;\n  },\n\n  /**\r\n   * Updates the internal WebGL UV cache.\r\n   *\r\n   * @method Phaser.Textures.Frame#updateUVsInverted\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Textures.Frame} This Frame object.\r\n   */\n  updateUVsInverted: function updateUVsInverted() {\n    var tw = this.source.width;\n    var th = this.source.height;\n    this.u0 = (this.cutX + this.cutHeight) / tw;\n    this.v0 = this.cutY / th;\n    this.u1 = this.cutX / tw;\n    this.v1 = (this.cutY + this.cutWidth) / th;\n    return this;\n  },\n\n  /**\r\n   * Clones this Frame into a new Frame object.\r\n   *\r\n   * @method Phaser.Textures.Frame#clone\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Textures.Frame} A clone of this Frame.\r\n   */\n  clone: function clone() {\n    var clone = new Frame(this.texture, this.name, this.sourceIndex);\n    clone.cutX = this.cutX;\n    clone.cutY = this.cutY;\n    clone.cutWidth = this.cutWidth;\n    clone.cutHeight = this.cutHeight;\n    clone.x = this.x;\n    clone.y = this.y;\n    clone.width = this.width;\n    clone.height = this.height;\n    clone.halfWidth = this.halfWidth;\n    clone.halfHeight = this.halfHeight;\n    clone.centerX = this.centerX;\n    clone.centerY = this.centerY;\n    clone.rotated = this.rotated;\n    clone.data = Extend(true, clone.data, this.data);\n    clone.updateUVs();\n    return clone;\n  },\n\n  /**\r\n   * Destroys this Frames references.\r\n   *\r\n   * @method Phaser.Textures.Frame#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    this.texture = null;\n    this.source = null;\n  },\n\n  /**\r\n   * The width of the Frame in its un-trimmed, un-padded state, as prepared in the art package,\r\n   * before being packed.\r\n   *\r\n   * @name Phaser.Textures.Frame#realWidth\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  realWidth: {\n    get: function get() {\n      return this.data.sourceSize.w;\n    }\n  },\n\n  /**\r\n   * The height of the Frame in its un-trimmed, un-padded state, as prepared in the art package,\r\n   * before being packed.\r\n   *\r\n   * @name Phaser.Textures.Frame#realHeight\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  realHeight: {\n    get: function get() {\n      return this.data.sourceSize.h;\n    }\n  },\n\n  /**\r\n   * The radius of the Frame (derived from sqrt(w * w + h * h) / 2)\r\n   *\r\n   * @name Phaser.Textures.Frame#radius\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  radius: {\n    get: function get() {\n      return this.data.radius;\n    }\n  },\n\n  /**\r\n   * Is the Frame trimmed or not?\r\n   *\r\n   * @name Phaser.Textures.Frame#trimmed\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  trimmed: {\n    get: function get() {\n      return this.data.trim;\n    }\n  },\n\n  /**\r\n   * The Canvas drawImage data object.\r\n   *\r\n   * @name Phaser.Textures.Frame#canvasData\r\n   * @type {object}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  canvasData: {\n    get: function get() {\n      return this.data.drawImage;\n    }\n  }\n});\nmodule.exports = Frame;","map":null,"metadata":{},"sourceType":"script"}