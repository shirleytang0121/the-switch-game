{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../utils/Class');\n/**\r\n * @callback EachMapCallback<E>\r\n *\r\n * @param {string} key - The key of the Map entry.\r\n * @param {E} entry - The value of the Map entry.\r\n *\r\n * @return {?boolean} The callback result.\r\n */\n\n/**\r\n * @classdesc\r\n * The keys of a Map can be arbitrary values.\r\n * \r\n * ```javascript\r\n * var map = new Map([\r\n *    [ 1, 'one' ],\r\n *    [ 2, 'two' ],\r\n *    [ 3, 'three' ]\r\n * ]);\r\n * ```\r\n *\r\n * @class Map\r\n * @memberof Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @generic K\r\n * @generic V\r\n * @genericUse {V[]} - [elements]\r\n *\r\n * @param {Array.<*>} elements - An optional array of key-value pairs to populate this Map with.\r\n */\n\n\nvar Map = new Class({\n  initialize: function Map(elements) {\n    /**\r\n     * The entries in this Map.\r\n     *\r\n     * @genericUse {Object.<string, V>} - [$type]\r\n     *\r\n     * @name Phaser.Structs.Map#entries\r\n     * @type {Object.<string, *>}\r\n     * @default {}\r\n     * @since 3.0.0\r\n     */\n    this.entries = {};\n    /**\r\n     * The number of key / value pairs in this Map.\r\n     *\r\n     * @name Phaser.Structs.Map#size\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.size = 0;\n\n    if (Array.isArray(elements)) {\n      for (var i = 0; i < elements.length; i++) {\n        this.set(elements[i][0], elements[i][1]);\n      }\n    }\n  },\n\n  /**\r\n   * Adds an element with a specified `key` and `value` to this Map.\r\n   * If the `key` already exists, the value will be replaced.\r\n   *\r\n   * @method Phaser.Structs.Map#set\r\n   * @since 3.0.0\r\n   *\r\n   * @genericUse {K} - [key]\r\n   * @genericUse {V} - [value]\r\n   * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n   *\r\n   * @param {string} key - The key of the element to be added to this Map.\r\n   * @param {*} value - The value of the element to be added to this Map.\r\n   *\r\n   * @return {Phaser.Structs.Map} This Map object.\r\n   */\n  set: function set(key, value) {\n    if (!this.has(key)) {\n      this.size++;\n    }\n\n    this.entries[key] = value;\n    return this;\n  },\n\n  /**\r\n   * Returns the value associated to the `key`, or `undefined` if there is none.\r\n   *\r\n   * @method Phaser.Structs.Map#get\r\n   * @since 3.0.0\r\n   *\r\n   * @genericUse {K} - [key]\r\n   * @genericUse {V} - [$return]\r\n   *\r\n   * @param {string} key - The key of the element to return from the `Map` object.\r\n   *\r\n   * @return {*} The element associated with the specified key or `undefined` if the key can't be found in this Map object.\r\n   */\n  get: function get(key) {\n    if (this.has(key)) {\n      return this.entries[key];\n    }\n  },\n\n  /**\r\n   * Returns an `Array` of all the values stored in this Map.\r\n   *\r\n   * @method Phaser.Structs.Map#getArray\r\n   * @since 3.0.0\r\n   *\r\n   * @genericUse {V[]} - [$return]\r\n   *\r\n   * @return {Array.<*>} An array of the values stored in this Map.\r\n   */\n  getArray: function getArray() {\n    var output = [];\n    var entries = this.entries;\n\n    for (var key in entries) {\n      output.push(entries[key]);\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Returns a boolean indicating whether an element with the specified key exists or not.\r\n   *\r\n   * @method Phaser.Structs.Map#has\r\n   * @since 3.0.0\r\n   *\r\n   * @genericUse {K} - [key]\r\n   *\r\n   * @param {string} key - The key of the element to test for presence of in this Map.\r\n   *\r\n   * @return {boolean} Returns `true` if an element with the specified key exists in this Map, otherwise `false`.\r\n   */\n  has: function has(key) {\n    return this.entries.hasOwnProperty(key);\n  },\n\n  /**\r\n   * Delete the specified element from this Map.\r\n   *\r\n   * @method Phaser.Structs.Map#delete\r\n   * @since 3.0.0\r\n   *\r\n   * @genericUse {K} - [key]\r\n   * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n   *\r\n   * @param {string} key - The key of the element to delete from this Map.\r\n   *\r\n   * @return {Phaser.Structs.Map} This Map object.\r\n   */\n  delete: function _delete(key) {\n    if (this.has(key)) {\n      delete this.entries[key];\n      this.size--;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Delete all entries from this Map.\r\n   *\r\n   * @method Phaser.Structs.Map#clear\r\n   * @since 3.0.0\r\n   *\r\n   * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n   *\r\n   * @return {Phaser.Structs.Map} This Map object.\r\n   */\n  clear: function clear() {\n    Object.keys(this.entries).forEach(function (prop) {\n      delete this.entries[prop];\n    }, this);\n    this.size = 0;\n    return this;\n  },\n\n  /**\r\n   * Returns all entries keys in this Map.\r\n   *\r\n   * @method Phaser.Structs.Map#keys\r\n   * @since 3.0.0\r\n   *\r\n   * @genericUse {K[]} - [$return]\r\n   *\r\n   * @return {string[]} Array containing entries' keys.\r\n   */\n  keys: function keys() {\n    return Object.keys(this.entries);\n  },\n\n  /**\r\n   * Returns an `Array` of all entries.\r\n   *\r\n   * @method Phaser.Structs.Map#values\r\n   * @since 3.0.0\r\n   *\r\n   * @genericUse {V[]} - [$return]\r\n   *\r\n   * @return {Array.<*>} An `Array` of entries.\r\n   */\n  values: function values() {\n    var output = [];\n    var entries = this.entries;\n\n    for (var key in entries) {\n      output.push(entries[key]);\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Dumps the contents of this Map to the console via `console.group`.\r\n   *\r\n   * @method Phaser.Structs.Map#dump\r\n   * @since 3.0.0\r\n   */\n  dump: function dump() {\n    var entries = this.entries; // eslint-disable-next-line no-console\n\n    console.group('Map');\n\n    for (var key in entries) {\n      console.log(key, entries[key]);\n    } // eslint-disable-next-line no-console\n\n\n    console.groupEnd();\n  },\n\n  /**\r\n   * Passes all entries in this Map to the given callback.\r\n   *\r\n   * @method Phaser.Structs.Map#each\r\n   * @since 3.0.0\r\n   *\r\n   * @genericUse {EachMapCallback.<V>} - [callback]\r\n   * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n   *\r\n   * @param {EachMapCallback} callback - The callback which will receive the keys and entries held in this Map.\r\n   *\r\n   * @return {Phaser.Structs.Map} This Map object.\r\n   */\n  each: function each(callback) {\n    var entries = this.entries;\n\n    for (var key in entries) {\n      if (callback(key, entries[key]) === false) {\n        break;\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Returns `true` if the value exists within this Map. Otherwise, returns `false`.\r\n   *\r\n   * @method Phaser.Structs.Map#contains\r\n   * @since 3.0.0\r\n   *\r\n   * @genericUse {V} - [value]\r\n   *\r\n   * @param {*} value - The value to search for.\r\n   *\r\n   * @return {boolean} `true` if the value is found, otherwise `false`.\r\n   */\n  contains: function contains(value) {\n    var entries = this.entries;\n\n    for (var key in entries) {\n      if (entries[key] === value) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Merges all new keys from the given Map into this one.\r\n   * If it encounters a key that already exists it will be skipped unless override is set to `true`.\r\n   *\r\n   * @method Phaser.Structs.Map#merge\r\n   * @since 3.0.0\r\n   *\r\n   * @genericUse {Phaser.Structs.Map.<K, V>} - [map,$return]\r\n   *\r\n   * @param {Phaser.Structs.Map} map - The Map to merge in to this Map.\r\n   * @param {boolean} [override=false] - Set to `true` to replace values in this Map with those from the source map, or `false` to skip them.\r\n   *\r\n   * @return {Phaser.Structs.Map} This Map object.\r\n   */\n  merge: function merge(map, override) {\n    if (override === undefined) {\n      override = false;\n    }\n\n    var local = this.entries;\n    var source = map.entries;\n\n    for (var key in source) {\n      if (local.hasOwnProperty(key) && override) {\n        local[key] = source[key];\n      } else {\n        this.set(key, source[key]);\n      }\n    }\n\n    return this;\n  }\n});\nmodule.exports = Map;","map":null,"metadata":{},"sourceType":"script"}