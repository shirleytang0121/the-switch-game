{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar CircleContains = require('../../geom/circle/Contains');\n\nvar Class = require('../../utils/Class');\n\nvar CONST = require('./const');\n\nvar Events = require('./events');\n\nvar RadToDeg = require('../../math/RadToDeg');\n\nvar Rectangle = require('../../geom/rectangle/Rectangle');\n\nvar RectangleContains = require('../../geom/rectangle/Contains');\n\nvar Vector2 = require('../../math/Vector2');\n/**\r\n * @typedef {object} ArcadeBodyBounds\r\n *\r\n * @property {number} x - The left edge.\r\n * @property {number} y - The upper edge.\r\n * @property {number} right - The right edge.\r\n * @property {number} bottom - The lower edge.\r\n */\n\n/**\r\n * @typedef {object} ArcadeBodyCollision\r\n *\r\n * @property {boolean} none - True if the Body is not colliding.\r\n * @property {boolean} up - True if the Body is colliding on its upper edge.\r\n * @property {boolean} down - True if the Body is colliding on its lower edge.\r\n * @property {boolean} left - True if the Body is colliding on its left edge.\r\n * @property {boolean} right - True if the Body is colliding on its right edge.\r\n */\n\n/**\r\n * @classdesc\r\n * A Dynamic Arcade Body.\r\n *\r\n * Its static counterpart is {@link Phaser.Physics.Arcade.StaticBody}.\r\n *\r\n * @class Body\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - The Arcade Physics simulation this Body belongs to.\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object this Body belongs to.\r\n */\n\n\nvar Body = new Class({\n  initialize: function Body(world, gameObject) {\n    var width = gameObject.width ? gameObject.width : 64;\n    var height = gameObject.height ? gameObject.height : 64;\n    /**\r\n     * The Arcade Physics simulation this Body belongs to.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#world\r\n     * @type {Phaser.Physics.Arcade.World}\r\n     * @since 3.0.0\r\n     */\n\n    this.world = world;\n    /**\r\n     * The Game Object this Body belongs to.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#gameObject\r\n     * @type {Phaser.GameObjects.GameObject}\r\n     * @since 3.0.0\r\n     */\n\n    this.gameObject = gameObject;\n    /**\r\n     * Transformations applied to this Body.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#transform\r\n     * @type {object}\r\n     * @since 3.4.0\r\n     */\n\n    this.transform = {\n      x: gameObject.x,\n      y: gameObject.y,\n      rotation: gameObject.angle,\n      scaleX: gameObject.scaleX,\n      scaleY: gameObject.scaleY,\n      displayOriginX: gameObject.displayOriginX,\n      displayOriginY: gameObject.displayOriginY\n    };\n    /**\r\n     * Whether the Body's boundary is drawn to the debug display.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#debugShowBody\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.debugShowBody = world.defaults.debugShowBody;\n    /**\r\n     * Whether the Body's velocity is drawn to the debug display.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#debugShowVelocity\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.debugShowVelocity = world.defaults.debugShowVelocity;\n    /**\r\n     * The color of this Body on the debug display.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#debugBodyColor\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.debugBodyColor = world.defaults.bodyDebugColor;\n    /**\r\n     * Whether this Body is updated by the physics simulation.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#enable\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.enable = true;\n    /**\r\n     * Whether this Body's boundary is circular (true) or rectangular (false).\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#isCircle\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#setCircle\r\n     */\n\n    this.isCircle = false;\n    /**\r\n     * If this Body is circular, this is the unscaled radius of the Body's boundary, as set by setCircle(), in source pixels.\r\n     * The true radius is equal to `halfWidth`.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#radius\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#setCircle\r\n     */\n\n    this.radius = 0;\n    /**\r\n     * The offset of this Body's position from its Game Object's position, in source pixels.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#offset\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#setOffset\r\n     */\n\n    this.offset = new Vector2();\n    /**\r\n     * The position of this Body within the simulation.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#position\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.position = new Vector2(gameObject.x, gameObject.y);\n    /**\r\n     * The position of this Body during the previous step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#prev\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.prev = new Vector2(gameObject.x, gameObject.y);\n    /**\r\n     * Whether this Body's `rotation` is affected by its angular acceleration and angular velocity.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#allowRotation\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.allowRotation = true;\n    /**\r\n     * This body's rotation, in degrees, based on its angular acceleration and angular velocity.\r\n     * The Body's rotation controls the `angle` of its Game Object.\r\n     * It doesn't rotate the Body's boundary, which is always an axis-aligned rectangle or a circle.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#rotation\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.rotation = gameObject.angle;\n    /**\r\n     * The Body's rotation, in degrees, during the previous step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#preRotation\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.preRotation = gameObject.angle;\n    /**\r\n     * The width of the Body's boundary, in pixels.\r\n     * If the Body is circular, this is also the Body's diameter.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#width\r\n     * @type {number}\r\n     * @default 64\r\n     * @since 3.0.0\r\n     */\n\n    this.width = width;\n    /**\r\n     * The height of the Body's boundary, in pixels.\r\n     * If the Body is circular, this is also the Body's diameter.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#height\r\n     * @type {number}\r\n     * @default 64\r\n     * @since 3.0.0\r\n     */\n\n    this.height = height;\n    /**\r\n     * The unscaled width of the Body, in source pixels, as set by setSize().\r\n     * The default is the width of the Body's Game Object's texture frame.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#sourceWidth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#setSize\r\n     */\n\n    this.sourceWidth = width;\n    /**\r\n     * The unscaled height of the Body, in source pixels, as set by setSize().\r\n     * The default is the height of the Body's Game Object's texture frame.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#sourceHeight\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#setSize\r\n     */\n\n    this.sourceHeight = height;\n\n    if (gameObject.frame) {\n      this.sourceWidth = gameObject.frame.realWidth;\n      this.sourceHeight = gameObject.frame.realHeight;\n    }\n    /**\r\n     * Half the Body's width, in pixels.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#halfWidth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.halfWidth = Math.abs(width / 2);\n    /**\r\n     * Half the Body's height, in pixels.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#halfHeight\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.halfHeight = Math.abs(height / 2);\n    /**\r\n     * The center of the Body's boundary.\r\n     * The midpoint of its `position` (top-left corner) and its bottom-right corner.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#center\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.center = new Vector2(gameObject.x + this.halfWidth, gameObject.y + this.halfHeight);\n    /**\r\n     * The Body's velocity, in pixels per second.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#velocity\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.velocity = new Vector2();\n    /**\r\n     * The Body's calculated velocity, in pixels per second, at the last step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#newVelocity\r\n     * @type {Phaser.Math.Vector2}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\n\n    this.newVelocity = new Vector2();\n    /**\r\n     * The Body's absolute maximum change in position, in pixels per step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#deltaMax\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.deltaMax = new Vector2();\n    /**\r\n     * The Body's change in velocity, in pixels per second squared.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#acceleration\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.acceleration = new Vector2();\n    /**\r\n     * Whether this Body's velocity is affected by its `drag`.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#allowDrag\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.allowDrag = true;\n    /**\r\n     * Absolute loss of velocity due to movement, in pixels per second squared.\r\n     * The x and y components are applied separately.\r\n     *\r\n     * When `useDamping` is true, this is 1 minus the damping factor.\r\n     * A value of 1 means the Body loses no velocity.\r\n     * A value of 0.95 means the Body loses 5% of its velocity per step.\r\n     * A value of 0.5 means the Body loses 50% of its velocity per step.\r\n     *\r\n     * Drag is applied only when `acceleration` is zero.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#drag\r\n     * @type {(Phaser.Math.Vector2|number)}\r\n     * @since 3.0.0\r\n     */\n\n    this.drag = new Vector2();\n    /**\r\n     * Whether this Body's position is affected by gravity (local or world).\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#allowGravity\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#gravity\r\n     * @see Phaser.Physics.Arcade.World#gravity\r\n     */\n\n    this.allowGravity = true;\n    /**\r\n     * Acceleration due to gravity (specific to this Body), in pixels per second squared.\r\n     * Total gravity is the sum of this vector and the simulation's `gravity`.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#gravity\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.World#gravity\r\n     */\n\n    this.gravity = new Vector2();\n    /**\r\n     * Rebound following a collision, relative to 1.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#bounce\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.bounce = new Vector2();\n    /**\r\n     * Rebound following a collision with the world boundary, relative to 1.\r\n     * If null, `bounce` is used instead.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#worldBounce\r\n     * @type {?Phaser.Math.Vector2}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.worldBounce = null; //  If true this Body will dispatch events\n\n    /**\r\n     * Whether the simulation emits a `worldbounds` event when this Body collides with the world boundary (and `collideWorldBounds` is also true).\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#onWorldBounds\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.World#worldboundsEvent\r\n     */\n\n    this.onWorldBounds = false;\n    /**\r\n     * Whether the simulation emits a `collide` event when this Body collides with another.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#onCollide\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.World#collideEvent\r\n     */\n\n    this.onCollide = false;\n    /**\r\n     * Whether the simulation emits an `overlap` event when this Body overlaps with another.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#onOverlap\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.World#overlapEvent\r\n     */\n\n    this.onOverlap = false;\n    /**\r\n     * The Body's absolute maximum velocity, in pixels per second.\r\n     * The horizontal and vertical components are applied separately.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#maxVelocity\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.maxVelocity = new Vector2(10000, 10000);\n    /**\r\n     * The maximum speed this Body is allowed to reach.\r\n     * \r\n     * If not negative it limits the scalar value of speed.\r\n     * \r\n     * Any negative value means no maximum is being applied.\r\n     * \r\n     * @name Phaser.Physics.Arcade.Body#maxSpeed\r\n     * @type {number}\r\n     * @since 3.16.0 \r\n     */\n\n    this.maxSpeed = -1;\n    /**\r\n     * If this Body is `immovable` and in motion, `friction` is the proportion of this Body's motion received by the riding Body on each axis, relative to 1.\r\n     * The default value (1, 0) moves the riding Body horizontally in equal proportion to this Body and vertically not at all.\r\n     * The horizontal component (x) is applied only when two colliding Bodies are separated vertically.\r\n     * The vertical component (y) is applied only when two colliding Bodies are separated horizontally.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#friction\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.friction = new Vector2(1, 0);\n    /**\r\n     * If this Body is using `drag` for deceleration this property controls how the drag is applied.\r\n     * If set to `true` drag will use a damping effect rather than a linear approach. If you are\r\n     * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in\r\n     * the game Asteroids) then you will get a far smoother and more visually correct deceleration\r\n     * by using damping, avoiding the axis-drift that is prone with linear deceleration.\r\n     *\r\n     * If you enable this property then you should use far smaller `drag` values than with linear, as\r\n     * they are used as a multiplier on the velocity. Values such as 0.95 will give a nice slow\r\n     * deceleration, where-as smaller values, such as 0.5 will stop an object almost immediately.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#useDamping\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.10.0\r\n     */\n\n    this.useDamping = false;\n    /**\r\n     * The rate of change of this Body's `rotation`, in degrees per second.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#angularVelocity\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.angularVelocity = 0;\n    /**\r\n     * The Body's angular acceleration (change in angular velocity), in degrees per second squared.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#angularAcceleration\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.angularAcceleration = 0;\n    /**\r\n     * Loss of angular velocity due to angular movement, in degrees per second.\r\n     *\r\n     * Angular drag is applied only when angular acceleration is zero.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#angularDrag\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.angularDrag = 0;\n    /**\r\n     * The Body's maximum angular velocity, in degrees per second.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#maxAngular\r\n     * @type {number}\r\n     * @default 1000\r\n     * @since 3.0.0\r\n     */\n\n    this.maxAngular = 1000;\n    /**\r\n     * The Body's inertia, relative to a default unit (1).\r\n     * With `bounce`, this affects the exchange of momentum (velocities) during collisions.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#mass\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\n\n    this.mass = 1;\n    /**\r\n     * The calculated angle of this Body's velocity vector, in degrees, during the last step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#angle\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.angle = 0;\n    /**\r\n     * The calculated magnitude of the Body's velocity, in pixels per second, during the last step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#speed\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.speed = 0;\n    /**\r\n     * The direction of the Body's velocity, as calculated during the last step.\r\n     * If the Body is moving on both axes (diagonally), this describes motion on the vertical axis only.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#facing\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.facing = CONST.FACING_NONE;\n    /**\r\n     * Whether this Body can be moved by collisions with another Body.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#immovable\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.immovable = false;\n    /**\r\n     * Whether the Body's position and rotation are affected by its velocity, acceleration, drag, and gravity.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#moves\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.moves = true;\n    /**\r\n     * A flag disabling the default horizontal separation of colliding bodies.\r\n     * Pass your own `collideCallback` to the collider.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#customSeparateX\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.customSeparateX = false;\n    /**\r\n     * A flag disabling the default vertical separation of colliding bodies.\r\n     * Pass your own `collideCallback` to the collider.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#customSeparateY\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.customSeparateY = false;\n    /**\r\n     * The amount of horizontal overlap (before separation), if this Body is colliding with another.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#overlapX\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.overlapX = 0;\n    /**\r\n     * The amount of vertical overlap (before separation), if this Body is colliding with another.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#overlapY\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.overlapY = 0;\n    /**\r\n     * The amount of overlap (before separation), if this Body is circular and colliding with another circular body.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#overlapR\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.overlapR = 0;\n    /**\r\n     * Whether this Body is overlapped with another and both are not moving.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#embedded\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.embedded = false;\n    /**\r\n     * Whether this Body interacts with the world boundary.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#collideWorldBounds\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.collideWorldBounds = false;\n    /**\r\n     * Whether this Body is checked for collisions and for which directions.\r\n     * You can set `checkCollision.none = true` to disable collision checks.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#checkCollision\r\n     * @type {ArcadeBodyCollision}\r\n     * @since 3.0.0\r\n     */\n\n    this.checkCollision = {\n      none: false,\n      up: true,\n      down: true,\n      left: true,\n      right: true\n    };\n    /**\r\n     * Whether this Body is colliding with another and in which direction.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#touching\r\n     * @type {ArcadeBodyCollision}\r\n     * @since 3.0.0\r\n     */\n\n    this.touching = {\n      none: true,\n      up: false,\n      down: false,\n      left: false,\n      right: false\n    };\n    /**\r\n     * Whether this Body was colliding with another during the last step, and in which direction.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#wasTouching\r\n     * @type {ArcadeBodyCollision}\r\n     * @since 3.0.0\r\n     */\n\n    this.wasTouching = {\n      none: true,\n      up: false,\n      down: false,\n      left: false,\n      right: false\n    };\n    /**\r\n     * Whether this Body is colliding with a tile or the world boundary.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#blocked\r\n     * @type {ArcadeBodyCollision}\r\n     * @since 3.0.0\r\n     */\n\n    this.blocked = {\n      none: true,\n      up: false,\n      down: false,\n      left: false,\n      right: false\n    };\n    /**\r\n     * Whether to automatically synchronize this Body's dimensions to the dimensions of its Game Object's visual bounds.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#syncBounds\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     * @see Phaser.GameObjects.Components.GetBounds#getBounds\r\n     */\n\n    this.syncBounds = false;\n    /**\r\n     * Whether this Body is being moved by the `moveTo` or `moveFrom` methods.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#isMoving\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.isMoving = false;\n    /**\r\n     * Whether this Body's movement by `moveTo` or `moveFrom` will be stopped by collisions with other bodies.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#stopVelocityOnCollide\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.stopVelocityOnCollide = true; //  read-only\n\n    /**\r\n     * The Body's physics type (dynamic or static).\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#physicsType\r\n     * @type {integer}\r\n     * @readonly\r\n     * @default Phaser.Physics.Arcade.DYNAMIC_BODY\r\n     * @since 3.0.0\r\n     */\n\n    this.physicsType = CONST.DYNAMIC_BODY;\n    /**\r\n     * Whether the Body's position needs updating from its Game Object.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#_reset\r\n     * @type {boolean}\r\n     * @private\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this._reset = true;\n    /**\r\n     * Cached horizontal scale of the Body's Game Object.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#_sx\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._sx = gameObject.scaleX;\n    /**\r\n     * Cached vertical scale of the Body's Game Object.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#_sy\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._sy = gameObject.scaleY;\n    /**\r\n     * The calculated change in the Body's horizontal position during the last step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#_dx\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this._dx = 0;\n    /**\r\n     * The calculated change in the Body's vertical position during the last step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#_dy\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this._dy = 0;\n    /**\r\n     * Stores the Game Object's bounds.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#_bounds\r\n     * @type {Phaser.Geom.Rectangle}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._bounds = new Rectangle();\n  },\n\n  /**\r\n   * Updates the Body's `transform`, `width`, `height`, and `center` from its Game Object.\r\n   * The Body's `position` isn't changed.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#updateBounds\r\n   * @since 3.0.0\r\n   */\n  updateBounds: function updateBounds() {\n    var sprite = this.gameObject; //  Container?\n\n    var transform = this.transform;\n\n    if (sprite.parentContainer) {\n      var matrix = sprite.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2);\n      transform.x = matrix.tx;\n      transform.y = matrix.ty;\n      transform.rotation = RadToDeg(matrix.rotation);\n      transform.scaleX = matrix.scaleX;\n      transform.scaleY = matrix.scaleY;\n      transform.displayOriginX = sprite.displayOriginX;\n      transform.displayOriginY = sprite.displayOriginY;\n    } else {\n      transform.x = sprite.x;\n      transform.y = sprite.y;\n      transform.rotation = sprite.angle;\n      transform.scaleX = sprite.scaleX;\n      transform.scaleY = sprite.scaleY;\n      transform.displayOriginX = sprite.displayOriginX;\n      transform.displayOriginY = sprite.displayOriginY;\n    }\n\n    var recalc = false;\n\n    if (this.syncBounds) {\n      var b = sprite.getBounds(this._bounds);\n      this.width = b.width;\n      this.height = b.height;\n      recalc = true;\n    } else {\n      var asx = Math.abs(transform.scaleX);\n      var asy = Math.abs(transform.scaleY);\n\n      if (this._sx !== asx || this._sy !== asy) {\n        this.width = this.sourceWidth * asx;\n        this.height = this.sourceHeight * asy;\n        this._sx = asx;\n        this._sy = asy;\n        recalc = true;\n      }\n    }\n\n    if (recalc) {\n      this.halfWidth = Math.floor(this.width / 2);\n      this.halfHeight = Math.floor(this.height / 2);\n      this.updateCenter();\n    }\n  },\n\n  /**\r\n   * Updates the Body's `center` from its `position`, `width`, and `height`.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#updateCenter\r\n   * @since 3.0.0\r\n   */\n  updateCenter: function updateCenter() {\n    this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\n  },\n\n  /**\r\n   * Updates the Body.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#update\r\n   * @fires Phaser.Physics.Arcade.World#worldbounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} delta - The delta time, in seconds, elapsed since the last frame.\r\n   */\n  update: function update(delta) {\n    //  Store and reset collision flags\n    this.wasTouching.none = this.touching.none;\n    this.wasTouching.up = this.touching.up;\n    this.wasTouching.down = this.touching.down;\n    this.wasTouching.left = this.touching.left;\n    this.wasTouching.right = this.touching.right;\n    this.touching.none = true;\n    this.touching.up = false;\n    this.touching.down = false;\n    this.touching.left = false;\n    this.touching.right = false;\n    this.blocked.none = true;\n    this.blocked.up = false;\n    this.blocked.down = false;\n    this.blocked.left = false;\n    this.blocked.right = false;\n    this.overlapR = 0;\n    this.overlapX = 0;\n    this.overlapY = 0;\n    this.embedded = false; //  Updates the transform values\n\n    this.updateBounds();\n    var sprite = this.transform;\n    this.position.x = sprite.x + sprite.scaleX * (this.offset.x - sprite.displayOriginX);\n    this.position.y = sprite.y + sprite.scaleY * (this.offset.y - sprite.displayOriginY);\n    this.updateCenter();\n    this.rotation = sprite.rotation;\n    this.preRotation = this.rotation;\n\n    if (this._reset) {\n      this.prev.x = this.position.x;\n      this.prev.y = this.position.y;\n    }\n\n    if (this.moves) {\n      this.world.updateMotion(this, delta);\n      var vx = this.velocity.x;\n      var vy = this.velocity.y;\n      this.newVelocity.set(vx * delta, vy * delta);\n      this.position.add(this.newVelocity);\n      this.updateCenter();\n      this.angle = Math.atan2(vy, vx);\n      this.speed = Math.sqrt(vx * vx + vy * vy); //  Now the State update will throw collision checks at the Body\n      //  And finally we'll integrate the new position back to the Sprite in postUpdate\n\n      if (this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds) {\n        this.world.emit(Events.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right);\n      }\n    }\n\n    this._dx = this.position.x - this.prev.x;\n    this._dy = this.position.y - this.prev.y;\n  },\n\n  /**\r\n   * Feeds the Body results back into the parent Game Object.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#postUpdate\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} resetDelta - Reset the delta properties?\r\n   */\n  postUpdate: function postUpdate() {\n    this._dx = this.position.x - this.prev.x;\n    this._dy = this.position.y - this.prev.y;\n\n    if (this.moves) {\n      if (this.deltaMax.x !== 0 && this._dx !== 0) {\n        if (this._dx < 0 && this._dx < -this.deltaMax.x) {\n          this._dx = -this.deltaMax.x;\n        } else if (this._dx > 0 && this._dx > this.deltaMax.x) {\n          this._dx = this.deltaMax.x;\n        }\n      }\n\n      if (this.deltaMax.y !== 0 && this._dy !== 0) {\n        if (this._dy < 0 && this._dy < -this.deltaMax.y) {\n          this._dy = -this.deltaMax.y;\n        } else if (this._dy > 0 && this._dy > this.deltaMax.y) {\n          this._dy = this.deltaMax.y;\n        }\n      }\n\n      this.gameObject.x += this._dx;\n      this.gameObject.y += this._dy;\n      this._reset = true;\n    }\n\n    if (this._dx < 0) {\n      this.facing = CONST.FACING_LEFT;\n    } else if (this._dx > 0) {\n      this.facing = CONST.FACING_RIGHT;\n    }\n\n    if (this._dy < 0) {\n      this.facing = CONST.FACING_UP;\n    } else if (this._dy > 0) {\n      this.facing = CONST.FACING_DOWN;\n    }\n\n    if (this.allowRotation) {\n      this.gameObject.angle += this.deltaZ();\n    }\n\n    this.prev.x = this.position.x;\n    this.prev.y = this.position.y;\n  },\n\n  /**\r\n   * Checks for collisions between this Body and the world boundary and separates them.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#checkWorldBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} True if this Body is colliding with the world boundary.\r\n   */\n  checkWorldBounds: function checkWorldBounds() {\n    var pos = this.position;\n    var bounds = this.world.bounds;\n    var check = this.world.checkCollision;\n    var bx = this.worldBounce ? -this.worldBounce.x : -this.bounce.x;\n    var by = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;\n\n    if (pos.x < bounds.x && check.left) {\n      pos.x = bounds.x;\n      this.velocity.x *= bx;\n      this.blocked.left = true;\n      this.blocked.none = false;\n    } else if (this.right > bounds.right && check.right) {\n      pos.x = bounds.right - this.width;\n      this.velocity.x *= bx;\n      this.blocked.right = true;\n      this.blocked.none = false;\n    }\n\n    if (pos.y < bounds.y && check.up) {\n      pos.y = bounds.y;\n      this.velocity.y *= by;\n      this.blocked.up = true;\n      this.blocked.none = false;\n    } else if (this.bottom > bounds.bottom && check.down) {\n      pos.y = bounds.bottom - this.height;\n      this.velocity.y *= by;\n      this.blocked.down = true;\n      this.blocked.none = false;\n    }\n\n    return !this.blocked.none;\n  },\n\n  /**\r\n   * Sets the offset of the Body's position from its Game Object's position.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setOffset\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal offset, in source pixels.\r\n   * @param {number} [y=x] - The vertical offset, in source pixels.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setOffset: function setOffset(x, y) {\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.offset.set(x, y);\n    return this;\n  },\n\n  /**\r\n   * Sizes and positions this Body's boundary, as a rectangle.\r\n   * Modifies the Body `offset` if `center` is true (the default).\r\n   * Resets the width and height to match current frame, if no width and height provided and a frame is found.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setSize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} [width] - The width of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame width.\r\n   * @param {integer} [height] - The height of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame height.\r\n   * @param {boolean} [center=true] - Modify the Body's `offset`, placing the Body's center on its Game Object's center. Only works if the Game Object has the `getCenter` method.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setSize: function setSize(width, height, center) {\n    if (center === undefined) {\n      center = true;\n    }\n\n    var gameObject = this.gameObject;\n\n    if (!width && gameObject.frame) {\n      width = gameObject.frame.realWidth;\n    }\n\n    if (!height && gameObject.frame) {\n      height = gameObject.frame.realHeight;\n    }\n\n    this.sourceWidth = width;\n    this.sourceHeight = height;\n    this.width = this.sourceWidth * this._sx;\n    this.height = this.sourceHeight * this._sy;\n    this.halfWidth = Math.floor(this.width / 2);\n    this.halfHeight = Math.floor(this.height / 2);\n    this.updateCenter();\n\n    if (center && gameObject.getCenter) {\n      var ox = gameObject.displayWidth / 2;\n      var oy = gameObject.displayHeight / 2;\n      this.offset.set(ox - this.halfWidth, oy - this.halfHeight);\n    }\n\n    this.isCircle = false;\n    this.radius = 0;\n    return this;\n  },\n\n  /**\r\n   * Sizes and positions this Body's boundary, as a circle.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setCircle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} radius - The radius of the Body, in source pixels.\r\n   * @param {number} [offsetX] - The horizontal offset of the Body from its Game Object, in source pixels.\r\n   * @param {number} [offsetY] - The vertical offset of the Body from its Game Object, in source pixels.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setCircle: function setCircle(radius, offsetX, offsetY) {\n    if (offsetX === undefined) {\n      offsetX = this.offset.x;\n    }\n\n    if (offsetY === undefined) {\n      offsetY = this.offset.y;\n    }\n\n    if (radius > 0) {\n      this.isCircle = true;\n      this.radius = radius;\n      this.sourceWidth = radius * 2;\n      this.sourceHeight = radius * 2;\n      this.width = this.sourceWidth * this._sx;\n      this.height = this.sourceHeight * this._sy;\n      this.halfWidth = Math.floor(this.width / 2);\n      this.halfHeight = Math.floor(this.height / 2);\n      this.offset.set(offsetX, offsetY);\n      this.updateCenter();\n    } else {\n      this.isCircle = false;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Resets this Body to the given coordinates. Also positions its parent Game Object to the same coordinates.\r\n   * If the Body had any velocity or acceleration it is lost as a result of calling this.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#reset\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal position to place the Game Object and Body.\r\n   * @param {number} y - The vertical position to place the Game Object and Body.\r\n   */\n  reset: function reset(x, y) {\n    this.stop();\n    var gameObject = this.gameObject;\n    gameObject.setPosition(x, y);\n    gameObject.getTopLeft(this.position);\n    this.prev.copy(this.position);\n    this.rotation = gameObject.angle;\n    this.preRotation = gameObject.angle;\n    this.updateBounds();\n    this.updateCenter();\n  },\n\n  /**\r\n   * Sets acceleration, velocity, and speed to zero.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#stop\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  stop: function stop() {\n    this.velocity.set(0);\n    this.acceleration.set(0);\n    this.speed = 0;\n    this.angularVelocity = 0;\n    this.angularAcceleration = 0;\n    return this;\n  },\n\n  /**\r\n   * Copies the coordinates of this Body's edges into an object.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#getBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {ArcadeBodyBounds} obj - An object to copy the values into.\r\n   *\r\n   * @return {ArcadeBodyBounds} - An object with {x, y, right, bottom}.\r\n   */\n  getBounds: function getBounds(obj) {\n    obj.x = this.x;\n    obj.y = this.y;\n    obj.right = this.right;\n    obj.bottom = this.bottom;\n    return obj;\n  },\n\n  /**\r\n   * Tests if the coordinates are within this Body's boundary.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#hitTest\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal coordinate.\r\n   * @param {number} y - The vertical coordinate.\r\n   *\r\n   * @return {boolean} True if (x, y) is within this Body.\r\n   */\n  hitTest: function hitTest(x, y) {\n    return this.isCircle ? CircleContains(this, x, y) : RectangleContains(this, x, y);\n  },\n\n  /**\r\n   * Whether this Body is touching a tile or the world boundary while moving down.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#onFloor\r\n   * @since 3.0.0\r\n   * @see Phaser.Physics.Arcade.Body#blocked\r\n   *\r\n   * @return {boolean} True if touching.\r\n   */\n  onFloor: function onFloor() {\n    return this.blocked.down;\n  },\n\n  /**\r\n   * Whether this Body is touching a tile or the world boundary while moving up.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#onCeiling\r\n   * @since 3.0.0\r\n   * @see Phaser.Physics.Arcade.Body#blocked\r\n   *\r\n   * @return {boolean} True if touching.\r\n   */\n  onCeiling: function onCeiling() {\n    return this.blocked.up;\n  },\n\n  /**\r\n   * Whether this Body is touching a tile or the world boundary while moving left or right.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#onWall\r\n   * @since 3.0.0\r\n   * @see Phaser.Physics.Arcade.Body#blocked\r\n   *\r\n   * @return {boolean} True if touching.\r\n   */\n  onWall: function onWall() {\n    return this.blocked.left || this.blocked.right;\n  },\n\n  /**\r\n   * The absolute (non-negative) change in this Body's horizontal position from the previous step.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#deltaAbsX\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The delta value.\r\n   */\n  deltaAbsX: function deltaAbsX() {\n    return this._dx > 0 ? this._dx : -this._dx;\n  },\n\n  /**\r\n   * The absolute (non-negative) change in this Body's vertical position from the previous step.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#deltaAbsY\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The delta value.\r\n   */\n  deltaAbsY: function deltaAbsY() {\n    return this._dy > 0 ? this._dy : -this._dy;\n  },\n\n  /**\r\n   * The change in this Body's horizontal position from the previous step.\r\n   * This value is set during the Body's update phase.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#deltaX\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The delta value.\r\n   */\n  deltaX: function deltaX() {\n    return this._dx;\n  },\n\n  /**\r\n   * The change in this Body's vertical position from the previous step.\r\n   * This value is set during the Body's update phase.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#deltaY\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The delta value.\r\n   */\n  deltaY: function deltaY() {\n    return this._dy;\n  },\n\n  /**\r\n   * The change in this Body's rotation from the previous step, in degrees.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#deltaZ\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The delta value.\r\n   */\n  deltaZ: function deltaZ() {\n    return this.rotation - this.preRotation;\n  },\n\n  /**\r\n   * Disables this Body and marks it for deletion by the simulation.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function destroy() {\n    this.enable = false;\n\n    if (this.world) {\n      this.world.pendingDestroy.set(this);\n    }\n  },\n\n  /**\r\n   * Draws this Body's boundary and velocity, if enabled.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#drawDebug\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Graphics} graphic - The Graphics object to draw on.\r\n   */\n  drawDebug: function drawDebug(graphic) {\n    var pos = this.position;\n    var x = pos.x + this.halfWidth;\n    var y = pos.y + this.halfHeight;\n\n    if (this.debugShowBody) {\n      graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor);\n\n      if (this.isCircle) {\n        graphic.strokeCircle(x, y, this.width / 2);\n      } else {\n        graphic.strokeRect(pos.x, pos.y, this.width, this.height);\n      }\n    }\n\n    if (this.debugShowVelocity) {\n      graphic.lineStyle(graphic.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1);\n      graphic.lineBetween(x, y, x + this.velocity.x / 2, y + this.velocity.y / 2);\n    }\n  },\n\n  /**\r\n   * Whether this Body will be drawn to the debug display.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#willDrawDebug\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} True if either `debugShowBody` or `debugShowVelocity` are enabled.\r\n   */\n  willDrawDebug: function willDrawDebug() {\n    return this.debugShowBody || this.debugShowVelocity;\n  },\n\n  /**\r\n   * Sets whether this Body collides with the world boundary.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setCollideWorldBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [value=true] - True (collisions) or false (no collisions).\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setCollideWorldBounds: function setCollideWorldBounds(value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.collideWorldBounds = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's velocity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setVelocity\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal velocity, in pixels per second.\r\n   * @param {number} [y=x] - The vertical velocity, in pixels per second.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setVelocity: function setVelocity(x, y) {\n    this.velocity.set(x, y);\n    this.speed = Math.sqrt(x * x + y * y);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's horizontal velocity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setVelocityX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The velocity, in pixels per second.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setVelocityX: function setVelocityX(value) {\n    this.velocity.x = value;\n    var vx = value;\n    var vy = this.velocity.y;\n    this.speed = Math.sqrt(vx * vx + vy * vy);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's vertical velocity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setVelocityY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The velocity, in pixels per second.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setVelocityY: function setVelocityY(value) {\n    this.velocity.y = value;\n    var vx = this.velocity.x;\n    var vy = value;\n    this.speed = Math.sqrt(vx * vx + vy * vy);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's maximum velocity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setMaxVelocity\r\n   * @since 3.10.0\r\n   *\r\n   * @param {number} x - The horizontal velocity, in pixels per second.\r\n   * @param {number} [y=x] - The vertical velocity, in pixels per second.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setMaxVelocity: function setMaxVelocity(x, y) {\n    this.maxVelocity.set(x, y);\n    return this;\n  },\n\n  /**\r\n   * Sets the maximum speed the Body can move.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setMaxSpeed\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} value - The maximum speed value, in pixels per second. Set to a negative value to disable.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setMaxSpeed: function setMaxSpeed(value) {\n    this.maxSpeed = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's bounce.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setBounce\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal bounce, relative to 1.\r\n   * @param {number} y - The vertical bounce, relative to 1.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setBounce: function setBounce(x, y) {\n    this.bounce.set(x, y);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's horizontal bounce.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setBounceX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The bounce, relative to 1.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setBounceX: function setBounceX(value) {\n    this.bounce.x = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's vertical bounce.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setBounceY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The bounce, relative to 1.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setBounceY: function setBounceY(value) {\n    this.bounce.y = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's acceleration.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAcceleration\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal component, in pixels per second squared.\r\n   * @param {number} y - The vertical component, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAcceleration: function setAcceleration(x, y) {\n    this.acceleration.set(x, y);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's horizontal acceleration.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAccelerationX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The acceleration, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAccelerationX: function setAccelerationX(value) {\n    this.acceleration.x = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's vertical acceleration.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAccelerationY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The acceleration, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAccelerationY: function setAccelerationY(value) {\n    this.acceleration.y = value;\n    return this;\n  },\n\n  /**\r\n   * Enables or disables drag.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAllowDrag\r\n   * @since 3.9.0\r\n   * @see Phaser.Physics.Arcade.Body#allowDrag\r\n   *\r\n   * @param {boolean} [value=true] - `true` to allow drag on this body, or `false` to disable it.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAllowDrag: function setAllowDrag(value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.allowDrag = value;\n    return this;\n  },\n\n  /**\r\n   * Enables or disables gravity's effect on this Body.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAllowGravity\r\n   * @since 3.9.0\r\n   * @see Phaser.Physics.Arcade.Body#allowGravity\r\n   *\r\n   * @param {boolean} [value=true] - `true` to allow gravity on this body, or `false` to disable it.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAllowGravity: function setAllowGravity(value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.allowGravity = value;\n    return this;\n  },\n\n  /**\r\n   * Enables or disables rotation.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAllowRotation\r\n   * @since 3.9.0\r\n   * @see Phaser.Physics.Arcade.Body#allowRotation\r\n   *\r\n   * @param {boolean} [value=true] - `true` to allow rotation on this body, or `false` to disable it.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAllowRotation: function setAllowRotation(value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.allowRotation = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's drag.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setDrag\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal component, in pixels per second squared.\r\n   * @param {number} y - The vertical component, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setDrag: function setDrag(x, y) {\n    this.drag.set(x, y);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's horizontal drag.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setDragX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The drag, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setDragX: function setDragX(value) {\n    this.drag.x = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's vertical drag.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setDragY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The drag, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setDragY: function setDragY(value) {\n    this.drag.y = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's gravity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setGravity\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal component, in pixels per second squared.\r\n   * @param {number} y - The vertical component, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setGravity: function setGravity(x, y) {\n    this.gravity.set(x, y);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's horizontal gravity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setGravityX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The gravity, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setGravityX: function setGravityX(value) {\n    this.gravity.x = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's vertical gravity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setGravityY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The gravity, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setGravityY: function setGravityY(value) {\n    this.gravity.y = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's friction.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setFriction\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal component, relative to 1.\r\n   * @param {number} y - The vertical component, relative to 1.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setFriction: function setFriction(x, y) {\n    this.friction.set(x, y);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's horizontal friction.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setFrictionX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The friction value, relative to 1.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setFrictionX: function setFrictionX(value) {\n    this.friction.x = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's vertical friction.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setFrictionY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The friction value, relative to 1.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setFrictionY: function setFrictionY(value) {\n    this.friction.y = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's angular velocity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAngularVelocity\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The velocity, in degrees per second.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAngularVelocity: function setAngularVelocity(value) {\n    this.angularVelocity = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's angular acceleration.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAngularAcceleration\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The acceleration, in degrees per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAngularAcceleration: function setAngularAcceleration(value) {\n    this.angularAcceleration = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's angular drag.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAngularDrag\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The drag, in degrees per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAngularDrag: function setAngularDrag(value) {\n    this.angularDrag = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's mass.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setMass\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The mass value, relative to 1.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setMass: function setMass(value) {\n    this.mass = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's `immovable` property.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setImmovable\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [value=true] - The value to assign to `immovable`.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setImmovable: function setImmovable(value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.immovable = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's `enable` property.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setEnable\r\n   * @since 3.15.0\r\n   *\r\n   * @param {boolean} [value=true] - The value to assign to `enable`.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setEnable: function setEnable(value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.enable = value;\n    return this;\n  },\n\n  /**\r\n   * The Body's horizontal position (left edge).\r\n   *\r\n   * @name Phaser.Physics.Arcade.Body#x\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  x: {\n    get: function get() {\n      return this.position.x;\n    },\n    set: function set(value) {\n      this.position.x = value;\n    }\n  },\n\n  /**\r\n   * The Body's vertical position (top edge).\r\n   *\r\n   * @name Phaser.Physics.Arcade.Body#y\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  y: {\n    get: function get() {\n      return this.position.y;\n    },\n    set: function set(value) {\n      this.position.y = value;\n    }\n  },\n\n  /**\r\n   * The left edge of the Body's boundary. Identical to x.\r\n   *\r\n   * @name Phaser.Physics.Arcade.Body#left\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  left: {\n    get: function get() {\n      return this.position.x;\n    }\n  },\n\n  /**\r\n   * The right edge of the Body's boundary.\r\n   *\r\n   * @name Phaser.Physics.Arcade.Body#right\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  right: {\n    get: function get() {\n      return this.position.x + this.width;\n    }\n  },\n\n  /**\r\n   * The top edge of the Body's boundary. Identical to y.\r\n   *\r\n   * @name Phaser.Physics.Arcade.Body#top\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  top: {\n    get: function get() {\n      return this.position.y;\n    }\n  },\n\n  /**\r\n   * The bottom edge of this Body's boundary.\r\n   *\r\n   * @name Phaser.Physics.Arcade.Body#bottom\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  bottom: {\n    get: function get() {\n      return this.position.y + this.height;\n    }\n  }\n});\nmodule.exports = Body;","map":null,"metadata":{},"sourceType":"script"}