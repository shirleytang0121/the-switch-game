{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar FloatBetween = require('../../math/FloatBetween');\n\nvar GetEaseFunction = require('../../tweens/builders/GetEaseFunction');\n\nvar GetFastValue = require('../../utils/object/GetFastValue');\n\nvar Wrap = require('../../math/Wrap');\n/**\r\n * The returned value sets what the property will be at the START of the particle's life, on emit.\r\n * @callback EmitterOpOnEmitCallback\r\n *\r\n * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n * @param {string} key - The name of the property.\r\n * @param {number} value - The current value of the property.\r\n *\r\n * @return {number} The new value of the property.\r\n */\n\n/**\r\n * The returned value updates the property for the duration of the particle's life.\r\n * @callback EmitterOpOnUpdateCallback\r\n *\r\n * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n * @param {string} key - The name of the property.\r\n * @param {number} t - The normalized lifetime of the particle, between 0 (start) and 1 (end).\r\n * @param {number} value - The current value of the property.\r\n *\r\n * @return {number} The new value of the property.\r\n */\n\n/**\r\n * Defines an operation yielding a random value within a range.\r\n * @typedef {object} EmitterOpRandomConfig\r\n *\r\n * @property {number[]} random - The minimum and maximum values, as [min, max].\r\n */\n\n/**\r\n * Defines an operation yielding a random value within a range.\r\n * @typedef {object} EmitterOpRandomMinMaxConfig\r\n *\r\n * @property {number} min - The minimum value.\r\n * @property {number} max - The maximum value.\r\n */\n\n/**\r\n * Defines an operation yielding a random value within a range.\r\n * @typedef {object} EmitterOpRandomStartEndConfig\r\n *\r\n * @property {number} start - The starting value.\r\n * @property {number} end - The ending value.\r\n * @property {boolean} random - If false, this becomes {@link EmitterOpEaseConfig}.\r\n */\n\n/**\r\n * Defines an operation yielding a value incremented continuously across a range.\r\n * @typedef {object} EmitterOpEaseConfig\r\n *\r\n * @property {number} start - The starting value.\r\n * @property {number} end - The ending value.\r\n * @property {string} [ease='Linear'] - The name of the easing function.\r\n */\n\n/**\r\n * Defines an operation yielding a value incremented by steps across a range.\r\n * @typedef {object} EmitterOpSteppedConfig\r\n *\r\n * @property {number} start - The starting value.\r\n * @property {number} end - The ending value.\r\n * @property {number} steps - The number of steps between start and end.\r\n */\n\n/**\r\n * @typedef {object} EmitterOpCustomEmitConfig\r\n *\r\n * @property {EmitterOpOnEmitCallback} onEmit - A callback that is invoked each time the emitter emits a particle.\r\n */\n\n/**\r\n * @typedef {object} EmitterOpCustomUpdateConfig\r\n *\r\n * @property {EmitterOpOnEmitCallback} [onEmit] - A callback that is invoked each time the emitter emits a particle.\r\n * @property {EmitterOpOnUpdateCallback} onUpdate - A callback that is invoked each time the emitter updates.\r\n */\n\n/**\r\n * @classdesc\r\n * A Particle Emitter property.\r\n *\r\n * Facilitates changing Particle properties as they are emitted and throughout their lifetime.\r\n *\r\n * @class EmitterOp\r\n * @memberof Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {ParticleEmitterConfig} config - Settings for the Particle Emitter that owns this property.\r\n * @param {string} key - The name of the property.\r\n * @param {number} defaultValue - The default value of the property.\r\n * @param {boolean} [emitOnly=false] - Whether the property can only be modified when a Particle is emitted.\r\n */\n\n\nvar EmitterOp = new Class({\n  initialize: function EmitterOp(config, key, defaultValue, emitOnly) {\n    if (emitOnly === undefined) {\n      emitOnly = false;\n    }\n    /**\r\n     * The name of this property.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#propertyKey\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.propertyKey = key;\n    /**\r\n     * The value of this property.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#propertyValue\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.propertyValue = defaultValue;\n    /**\r\n     * The default value of this property.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#defaultValue\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.defaultValue = defaultValue;\n    /**\r\n     * The number of steps for stepped easing between {@link Phaser.GameObjects.Particles.EmitterOp#start} and\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#end} values, per emit.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#steps\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.steps = 0;\n    /**\r\n     * The step counter for stepped easing, per emit.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#counter\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.counter = 0;\n    /**\r\n     * The start value for this property to ease between.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#start\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.start = 0;\n    /**\r\n     * The end value for this property to ease between.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#end\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.end = 0;\n    /**\r\n     * The easing function to use for updating this property.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#ease\r\n     * @type {?function}\r\n     * @since 3.0.0\r\n     */\n\n    this.ease;\n    /**\r\n     * Whether this property can only be modified when a Particle is emitted.\r\n     *\r\n     * Set to `true` to allow only {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} callbacks to be set and\r\n     * affect this property.\r\n     *\r\n     * Set to `false` to allow both {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks to be set and affect this property.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#emitOnly\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.emitOnly = emitOnly;\n    /**\r\n     * The callback to run for Particles when they are emitted from the Particle Emitter.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#onEmit\r\n     * @type {EmitterOpOnEmitCallback}\r\n     * @since 3.0.0\r\n     */\n\n    this.onEmit = this.defaultEmit;\n    /**\r\n     * The callback to run for Particles when they are updated.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#onUpdate\r\n     * @type {EmitterOpOnUpdateCallback}\r\n     * @since 3.0.0\r\n     */\n\n    this.onUpdate = this.defaultUpdate;\n    this.loadConfig(config);\n  },\n\n  /**\r\n   * Load the property from a Particle Emitter configuration object.\r\n   *\r\n   * Optionally accepts a new property key to use, replacing the current one.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#loadConfig\r\n   * @since 3.0.0\r\n   *\r\n   * @param {ParticleEmitterConfig} [config] - Settings for the Particle Emitter that owns this property.\r\n   * @param {string} [newKey] - The new key to use for this property, if any.\r\n   */\n  loadConfig: function loadConfig(config, newKey) {\n    if (config === undefined) {\n      config = {};\n    }\n\n    if (newKey) {\n      this.propertyKey = newKey;\n    }\n\n    this.propertyValue = GetFastValue(config, this.propertyKey, this.defaultValue);\n    this.setMethods();\n\n    if (this.emitOnly) {\n      //  Reset it back again\n      this.onUpdate = this.defaultUpdate;\n    }\n  },\n\n  /**\r\n   * Build a JSON representation of this Particle Emitter property.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#toJSON\r\n   * @since 3.0.0\r\n   *\r\n   * @return {object} A JSON representation of this Particle Emitter property.\r\n   */\n  toJSON: function toJSON() {\n    return this.propertyValue;\n  },\n\n  /**\r\n   * Change the current value of the property and update its callback methods.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#onChange\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The value of the property.\r\n   *\r\n   * @return {Phaser.GameObjects.Particles.EmitterOp} This Emitter Op object.\r\n   */\n  onChange: function onChange(value) {\n    this.propertyValue = value;\n    return this.setMethods();\n  },\n\n  /**\r\n   * Update the {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and\r\n   * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks based on the type of the current\r\n   * {@link Phaser.GameObjects.Particles.EmitterOp#propertyValue}.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#setMethods\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.GameObjects.Particles.EmitterOp} This Emitter Op object.\r\n   */\n  setMethods: function setMethods() {\n    var value = this.propertyValue;\n    var t = typeof value;\n\n    if (t === 'number') {\n      //  Explicit static value:\n      //  x: 400\n      this.onEmit = this.staticValueEmit;\n      this.onUpdate = this.staticValueUpdate; // How?\n    } else if (Array.isArray(value)) {\n      //  Picks a random element from the array:\n      //  x: [ 100, 200, 300, 400 ]\n      this.onEmit = this.randomStaticValueEmit;\n    } else if (t === 'function') {\n      //  The same as setting just the onUpdate function and no onEmit (unless this op is an emitOnly one)\n      //  Custom callback, must return a value:\n\n      /*\r\n      x: function (particle, key, t, value)\r\n         {\r\n             return value + 50;\r\n         }\r\n      */\n      if (this.emitOnly) {\n        this.onEmit = value;\n      } else {\n        this.onUpdate = value;\n      }\n    } else if (t === 'object' && (this.has(value, 'random') || this.hasBoth(value, 'start', 'end') || this.hasBoth(value, 'min', 'max'))) {\n      this.start = this.has(value, 'start') ? value.start : value.min;\n      this.end = this.has(value, 'end') ? value.end : value.max;\n      var isRandom = this.hasBoth(value, 'min', 'max') || this.has(value, 'random'); //  A random starting value (using 'min | max' instead of 'start | end' automatically implies a random value)\n      //  x: { start: 100, end: 400, random: true } OR { min: 100, max: 400 } OR { random: [ 100, 400 ] }\n\n      if (isRandom) {\n        var rnd = value.random; //  x: { random: [ 100, 400 ] } = the same as doing: x: { start: 100, end: 400, random: true }\n\n        if (Array.isArray(rnd)) {\n          this.start = rnd[0];\n          this.end = rnd[1];\n        }\n\n        this.onEmit = this.randomRangedValueEmit;\n      }\n\n      if (this.has(value, 'steps')) {\n        //  A stepped (per emit) range\n        //  x: { start: 100, end: 400, steps: 64 }\n        //  Increments a value stored in the emitter\n        this.steps = value.steps;\n        this.counter = this.start;\n        this.onEmit = this.steppedEmit;\n      } else {\n        //  An eased range (defaults to Linear if not specified)\n        //  x: { start: 100, end: 400, [ ease: 'Linear' ] }\n        var easeType = this.has(value, 'ease') ? value.ease : 'Linear';\n        this.ease = GetEaseFunction(easeType);\n\n        if (!isRandom) {\n          this.onEmit = this.easedValueEmit;\n        } //  BUG: alpha, rotate, scaleX, scaleY, or tint are eased here if {min, max} is given.\n        //  Probably this branch should exclude isRandom entirely.\n\n\n        this.onUpdate = this.easeValueUpdate;\n      }\n    } else if (t === 'object' && this.hasEither(value, 'onEmit', 'onUpdate')) {\n      //  Custom onEmit and onUpdate callbacks\n\n      /*\r\n      x: {\r\n          //  Called at the start of the particles life, when it is being created\r\n          onEmit: function (particle, key, t, value)\r\n          {\r\n              return value;\r\n          },\r\n            //  Called during the particles life on each update\r\n          onUpdate: function (particle, key, t, value)\r\n          {\r\n              return value;\r\n          }\r\n      }\r\n      */\n      if (this.has(value, 'onEmit')) {\n        this.onEmit = value.onEmit;\n      }\n\n      if (this.has(value, 'onUpdate')) {\n        this.onUpdate = value.onUpdate;\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Check whether an object has the given property.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#has\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} object - The object to check.\r\n   * @param {string} key - The key of the property to look for in the object.\r\n   *\r\n   * @return {boolean} `true` if the property exists in the object, `false` otherwise.\r\n   */\n  has: function has(object, key) {\n    return object.hasOwnProperty(key);\n  },\n\n  /**\r\n   * Check whether an object has both of the given properties.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#hasBoth\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} object - The object to check.\r\n   * @param {string} key1 - The key of the first property to check the object for.\r\n   * @param {string} key2 - The key of the second property to check the object for.\r\n   *\r\n   * @return {boolean} `true` if both properties exist in the object, `false` otherwise.\r\n   */\n  hasBoth: function hasBoth(object, key1, key2) {\n    return object.hasOwnProperty(key1) && object.hasOwnProperty(key2);\n  },\n\n  /**\r\n   * Check whether an object has at least one of the given properties.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#hasEither\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} object - The object to check.\r\n   * @param {string} key1 - The key of the first property to check the object for.\r\n   * @param {string} key2 - The key of the second property to check the object for.\r\n   *\r\n   * @return {boolean} `true` if at least one of the properties exists in the object, `false` if neither exist.\r\n   */\n  hasEither: function hasEither(object, key1, key2) {\n    return object.hasOwnProperty(key1) || object.hasOwnProperty(key2);\n  },\n\n  /**\r\n   * The returned value sets what the property will be at the START of the particles life, on emit.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#defaultEmit\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n   * @param {string} key - The name of the property.\r\n   * @param {number} [value] - The current value of the property.\r\n   *\r\n   * @return {number} The new value of hte property.\r\n   */\n  defaultEmit: function defaultEmit(particle, key, value) {\n    return value;\n  },\n\n  /**\r\n   * The returned value updates the property for the duration of the particles life.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#defaultUpdate\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n   * @param {string} key - The name of the property.\r\n   * @param {number} t - The T value (between 0 and 1)\r\n   * @param {number} value - The current value of the property.\r\n   *\r\n   * @return {number} The new value of the property.\r\n   */\n  defaultUpdate: function defaultUpdate(particle, key, t, value) {\n    return value;\n  },\n\n  /**\r\n   * An `onEmit` callback that returns the current value of the property.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#staticValueEmit\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The current value of the property.\r\n   */\n  staticValueEmit: function staticValueEmit() {\n    return this.propertyValue;\n  },\n\n  /**\r\n   * An `onUpdate` callback that returns the current value of the property.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#staticValueUpdate\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The current value of the property.\r\n   */\n  staticValueUpdate: function staticValueUpdate() {\n    return this.propertyValue;\n  },\n\n  /**\r\n   * An `onEmit` callback that returns a random value from the current value array.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#randomStaticValueEmit\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The new value of the property.\r\n   */\n  randomStaticValueEmit: function randomStaticValueEmit() {\n    var randomIndex = Math.floor(Math.random() * this.propertyValue.length);\n    return this.propertyValue[randomIndex];\n  },\n\n  /**\r\n   * An `onEmit` callback that returns a value between the {@link Phaser.GameObjects.Particles.EmitterOp#start} and\r\n   * {@link Phaser.GameObjects.Particles.EmitterOp#end} range.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#randomRangedValueEmit\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n   * @param {string} key - The key of the property.\r\n   *\r\n   * @return {number} The new value of the property.\r\n   */\n  randomRangedValueEmit: function randomRangedValueEmit(particle, key) {\n    var value = FloatBetween(this.start, this.end);\n\n    if (particle && particle.data[key]) {\n      particle.data[key].min = value;\n    }\n\n    return value;\n  },\n\n  /**\r\n   * An `onEmit` callback that returns a stepped value between the\r\n   * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}\r\n   * range.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#steppedEmit\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The new value of the property.\r\n   */\n  steppedEmit: function steppedEmit() {\n    var current = this.counter;\n    var next = this.counter + (this.end - this.start) / this.steps;\n    this.counter = Wrap(next, this.start, this.end);\n    return current;\n  },\n\n  /**\r\n   * An `onEmit` callback that returns an eased value between the\r\n   * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}\r\n   * range.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#easedValueEmit\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n   * @param {string} key - The name of the property.\r\n   *\r\n   * @return {number} The new value of the property.\r\n   */\n  easedValueEmit: function easedValueEmit(particle, key) {\n    if (particle && particle.data[key]) {\n      var data = particle.data[key];\n      data.min = this.start;\n      data.max = this.end;\n    }\n\n    return this.start;\n  },\n\n  /**\r\n   * An `onUpdate` callback that returns an eased value between the\r\n   * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}\r\n   * range.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#easeValueUpdate\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n   * @param {string} key - The name of the property.\r\n   * @param {number} t - The T value (between 0 and 1)\r\n   *\r\n   * @return {number} The new value of the property.\r\n   */\n  easeValueUpdate: function easeValueUpdate(particle, key, t) {\n    var data = particle.data[key];\n    return (data.max - data.min) * this.ease(t) + data.min;\n  }\n});\nmodule.exports = EmitterOp;","map":null,"metadata":{},"sourceType":"script"}